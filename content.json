{"meta":{"title":"周贺涛的博客","subtitle":null,"description":null,"author":null,"url":"http://example.com","root":"/"},"pages":[{"title":"Java学习","date":"2022-11-21T02:06:37.946Z","updated":"2022-11-21T02:06:37.946Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Java介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 Java标识符和关键字 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。 名称 说明字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 public 它用来表示公共类。另外，static 和 void 也是关键字，它们的使用将在本教程后面的章节中详细介绍。 final 是定义常量的关键字 final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量 声明变量 12345678 char usersex=&#x27;女&#x27;; // 直接赋值 ----------------------- String username; // 先声明 username =&quot;琪琪&quot;; // 后赋值-------------------------- String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 成员变量名称 修饰 访问 生命周期全局变量（实例变量）| 无 static 修饰 | 对象名.变量名 只要对象被当作引用，实例变量就将存在静态变量（类变量） | 用 static 修饰 | 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 123456 public class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = &quot;C语言中文网&quot;; // 成员变量、静态变量(类变量) static String URL = &quot;http://c.biancheng.net&quot;; // 成员变量、静态变量(类变量)&#125; 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 1234567891011 public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(&quot;s=&quot; + s); System.out.println(&quot;a=&quot; + a); &#125; System.out.println(&quot;a=&quot; + a); &#125;&#125;"},{"title":"分类","date":"2022-09-11T09:42:31.000Z","updated":"2022-11-01T05:58:41.601Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"vue2vue 简介Vue 是一套用于构建用户界面的 渐进式框架 。与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 小程序浅谈小程序在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来： “ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。 小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M；2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。 NodejsNodejs简介以下引自 Node.js 官网：Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 不是编程语言 也不是框架和库 是一个 JavaScript 运行时（环境） 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 文件 IO 网络 IO 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 Node 的特点事件驱动 非阻塞 IO（异步） 模型 单线程 跨平台 Nuxtjs官网介绍关于 Nuxt.js2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。 Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（Microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 javaJava介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 更多内容后续更新 敬请期待 ！ 如有问题请联系&#x31;&#54;&#x37;&#56;&#x37;&#x37;&#49;&#x33;&#51;&#54;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109; 欢迎指导"},{"title":"Java学习","date":"2022-11-08T06:16:44.309Z","updated":"2022-11-08T06:16:44.309Z","comments":true,"path":"java-about/index.html","permalink":"http://example.com/java-about/index.html","excerpt":"","text":"Java介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 Java标识符和关键字 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。 名称 说明字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 public 它用来表示公共类。另外，static 和 void 也是关键字，它们的使用将在本教程后面的章节中详细介绍。 final 是定义常量的关键字 final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量 声明变量 12345678 char usersex=&#x27;女&#x27;; // 直接赋值 ----------------------- String username; // 先声明 username =&quot;琪琪&quot;; // 后赋值-------------------------- String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 成员变量名称 修饰 访问 生命周期全局变量（实例变量）| 无 static 修饰 | 对象名.变量名 只要对象被当作引用，实例变量就将存在静态变量（类变量） | 用 static 修饰 | 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 123456 public class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = &quot;C语言中文网&quot;; // 成员变量、静态变量(类变量) static String URL = &quot;http://c.biancheng.net&quot;; // 成员变量、静态变量(类变量)&#125; 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 1234567891011 public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(&quot;s=&quot; + s); System.out.println(&quot;a=&quot; + a); &#125; System.out.println(&quot;a=&quot; + a); &#125;&#125;"},{"title":"Nuxtjs学习","date":"2023-03-28T03:04:11.354Z","updated":"2023-03-28T03:04:11.354Z","comments":true,"path":"Nuxt-about/index.html","permalink":"http://example.com/Nuxt-about/index.html","excerpt":"","text":"|官网介绍关于 Nuxt.js 2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。 Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（Microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxtjs特性 基于 Vue.js 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ES2015+ 语法支持 打包和压缩 JS 和 CSS HTML 头部标签管理 本地开发支持热加载 集成 ESLint 支持各种样式预处理器： SASS、LESS、 Stylus 等等 支持 HTTP&#x2F;2 推送* Nuxtjs 和 Vue的区别 路由 nuxt按照 pages 文件夹的目录结构自动生成路由 vue需在 src&#x2F;router&#x2F;index.js 手动配置路由 nuxt nuxt 类似 router-view , nuxt-link 类似 router-link webpack配置 nuxt内置webpack，允许根据服务端需求，在 nuxt.config.js 中的build属性自定义构建webpack的配置，覆盖默认配置 vue关于webpack的配置存放在build文件夹下 项目入口 nuxt: 没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置指定。 vue: &#x2F;src&#x2F;main.js，在main.js可以做一些全局注册的初始化工作； 网页渲染流程 vue: 客户端渲染，先下载js后，通过ajax来渲染页面； nuxt： 服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以做到无需发起ajax请求； build后目标产物不同 vue: dist uxt: .nuxt 安装123$ npx create-nuxt-app &lt;项目名&gt;// 或$ yarn create nuxt-app &lt;项目名&gt; 目录结构 资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录 layouts 用于组织应用的布局组件。 middleware 目录 用于存放应用的中间件。 页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。 插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 &#x2F; 下。 store 目录 用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。 nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。 路由 Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。 123 &lt;template&gt; &lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt;&lt;/template&gt; 举例 pages 文件下 12345pages/ --| user/ -----| index.vue -----| one.vue --| index.vue 生成的路由12345678910111213141516171819router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;user&#x27;, path: &#x27;/user&#x27;, component: &#x27;pages/user/index.vue&#x27; &#125;, &#123; name: &#x27;user-one&#x27;, path: &#x27;/user/one&#x27;, component: &#x27;pages/user/one.vue&#x27; &#125; ]&#125; 动态路由123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;users-id&#x27;, path: &#x27;/users/:id?&#x27;, component: &#x27;pages/users/_id.vue&#x27; &#125;, &#123; name: &#x27;slug&#x27;, path: &#x27;/:slug&#x27;, component: &#x27;pages/_slug/index.vue&#x27; &#125;, &#123; name: &#x27;slug-comments&#x27;, path: &#x27;/:slug/comments&#x27;, component: &#x27;pages/_slug/comments.vue&#x27; &#125; ]&#125;"},{"title":"Express内容","date":"2023-03-28T02:56:56.080Z","updated":"2023-03-28T02:56:56.080Z","comments":true,"path":"node-about/express.html","permalink":"http://example.com/node-about/express.html","excerpt":"","text":"|Express 介绍 Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它可以轻松构建各种web应用，例如： 接口服务 传统的web网站 开发工具集成等（例如webpack的devServer） Express本身是极简的，仅仅提供了web开发的基础功能，但是它通过中间件的方式集成了许许多多的外部插件来处理HTTP请求。 body-parser：解析HTTP请求体 compression：压缩HTTP响应 cookie-parser：解析cookie 数据 cors：处理跨域资源请求 morgan：HTTP请求日志记录 Express中间件的特性固然强大，但是它所提供的灵活性是一把双刃剑。 它让Express本身变得更加灵活和简单 缺点在于虽然有一些中间件包可以解决几乎所有问题或需求，但是挑选合适的包有时也会成为一个挑战 有很多流行框架基于 Express Express 官网 express 安装 参考文档：http://expressjs.com/en/starter/installing.html 123456789 # 创建并切换到 myapp 目录mkdir myappcd myapp# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express Hello World 123456789101112131415// 0. 加载 Expressconst express = require(&quot;express&quot;);// 1. 调用 express() 得到一个 app// 类似于 http.createServer()const app = express();// 2. 设置请求对应的处理函数// 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);// 3. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log(&quot;app listening on port 3000!&quot;)); 基本路由参考文档：http://expressjs.com/en/starter/basic-routing.html 路由（Routing）是由一个 URI（或者叫路径标识）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何处理响应客户端请求。 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个&#x2F;些函数将被执行。 路由的定义的结构如下： 1app.METHOD(PATH, HANDLER); ● app 是 express 实例● METHOD 是一个 HTTP 请求方法● PATH 是服务端路径（定位标识）● HANDLER 是当路由匹配到时需要执行的处理函数 举例1234567891011121314// 当你以 GET 方法请求 / 的时候，执行对应的处理函数app.get(&quot;/&quot;, function(req, res) &#123; res.send(&quot;Hello World!&quot;);&#125;);// 当你以 POST 方法请求 / 的时候，指定对应的处理函数app.post(&quot;/&quot;, function(req, res) &#123; res.send(&quot;Got a POST request&quot;);&#125;);app.put(&quot;/user&quot;, function(req, res) &#123; res.send(&quot;Got a PUT request at /user&quot;);&#125;);app.delete(&quot;/user&quot;, function(req, res) &#123; res.send(&quot;Got a DELETE request at /user&quot;);&#125;); 路由路径路由路径与请求方法结合，定义了可以进行请求的端点。路由路径可以是字符串，字符串模式或正则表达式。字符?，+，*，和()是他们的正则表达式的对应的子集。连字符（-）和点(.)由基于字符串的路径按字面意义进行解释。如果您需要$在路径字符串中使用美元字符()，请将其转义([并括在和中]) 例如，“&#x2F;data &#x2F;$book”处用于请求的路径字符串将为$ Express使用path-to-regexp来匹配路由路径; 有关定义路由路径的所有可能性，请参见正则表达式路径文档。Express Route Tester尽管不支持模式匹配，但却是用于测试基本Express路由的便捷工具。 ● *查询字符串不是路由路径的一部分。 动态路径123app.get(&quot;/users/:userId/books/:bookId&quot;, function(req, res) &#123; res.send(req.params);&#125;); 路径参数路由参数被命名为URL段，用于捕获URL中在其位置处指定的值。捕获的值将填充到req.params对象中，并将路径中指定的route参数的名称作为其各自的键。 123Route path: /flights/ :from-:toRequest URL:http:// localhost: 3000/flights/LAX-SFOreq.params : &#123; &quot;from&quot; : &quot;LAX&quot;,&quot;to&quot; : &quot;SFO&quot; &#125; 路径参数的名称必须由“文字字符”([A-Za-zO-9_]）组成。由于连字符(-）和点（.)是按字面解释的，因此可以将它们与路由参数一起使用，以实现有用的目的。 123Route path : /plantae/ :genus.:speciesRequest URL: http : // localhost : 3000/plantae/Prunus.persicareq.params : &#123; &quot;genus &quot; : &quot;prunus &quot; , &quot; species &quot; : &quot;persica&quot; &#125; 路由处理方法app.route() express.Router 1234567891011121314151617onst express = require(&quot;express&quot;);const router = express.Router();router.get(&quot;/&quot;, function(req, res) &#123; res.send(&quot;home page&quot;);&#125;);router.get(&quot;/about&quot;, function(req, res) &#123; res.send(&quot;About page&quot;);&#125;);const router = require(&quot;./router&quot;);// ...app.use(router);module.exports = router; 在 Express 中获取客户端请求参数的三种方式例如，有一个地址：&#x2F;a&#x2F;b&#x2F;c?foo&#x3D;bar&amp;id&#x3D;123 查询字符串参数1console.log(req.query); 请求体参数POST 请求才有请求体，我们需要单独配置 body-parser 中间件才可以获取。只要程序中配置了 body-parser 中间件，我们就可以通过 req.body 来获取表单 POST 请求体数据。 12req.body// =&gt; 得到一个请求体对象 动态的路径参数在 Express 中，支持把一个路由设计为动态的。例如： 12345678910111213141516171819202122232425262728293031// /users/:id 要求必须以 /users/ 开头，:id 表示动态的，1、2、3、abc、dnsaj 任意都行// 注意：:冒号很重要，如果你不加，则就变成了必须 === /users/id// 为啥叫 id ，因为是动态的路径，服务器需要单独获取它，所以得给它起一个名字// 那么我们就可以通过 req.params 来获取路径参数app.get(&quot;/users/:id&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /users/*/abc// req.params.idapp.get(&quot;/users/:id/abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /users/*/*// req.params.id// req.params.abcapp.get(&quot;/users/:id/:abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /*/*/*// req.params.usersapp.get(&quot;/:users/:id/:abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /*/id/*app.get(&quot;/:users/id/:abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;); 请求和响应Express应用使用路由回调函数的参数：request和response 对象来处理请求和响应的数据。Express不对Node.js 已有的特性进行二次抽象，只是在它之上扩展了web应用所需的基本功能。● 内部使用的还是 http 模块● 请求对象继承自: http.IncomingMessage● 响应对象继承自: http.ServerResponse 处理静态资源12345678910111213141516// 开放 public 目录中的资源// 不需要访问前缀app.use(express.static(&quot;public&quot;));// 开放 files 目录资源，同上app.use(express.static(&quot;files&quot;));// 开放 public 目录，限制访问前缀app.use(&quot;/public&quot;, express.static(&quot;public&quot;));// 开放 public 目录资源，限制访问前缀app.use(&quot;/static&quot;, express.static(&quot;public&quot;));// 开放 publi 目录，限制访问前缀// path.join(__dirname, &#x27;public&#x27;) 会得到一个动态的绝对路径app.use(&quot;/static&quot;, express.static(path.join(__dirname, &quot;public&quot;))); Nodejs + express案例"},{"title":"Node+express案例","date":"2023-03-28T02:57:35.518Z","updated":"2023-03-28T02:57:35.518Z","comments":true,"path":"node-about/node-case.html","permalink":"http://example.com/node-about/node-case.html","excerpt":"","text":"|登陆页面&#x2F;html版本(静态资源) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const http = require(&#x27;http&#x27;)const app = http.createServer()const fs = require(&#x27;fs&#x27;)const url = require(&#x27;url&#x27;)const path = require(&#x27;path&#x27;)const &#123; json &#125; = require(&#x27;express&#x27;)let lodash = require(&#x27;lodash&#x27;)app.on(&#x27;request&#x27;, (req, res) =&gt; &#123; req.url = req.url.toLowerCase() let urlObj = url.parse(req.url, true) if (req.url == &#x27;/&#x27; || req.url == &#x27;index&#x27; || req.url == &#x27;submit&#x27;) &#123; fs.readFile(path.join(__dirname, &#x27;view&#x27;, &#x27;submit.html&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.end(data) &#125;) &#125; else if (req.url == &#x27;/login&#x27;) &#123; fs.readFile(path.join(__dirname, &#x27;view&#x27;, &#x27;login.html&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.end(data) &#125;) &#125; else if(req.url == &quot;/home&quot;)&#123; fs.readFile(path.join(__dirname, &#x27;view&#x27;, &#x27;home.html&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.end(data) &#125;) &#125; else if (req.url.startsWith(&#x27;/add&#x27;) &amp;&amp; req.method == &#x27;GET&#x27;) &#123; let content = urlObj.query fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;kaoshi.json&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err &amp;&amp; err.code != &#x27;ENOENT&#x27;) throw err let arr = JSON.parse(data || &#x27;[]&#x27;) arr.push(content) fs.writeFile(path.join(__dirname,&#x27;data&#x27;,&#x27;kaoshi.json&#x27;),JSON.stringify(arr,null,&#x27; &#x27;),(err)=&gt;&#123; if(err) throw err res.writeHead(302, &#x27;Found&#x27;, &#123; &#x27;Location&#x27;: &#x27;login&#x27; &#125;) res.end() &#125;) &#125;) &#125; else if(req.url.startsWith(&#x27;/out&#x27;)&amp;&amp; req.method==&#x27;GET&#x27;)&#123; let count = urlObj.query fs.readFile(path.join(__dirname,&#x27;data&#x27;,&#x27;kaoshi.json&#x27;),&#x27;utf-8&#x27;,(err,data)=&gt;&#123; if(err) throw err let arr = JSON.parse(data) var m = lodash.findIndex(arr, count) if(m&gt;=0)&#123; res.writeHead(302, &#x27;Found&#x27;, &#123; &#x27;Location&#x27;: &#x27;/home&#x27; &#125;) res.end() &#125; &#125;) &#125;&#125;).listen(3000, () =&gt; &#123; console.log(&quot;服务启动,请访问:http://localhost:3000&quot;)&#125;) express + cors跨域123var app = express();var cors = require(&quot;cors&quot;) //cors同源跨域app.use(cors) header跨域12345678910111213app.all(&#x27;*&#x27;, function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //跨域 res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;X-Requested-With&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;); res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;); res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) // res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;content-type,curUserId,token,platform&#x27;); // res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;curUserId,token,platform&#x27;); res.header(&#x27;X-Powered-By&#x27;, &#x27;3.2.1&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next();&#125;) 用户 注册 &#x2F; 登陆 &#x2F; 验证注册1234567891011121314151617181920212223242526272829app.use(cors()) //设置cores同源跨域app.post(&#x27;/user/add&#x27;, urlencodedParser, (req, res) =&gt; &#123; let content = req.body fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var m = lodash.findIndex(str, content);//判断账户名密码是否正确 var n = lodash.findIndex(str, function (o) &#123;//判断用户名是否存在 return o.userName === content.userName; &#125;); if (m &gt;= 0 || n &gt;= 0) &#123; res.send(&#123; code: 201, message: &quot;该用户已经存在&quot; &#125;) &#125; else &#123; content.id = JSON.parse(data).length + 1 content.time = moment(Date.now()).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) //用户注册时间 const secret = &#x27;yating&#x27;; content.token = jwt.sign(content, secret)//生成用户专属令牌token var arr = JSON.parse(data || &quot;[]&quot;) arr.push(content) fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), JSON.stringify(arr, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(&#123; code: 200, message: &quot;已添加该用户&quot; &#125;) &#125;) &#125;) &#125; &#125;)&#125;) 登陆12345678910111213141516app.use(cors())app.post(&quot;/login/add&quot;, urlencodedParser, (req, res) =&gt; &#123; let content = req.body console.log(content); fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err var arr = JSON.parse(data) var m = lodash.findIndex(arr, content) if (m &gt;= 0) &#123; const token = jwtSign(&#123;_id:arr[m].id&#125;) //返回带有时效的token res.send(&#123; code: 200, message: &quot;登陆成功&quot;, token:token &#125;) &#125; else &#123; res.send(&#123; code: 201, message: &quot;登陆失败该用户不存在/密码错误&quot; &#125;) &#125; &#125;)&#125;) 验证token jwt插件1234567891011121314151617181920212223242526272829//utils/jswconst jwt = require(&#x27;jsonwebtoken&#x27;)const jwtKey = &#x27;junkaicool&#x27; // token生成的密匙const jwtSign = (data) =&gt; &#123; // token生成函数，有效时间为一个小时 const token = jwt.sign(data, jwtKey, &#123;expiresIn:60*60&#125;) return token&#125;const jwtCheck = (req, res, next) =&gt; &#123; // token验证函数 const token = req.headers.token jwt.verify(token, jwtKey, (err, data) =&gt; &#123; if (err) &#123; res.send(&#123; code: &#x27;99999999&#x27;, msg: &#x27;token无效&#x27; &#125;) &#125; else &#123; req.jwtInfo = data next() &#125; &#125;)&#125;module.exports = &#123; jwtSign, jwtCheck&#125; 12345678910//验证是否登陆const &#123;jwtCheck&#125; = require(&#x27;./utils/jsw&#x27;)// header传递token值判断是否登陆 和token值是否失效app.get(&quot;/token&quot;,jwtCheck,(req,res)=&gt;&#123; res.send(&#123; code:200, meg:&quot;验证成功&quot; &#125;)&#125;) 获取博客列表数据1234567891011//获取博客所有文章app.get(&quot;/blog/list&quot;, (req, res) =&gt; &#123; fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.send(&#123; code:200, message:&quot;数据获取成功&quot;, list:data &#125;) &#125;)&#125;) 添加博客12345678910111213141516171819202122232425//添加博客app.post(&quot;/blog/add&quot;, urlencodedParser, (req, res) =&gt; &#123; let content = req.body//获取传递的数据 fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err if(content.categoryId!=undefined)&#123; content.id = JSON.parse(data).length + 1 //id content.categoryId = Number(content.categoryId) //用户id content.time = moment(Date.now()).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)//生成添加时间 moment插件 var arr = JSON.parse(data || &quot;[]&quot;) arr.push(content) fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), JSON.stringify(arr, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(data) &#125;) &#125;) &#125;else&#123; res.send(&#123; code:201, message:&quot;缺少必要参数&quot; &#125;) &#125; &#125;)&#125;) 获取单条博客数据123456789101112131415161718//获取单条博客文章详情app.post(&quot;/blog/list/:id&quot;, (req, res) =&gt; &#123; var arg = url.parse(req.url).path var ids = arg.match(/\\d+/g).join(&quot; &quot;) fs.readFile(path.join(__dirname, &quot;data&quot;, &quot;list.json&quot;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var n = lodash.findIndex(str, function (o) &#123; return o.id == ids; &#125;) if (n &gt;= 0) &#123; res.send(str[n]) &#125; else &#123; res.send(&#123; code: 201, message: &quot;暂无此数据&quot; &#125;) &#125; &#125;)&#125;) 删除博客123456789101112131415161718//删除博客文章app.delete(&quot;/blog/list/delete/:id&quot;, (req, res) =&gt; &#123; var arg = url.parse(req.url).path var ids = arg.match(/\\d+/g).join(&quot; &quot;) fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var s = lodash.remove(str, function (n) &#123; return n.id == ids; &#125;); fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), JSON.stringify(str, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(data) &#125;) &#125;) &#125;)&#125;) 博客更新12345678910111213141516171819202122232425//更新博客app.put(&quot;/blog/list/put/:id&quot;, (req, res) =&gt; &#123; let content = req.body var arg = url.parse(req.url).path var ids = arg.match(/\\d+/g).join(&quot; &quot;) fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var n = lodash.findIndex(str, function (o) &#123; return o.id == ids; &#125;) if (n &gt;= 0) &#123; content.time = moment(Date.now()).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) content.id = str[n].id str[n] = content fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), JSON.stringify(str, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(data) &#125;) &#125;) &#125; else &#123; res.send(&#123; code: 201, message: &quot;暂无数据&quot; &#125;) &#125; &#125;)&#125;)"},{"title":"小程序","date":"2022-09-11T10:26:06.000Z","updated":"2023-03-28T03:06:17.818Z","comments":true,"path":"smallcx/index.html","permalink":"http://example.com/smallcx/index.html","excerpt":"","text":"|浅谈小程序 在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来： “ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。 小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M； 2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。 什么样的应用适合使用小程序开发?虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。 基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。 逻辑简单：是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。 使用低频：是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。 对性能要求不极致：是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。 当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现 小程序与H5，原生应用有何区别？很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？ H5 移动应用我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。 同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。 原生应用原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。 既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。 混合应用混合应用一般被称为 Hybrid App。简单来说，混合应用就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳） ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。 我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。 小程序严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。 相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；能获取更多系统权限，完成更加丰富的产品设计；可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；"},{"title":"标签","date":"2019-11-16T02:46:27.000Z","updated":"2023-03-28T02:06:03.565Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"React","date":"2022-09-13T12:11:58.529Z","updated":"2022-09-13T12:11:58.529Z","comments":true,"path":"react-about/index.html","permalink":"http://example.com/react-about/index.html","excerpt":"","text":"react简介React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。React 中拥有多种不同类型的组件，我们先从 React.Component 的子类开始介绍： 12345678910111213141516class ShoppingList extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;shopping-list&quot;&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 用法示例: &lt;ShoppingList name=&quot;Mark&quot; /&gt; 我们马上会讨论这些又奇怪、又像 XML 的标签。我们通过使用组件来告诉 React 我们希望在屏幕上看到什么。当数据发生改变时，React 会高效地更新并重新渲染我们的组件。 创建react项目1npx create-react-app 项目名 清空src目录创建index.js 12rm src/*touch src/index.js index.js 入口js: 用react-dom渲染注入点 12const root = ReactDOM.createRoot(dom节点)root.render(&lt;App /&gt;) JSXJSX: Javascript + XMLJSX是一个语法糖，React.createElement的语法糖 React.createElement定义 1React.createElement(组件, [属性props], [...children]) // 返回jsx元素 12345678910const element1 = &lt;h1&gt;hello&lt;/h1&gt; // element1的值叫做jsx的元素 // h1叫做jsx的组件const element2 = &lt;App /&gt; // element2是元素 // App是组件const element3 = &lt;button id=&#x27;okBtn&#x27; type=&#x27;button&#x27;&gt;OK&lt;/button&gt;const element4 = ( &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;/select&gt;) React.createElement函数表达以上的代码(Babel转换成下面的代码)： 123456789const element1 = React.createElement(&#x27;h1&#x27;, null, &#x27;hello&#x27;)const element2 = React.createElement(App)const element3 = React.createElement( &#x27;button&#x27;, &#123;id: &#x27;okBtn&#x27;, type: &#x27;button&#x27;&#125;, &#x27;OK&#x27;)const element4 = React.createElement( &#x27;select&#x27;, &#123;name: &#x27;city&#x27;&#125;, React.createElement(&#x27;option&#x27;, &#123;value: &quot;1&quot;&#125;, &#x27;北京&#x27;), React.createElement(&#x27;option&#x27;, &#123;value: &quot;2&quot;&#125;, &#x27;上海&#x27;)) html和jsx的转换关系第一点：jsx要符合xml的标准，jsx的html组件必须名字为小写： tag必须成对出现(&lt;div&gt;...&lt;/div&gt;) 或者自结束标签(&lt;input /&gt;)html的tag结构不严谨1234const el1 = &lt;h1&gt;&lt;/H1&gt; // ❌ 大小写不一样const el2 = &lt;H1&gt;&lt;/H1&gt; // ❌ 不是html里的h1对应的组件，而是自定义H1组件const el3 = &lt;img &gt; // ❌ 无关闭标记const el4 = &lt;div&gt;&lt;b&gt;hello &lt;i&gt;world&lt;/b&gt;&lt;/i&gt;&lt;/div&gt; // ❌ 没有正确嵌套 第二点，jsx的属性名称由两个单词组成，用驼峰形式书写；html属性是不区分大小写的。 12&lt;input value=&#x27;&#x27; autoComplete=&#x27;on&#x27; data-id=&#x27;name&#x27;&gt;&lt;td colSpan=&#x27;2&#x27;&gt; 第三点：有一些属性名称在jsx中改变了: class -&gt; className for -&gt; htmlFor因为class和for都是js里的关键字，避免用关键字命名 第四点：有一些属性是html没有的 key - 值字符串，为了表示元素唯一性 ref - 为了引用dom元素或者jsx元素 defaultValue 用来代替 value属性 defaultChecked 用来代替checked属性 1234&lt;input type=&#x27;text&#x27; value=&#x27;abc&#x27;/&gt;&lt;input type=&#x27;text&#x27; defaultValue=&#x27;abc&#x27;/&gt;&lt;input type=&#x27;checkbox&#x27; checked /&gt;&lt;input type=&#x27;checkbox&#x27; defaultChecked /&gt; 第五点，html的style是字符串，jsx的style属性是object（dom里style对象的方式书写） 1&lt;span style=&#x27;font-size: 18px; color: red; text-decoration: underline&#x27;&gt;Hello World&lt;/span&gt; 1234&lt;span style=&#123;&#123;fontSize: &quot;18px&quot;, color: &quot;red&quot;, textDecoration: &quot;underline&quot;&#125;&#125;&gt;Hello World&lt;/span&gt;const styles = &#123;fontSize: &quot;18px&quot;, color: &quot;red&quot;, textDecoration: &quot;underline&quot;&#125;&lt;span style=&#123;styles&#125;&gt;Hello World&lt;/span&gt; 第六点，开关属性（cheched, disabled, readOnly）值是布尔类型 12345678&lt;input type=&#x27;text&#x27; readOnly=&#123;true&#125; /&gt;&lt;input type=&#x27;text&#x27; readOnly=&quot;true&quot; /&gt; &#123;/*错*/&#125;&lt;div className=&quot;container&quot;&gt;&lt;/div&gt;&lt;div className=&#123;&quot;container&quot;&#125;&gt;&lt;/div&gt;&lt;Counter value=&quot;1&quot; /&gt;&lt;Counter value=&#123;1&#125; /&gt; 第七点，children位置（指元素标记之间的内容&lt;b&gt;...&lt;/b&gt;）用字符串表达式，里面的内容会自动转义（html特殊字符会转换成html entity，&gt; 转换成 &amp;gt; ）避免XSS攻击 12&lt;div&gt;&#123;&quot;&lt;b&gt;hello&lt;/b&gt; world&quot;&#125;&lt;/div&gt;&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &quot;&lt;b&gt;hello&lt;/b&gt; world&quot;&#125;&#125;&gt;&lt;/div&gt; 第八点，html的注释&lt;!-- 注释内容 --&gt;，jsx的注释&#123;/* 注释 */&#125; 第九点，html里换行也是一个空格，jsx里换行不是空格 123&lt;span&gt;红灯&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;&lt;!-- 红灯 绿灯 --&gt; 123456&lt;span&gt;红灯&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;&#123;/* 红灯绿灯 */&#125;&lt;span&gt;红灯&lt;/span&gt;&#123;&#x27; &#x27;&#125;&lt;span&gt;绿灯&lt;/span&gt; 表达式使用表达式用&#123;表达式&#125;，表达式只能写一个语句（if&#x2F;for&#x2F;while&#x2F;switch不能在表达式里使用） 表达式可以用在children位置或者属性值位置 children位置的表达式里不能是普通object 有一些值放在表达式里没有任何渲染内容：false&#x2F;true&#x2F;null&#x2F;undefined&#x2F;NaN 12345678910111213141516171819&#123;1&#125;&#123;&#x27;1&#x27;&#125;&#123;false&#125;&#123;null&#125;&#123;1+1&#125;&#123;Math.random()&#125;&#123;&lt;div&gt;123&lt;/div&gt;&#125;&#123;Math.random() &gt; 0.5 ? &#x27;正面&#x27; : &#x27;背面&#x27;&#125;&#123;[1,2,3].map(n =&gt; n * 2).join(&#x27;, &#x27;)&#125;&#123;(function()&#123; if(Math.random()&gt;0.5) &#123; return 1 &#125; else &#123; return 2 &#125;&#125;)()&#125;&lt;div className=&#123;`row $&#123;index%2 ? &#x27;bg&#x27; : &#x27;&#x27;&#125;`&#125;&gt;&lt;/div&gt;&lt;div&gt;&#123;[1,2,3]&#125;&lt;/div&gt;&lt;ul&gt;&#123;[&lt;li&gt;1&lt;/li&gt;,&lt;li&gt;3&lt;/li&gt;,&lt;li&gt;2&lt;/li&gt;]&#125;&lt;/ul&gt; 表达式的扩展语法 123456789const params = &#123; className: &#x27;abc&#x27;, style: &#123;border: &#x27;1px solid red&#x27;&#125;, defaultValue: &#x27;hello&#x27;&#125;&lt;input className=&#123;params.className&#125; style=&#123;params.style&#125; defaultValue=&#123;params.defaultValue&#125; /&gt;&lt;input className=&#x27;xyz&#x27; &#123;...params&#125; className=&#x27;a&#x27;/&gt;"},{"title":"computed和method","date":"2022-09-12T11:23:00.620Z","updated":"2022-09-12T11:23:00.620Z","comments":true,"path":"vue-computed/com-and-met.html","permalink":"http://example.com/vue-computed/com-and-met.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt; &lt;!-- 插值表达式的实现 简单的js逻辑表达式 --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName +&#x27;-&#x27;+ lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName&#125;&#125; - &#123;&#123;lastName&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- 更复杂的通过方法的实现 methods中的方法调用一次就会执行一次 如果数据不需要更新 会造成性能的浪费--&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // 定义到data中的数据默认会被响应式监听 firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27; &#125;, methods: &#123; // fullName() &#123; // console.log(111); // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125;, // 计算属性computed: 计算属性的值本身不存在 是需要通过计算得到的 // 底层也是通过object.defineProperty来实现的 // computed 与 methods的区别 // 1、是否存在缓存: methods调用一次执行一次 // computed第一次调用时会将结果缓存 (有缓存)、后续调用在所依赖的数据不发生变化的前提下 直接返回缓存的结果 =&gt; 复用率高 提升性能 // 2、调用方式不同: methods使用时，一般情况需要加括号，而computed则不需要 // 3、绑定方式不同: methods是单向数据绑定 只有getter, computed是双向数据绑定, 有setter和getter // 使用场景 // 某个属性的值需要来自多个属性的简单计算或者复杂逻辑计算得出的值时, 推荐使用computed属性, 比如购物车的总价计算 computed: &#123; // 完整写法 fullName: &#123; // get作用: 当使用到fullName的时候 默认会调用get方法 // get特点: // 1、初次使用计算属性的时候会执行 // 2、当依赖的响应式数据发生变化的时候会执行 get() &#123; console.log(111); return this.firstName + &#x27;-&#x27; + this.lastName &#125;, // 如果需要修改计算属性 需要提供一个set方法 // 并且这个set方法中要能够引起依赖的数据的变化 set(val) &#123; let arr = val.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;, // 简写 // fullName()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"指令语法","date":"2022-09-12T11:20:38.897Z","updated":"2022-09-12T11:20:38.897Z","comments":true,"path":"vue-instruction/instruction.html","permalink":"http://example.com/vue-instruction/instruction.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445# 属性绑定 v-bind:# 功能：指定变化的属性值# 完整写法 v-bind:xxx=&#x27;yyy&#x27; // yyy会作为表达式解析执行# 简洁写法 :xxx=&#x27;yyy&#x27;# 属性绑定应用&lt;div id=&quot;app&quot;&gt; &lt;!-- 数组 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套三元表达式 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, isactive?&#x27;active&#x27;: &#x27;&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, &#123;active: isactive&#125;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class=&quot;&#123;red:true&#125;&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;h1 :class=&quot;styles&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&#x27;click&#x27;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, info: &#x27;明天就中秋了，你们的中秋节目准备的咋样了？&#x27;, isactive: true, index: 1, styles: &#123; red: true, thin: true, active: true &#125; &#125;, methods: &#123; click() &#123; console.log(this); &#125; &#125;, &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 单向数据绑定# 语法：v-bind:href =&quot;xxx&quot; 或简写为 :href =&quot;xxx&quot;# 特点：数据只能从 data 流向页面# 双向数据绑定 指令 v-model# 语法：v-mode:value=&quot;xxx&quot; 或简写为 v-model=&quot;xxx&quot;# 特点：数据不仅能从 data 流向页面，还能从页面流向 datav-model应用v-model:用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据&lt;p&gt;选择的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&#x27;province&#x27;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;杭州&lt;/option&gt;&lt;/select&gt;&lt;p&gt;您选中的是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;man&quot;&gt;man&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;woman&quot;&gt;woman&lt;p&gt;您的爱好是: &#123;&#123;loves&#125;&#125;&lt;/p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;game&quot; v-model=loves value=&quot;玩游戏&quot;&gt;玩游戏&lt;input type=&quot;checkbox&quot; name=&quot;music&quot; v-model=loves value=&quot;听音乐&quot;&gt;听音乐&lt;input type=&quot;checkbox&quot; name=&quot;basketball&quot; v-model=loves value=&quot;打篮球&quot;&gt;打篮球&lt;input type=&quot;checkbox&quot; name=&quot;eat&quot; v-model=loves value=&quot;吃东西&quot;&gt;吃东西&lt;input type=&quot;checkbox&quot; name=&quot;treenp&quot; v-model=loves value=&quot;吹牛皮&quot;&gt;吹牛皮.number: 将输入值转化为数字类型想要严格限制输入框只允许输入数字，请使用属性type=&quot;number&quot;&lt;input type=&quot;text&quot; v-model.number=&#x27;first&#x27; @keyup=&#x27;sum&#x27;&gt;+&lt;input type=&quot;text&quot; v-model.number=&#x27;last&#x27; @keyup=&#x27;sum&#x27;&gt; =&lt;span&gt;&#123;&#123;result&#125;&#125;&lt;/span&gt;.lazy: 当添加了.lazy修饰符后，双向绑定的数据就不同步了，相当于在input输入框失去焦点后触发的change事件中同步&lt;div&gt; &lt;input v-model.lazy=&quot;msg&quot; @change=&quot;show&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 老许 &#125; &#125;, methods: &#123; show () &#123; console.log(this.msg) &#125; &#125;&#125;&lt;/script&gt;.trim 自动去除输入框前后(首尾)空格如下: 如果直接在开头输入空格，或者是在末尾输入空格，是不会显示有输入内容的&lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt; v-on指令12345678v-on:click=&#x27;xxx&#x27;v-on:keyup=&#x27;xxx(参数)&#x27;v-on:keyup.enter=&#x27;xxx&#x27;功能：绑定指定事件名的回调函数简洁写法@click=&#x27;xxx&#x27;@keyup=&#x27;xxx&#x27;@keyup.enter=&#x27;xxx&#x27; 事件修饰符prevent：阻止默认事件（常用）； 12&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我&lt;/a&gt; stop：阻止事件冒泡（常用）； 12345&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;&lt;button @click.stop=&quot;showInfo&quot;&gt;点我&lt;/button&gt;&lt;!-- 修饰符可以连续写 先写的先起作用: 这样写就是先阻止默认行为后阻止冒泡--&gt;&lt;!-- &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我&lt;/a&gt; --&gt;&lt;/div&gt; once：事件只触发一次（常用） 123&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我&lt;/button&gt; 指令语法：条件渲染指令v-if是控制元素是否加载到页面上（有性能开销） 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。当条件不成立时, v-if 的所有子节点不会解析 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被 ‘打断’。 v-show是控制元素的显示与隐藏 （初始创建时加载一次） 切换频率较高的场景。不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 123456789&lt;p v-if=&#x27;flag&#x27;&gt;海底月是天上月&lt;/p&gt;&lt;p v-else&gt;眼前人是心上人&lt;/p&gt;&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;一般&lt;/p&gt;&lt;p v-else=&quot;type === &#x27;D&#x27;&quot;&gt;差&lt;/p&gt;&lt;p v-show=&#x27;flag&#x27;&gt;&lt;/p&gt; 列表渲染指令v-for指令: 1、用于展示列表数据 2、语法：v-for&#x3D;“(item, index) in xxx” :key&#x3D;“yyy” 3、可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 123456789101112131415161718192021222324252627282930&lt;!-- 遍历数组 --&gt;&lt;ul&gt; &lt;span&gt;key是唯一的标识 其数据类型只能是字符串或者数字&lt;/span&gt; &lt;!-- item代表数组中的每一项 --&gt; &lt;!-- 如果需要取下标 (item, index) --&gt; &lt;li v-for=&quot;(item,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历对象 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历字符串 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt; &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历指定次数 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125; &lt;/li&gt;&lt;/ul&gt; key使用注意事项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 面试题：react、vue中的key有什么作用？（key的内部原理）1. 虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：2.对比规则：(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 3. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key? 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。--&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;carname&#x27;&gt; &lt;button @click=&#x27;add&#x27;&gt;添加一辆车&lt;/button&gt; &lt;ul v-for=&#x27;(item, index) in list&#x27; :key=&#x27;item.id&#x27;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;input&gt;&lt;/input&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div &gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; carname: &#x27;&#x27;, nextId: 4, list: [ &#123;id: 001, name: &#x27;法拉利&#x27; &#125;, &#123;id: 002, name: &#x27;兰博基尼&#x27; &#125;, &#123;id: 003, name: &#x27;布加迪&#x27; &#125;] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.nextId, name: this.carname &#125;) this.nextId += 1 &#125; &#125; &#125;);&lt;/script&gt; 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100自定义指令总结：一、定义语法：(1).局部指令：new Vue(&#123; new Vue(&#123;directives:&#123;指令名:配置对象&#125; 或 directives&#123;指令名:回调函数&#125;&#125;) &#125;)(2).全局指令：Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：(1).bind：指令与元素成功绑定时调用。(2).inserted：指令所在元素被插入页面时调用。(3).update：指令所在模板结构被重新解析时调用。三、备注：1.指令定义时不加v-，但使用时要加v-；2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; v-focus&gt; --&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; 自定义指令: &lt;p v-two-double.flag=&quot;number&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;number += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; 自动聚焦: &lt;input type=&quot;text&quot; v-focus v-if=&quot;flag&quot;&gt;&lt;br&gt; &lt;button @click=&quot;del&quot;&gt;移除元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // ctrl+shift+k 删除当前行 Vue.config.productionTip = false // 1、自定义指令什么时候会被执行 ? // - 指令与页面元素绑定成功时(页面一打开) // - 自定义指令所在的vue模板被重新解析时 // 函数式写法 Vue.directive(&#x27;two-double&#x27;, (el, binding) =&gt; &#123; el.innerText = binding.value * 2 &#125;) // Vue.directive(&#x27;focus&#x27;, (el, binding) =&gt; &#123; // // 聚焦失败 原因是此时元素并没有渲染到页面上 // el.focus() // &#125;) // 对象式写法 Vue.directive(&#x27;focus&#x27;, &#123; // 指令与元素成功绑定时调用 bind(el,binding)&#123; el.style.backgroundColor = &#x27;skyblue&#x27; &#125;, // 指令所在元素被插入页面时调用 inserted(el,binding)&#123; el.focus() &#125;, // 指令所在模板结构被重新解析时调用 update(el,binding) &#123; console.log(&#x27;update&#x27;) &#125;, unbind()&#123; console.log(&#x27;unbind&#x27;) &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; number: 1, age: 1, flag: true &#125;, methods: &#123; del()&#123; this.flag = false &#125; &#125;, // 局部自定义指令 // directives: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"Nodejs内容","date":"2023-03-28T02:56:12.672Z","updated":"2023-03-28T02:56:12.672Z","comments":true,"path":"node-about/nodeall.html","permalink":"http://example.com/node-about/nodeall.html","excerpt":"","text":"|Nodejs简介 以下引自 Node.js 官网： 不是编程语言 也不是框架和库 是一个 JavaScript 运行时（环境） 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 文件 IO 网络 IO 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 Node 的特点事件驱动 非阻塞 IO（异步） 模型 单线程 跨平台 Node 的运行机制多线程处理机制： Web 服务器（Apache、Tomcat、IIS）：请求进来 Web 服务器开启一个线程来处理用户请求 同一时间有 n 请求，服务器就需要开启 n 个线程 一个线程最少得消耗 8MB 内存 对于一个 8GB 内存的服务器来说，它能应对的并发数是 1024 * 8 / 8 = 1024 个并发 事件驱动处理模型：Node 中低层封装了一堆的异步操作 API 文件操作 网络操作 ... JavaScript 语言本身是单线程的 模块通信规则require 模块导入 12345678910111213 // 核心模块var fs = require(&quot;fs&quot;);// 第三方模块// npm install markedvar marked = require(&quot;marked&quot;);// 用户模块（自己写的），正确的，正确的方式// 注意：加载自己写的模块，相对路径不能省略 ./var foo = require(&quot;./foo.js&quot;);// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .jsvar foo = require(&quot;./foo&quot;); require内部处理流程 检查Module._cache是够缓存到了指定模块 如果缓存没有的话，就创建一个新的module实例将他保存到缓存 module.load()加载指定模块 在解析的过程中如果发生异变，仓缓存中删除该模块 返回该模块的moudule.exprots exports 模块导出123456789101112131415161718192021// 导出多个成员：写法一module.exports.a = 123;module.exports.b = 456;module.exports.c = 789;//导出多个成员：写法二（推荐）Node 为了降低开发人员的痛苦，所以为 module.exports 提供了一个别名 exports （下面协大等价于上面的写法）。 console.log(exports === module.exports); // =&gt; trueexports.a = 123;exports.b = 456;exports.c = 789;exports.fn = function() &#123;&#125;;//导出单个成员：（唯一的写法）：// 导出单个成员：错误的写法// 因为每个模块最终导出是 module.exports 而不是 exports 这个别名// exports = function (x, y) &#123;// return x + y// &#125;// 导出单个成员：必须这么写module.exports = function(x, y) &#123; return x + y;&#125;; exports 和 module.exports 的区别 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 true 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 文件操作fs模块 | API | 作用 | 备注 | 123456789101112131415161718192021fs.access(path, callback) 判断路径是否存在 fs.appendFile(file, data, callback) 向文件中追加内容 fs.copyFile(src, callback) 复制文件 fs.mkdir(path, callback) 创建目录 fs.readDir(path, callback) 读取目录列表 fs.rename(oldPath, newPath, callback) 重命名文件/目录 fs.rmdir(path, callback) 删除目录 只能删除空目录fs.stat(path, callback) 获取文件/目录信息 fs.unlink(path, callback) 删除文件 fs.watch(filename[, options][, listener]) 监视文件/目录 fs.watchFile(filename[, options], listener) 监视文件 path 模块参考文档：https://nodejs.org/dist/latest-v9.x/docs/api/path.htmlpath 是 Node 本身提供的一个核心模块，专门用来处理路径。使用它的第一步就是先加载： 12const path = require(&quot;path&quot;); path.basename获取一个路径的文件名部分 12345path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;);// Returns: &#x27;quux.html&#x27;path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;, &quot;.html&quot;);// Returns: &#x27;quux&#x27; path.dirname 获取一个路径的目录部分 12 path.dirname(&quot;/foo/bar/baz/asdf/quux&quot;);// Returns: &#x27;/foo/bar/baz/asdf&#x27; path.extname获取一个路径的后缀名部分 1234567891011121314path.extname(&quot;index.html&quot;);// Returns: &#x27;.html&#x27;path.extname(&quot;index.coffee.md&quot;);// Returns: &#x27;.md&#x27;path.extname(&quot;index.&quot;);// Returns: &#x27;.&#x27;path.extname(&quot;index&quot;);// Returns: &#x27;&#x27;path.extname(&quot;.index&quot;);// Returns: &#x27;&#x27; Node + expressExpress 介绍 Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它可以轻松构建各种web应用，例如： 接口服务 传统的web网站 开发工具集成等（例如webpack的devServer） Express本身是极简的，仅仅提供了web开发的基础功能，但是它通过中间件的方式集成了许许多多的外部插件来处理HTTP请求。 body-parser：解析HTTP请求体 compression：压缩HTTP响应 cookie-parser：解析cookie 数据 cors：处理跨域资源请求 morgan：HTTP请求日志记录 Express中间件的特性固然强大，但是它所提供的灵活性是一把双刃剑。 它让Express本身变得更加灵活和简单 缺点在于虽然有一些中间件包可以解决几乎所有问题或需求，但是挑选合适的包有时也会成为一个挑战 有很多流行框架基于 Express Express 官网 express 安装 参考文档：http://expressjs.com/en/starter/installing.html 123456789 # 创建并切换到 myapp 目录mkdir myappcd myapp# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express Hello World 123456789101112131415// 0. 加载 Expressconst express = require(&quot;express&quot;);// 1. 调用 express() 得到一个 app// 类似于 http.createServer()const app = express();// 2. 设置请求对应的处理函数// 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);// 3. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log(&quot;app listening on port 3000!&quot;)); 查看更多Express内容"},{"title":"vue2简介","date":"2022-09-11T05:55:03.000Z","updated":"2022-09-12T08:59:54.282Z","comments":true,"path":"vueall/jianjie.html","permalink":"http://example.com/vueall/jianjie.html","excerpt":"","text":"Vue 是一套用于构建用户界面的 渐进式框架 。 与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 自从Vue 2.0 发布之后，Vue 就成了前端领域的热门话题。 2019.02.05，Vue 发布了 2.6.0 ，这是一个承前启后的版本，在它之后，推出了 3.0.0。 2019.12.05，在万众期待中，尤雨溪公布了 Vue 3 源代码，此时的 Vue 3仍 处于 Alpha 版本。 2020年09月18日，Vue.js 3.0 正式发布。"},{"title":"vue2内容","date":"2022-09-11T05:55:03.000Z","updated":"2023-03-28T02:55:15.366Z","comments":true,"path":"vue2/index.html","permalink":"http://example.com/vue2/index.html","excerpt":"","text":"|vue 简介 Vue 是一套用于构建用户界面的 渐进式框架 。 与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 自从Vue 2.0 发布之后，Vue 就成了前端领域的热门话题。 2019.02.05，Vue 发布了 2.6.0 ，这是一个承前启后的版本，在它之后，推出了 3.0.0。 2019.12.05，在万众期待中，尤雨溪公布了 Vue 3 源代码，此时的 Vue 3仍 处于 Alpha 版本。 2020年09月18日，Vue.js 3.0 正式发布。 Vue 周边生态 vue-cli：vue 脚手架vue-resource(axios)：ajax 请求vue-router：路由vuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）vue-lazyload：图片懒加载vue-scroller：页面滑动相关mint-ui：基于 vue 的 UI 组件库（移动端）element-ui：基于 vue 的 UI 组件库（PC 端） 原生计数器 1234567891011121314151617// 1. 获取DOM原生const titleEl = document.querySelector(&quot;.title&quot;);const btnInEl = document.querySelector(&#x27;.increment&#x27;);const btnDeEl = document.querySelector(&#x27;.decrement&#x27;);// 2. 默认设置的是Hello Worldlet counter = 0// 3. 设置titleEl的内容titleEl.innerHTML = counter;// 4. 监听按钮的点击btnInEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter += 1; titleEl.innerHTML =counter;&#125;)btnDeEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter -=1; titleEl.innerHTML = counter;&#125;) vue写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue指令: v-on:事件类型 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;!-- 简写 比如: @click @keyup @keydown --&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &#123;&#123; count &#125;&#125; &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 关闭生产提示 Vue.config.productionTip = false var vm = new Vue(&#123; el: &#x27;#app&#x27;, // 数据 data: &#123; count: 0 &#125;, // 方法 methods: &#123; increment()&#123; // this =&gt; vue实例 this.count++ &#125;, decrement()&#123; this.count-- &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 指令语法123456789101112131415161718192021222324252627282930313233343536373839404142434445# 属性绑定 v-bind:# 功能：指定变化的属性值# 完整写法 v-bind:xxx=&#x27;yyy&#x27; // yyy会作为表达式解析执行# 简洁写法 :xxx=&#x27;yyy&#x27;# 属性绑定应用&lt;div id=&quot;app&quot;&gt; &lt;!-- 数组 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套三元表达式 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, isactive?&#x27;active&#x27;: &#x27;&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, &#123;active: isactive&#125;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class=&quot;&#123;red:true&#125;&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;h1 :class=&quot;styles&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&#x27;click&#x27;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, info: &#x27;明天就中秋了，你们的中秋节目准备的咋样了？&#x27;, isactive: true, index: 1, styles: &#123; red: true, thin: true, active: true &#125; &#125;, methods: &#123; click() &#123; console.log(this); &#125; &#125;, &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 单向数据绑定# 语法：v-bind:href =&quot;xxx&quot; 或简写为 :href =&quot;xxx&quot;# 特点：数据只能从 data 流向页面# 双向数据绑定 指令 v-model# 语法：v-mode:value=&quot;xxx&quot; 或简写为 v-model=&quot;xxx&quot;# 特点：数据不仅能从 data 流向页面，还能从页面流向 datav-model应用v-model:用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据&lt;p&gt;选择的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&#x27;province&#x27;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;杭州&lt;/option&gt;&lt;/select&gt;&lt;p&gt;您选中的是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;man&quot;&gt;man&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;woman&quot;&gt;woman&lt;p&gt;您的爱好是: &#123;&#123;loves&#125;&#125;&lt;/p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;game&quot; v-model=loves value=&quot;玩游戏&quot;&gt;玩游戏&lt;input type=&quot;checkbox&quot; name=&quot;music&quot; v-model=loves value=&quot;听音乐&quot;&gt;听音乐&lt;input type=&quot;checkbox&quot; name=&quot;basketball&quot; v-model=loves value=&quot;打篮球&quot;&gt;打篮球&lt;input type=&quot;checkbox&quot; name=&quot;eat&quot; v-model=loves value=&quot;吃东西&quot;&gt;吃东西&lt;input type=&quot;checkbox&quot; name=&quot;treenp&quot; v-model=loves value=&quot;吹牛皮&quot;&gt;吹牛皮.number: 将输入值转化为数字类型想要严格限制输入框只允许输入数字，请使用属性type=&quot;number&quot;&lt;input type=&quot;text&quot; v-model.number=&#x27;first&#x27; @keyup=&#x27;sum&#x27;&gt;+&lt;input type=&quot;text&quot; v-model.number=&#x27;last&#x27; @keyup=&#x27;sum&#x27;&gt; =&lt;span&gt;&#123;&#123;result&#125;&#125;&lt;/span&gt;.lazy: 当添加了.lazy修饰符后，双向绑定的数据就不同步了，相当于在input输入框失去焦点后触发的change事件中同步&lt;div&gt; &lt;input v-model.lazy=&quot;msg&quot; @change=&quot;show&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 老许 &#125; &#125;, methods: &#123; show () &#123; console.log(this.msg) &#125; &#125;&#125;&lt;/script&gt;.trim 自动去除输入框前后(首尾)空格如下: 如果直接在开头输入空格，或者是在末尾输入空格，是不会显示有输入内容的&lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt; v-on指令12345678v-on:click=&#x27;xxx&#x27;v-on:keyup=&#x27;xxx(参数)&#x27;v-on:keyup.enter=&#x27;xxx&#x27;功能：绑定指定事件名的回调函数简洁写法@click=&#x27;xxx&#x27;@keyup=&#x27;xxx&#x27;@keyup.enter=&#x27;xxx&#x27; 事件修饰符prevent：阻止默认事件（常用）； 12&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我&lt;/a&gt; stop：阻止事件冒泡（常用）； 12345&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;&lt;button @click.stop=&quot;showInfo&quot;&gt;点我&lt;/button&gt;&lt;!-- 修饰符可以连续写 先写的先起作用: 这样写就是先阻止默认行为后阻止冒泡--&gt;&lt;!-- &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我&lt;/a&gt; --&gt;&lt;/div&gt; once：事件只触发一次（常用） 123&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我&lt;/button&gt; 指令语法：条件渲染指令v-if是控制元素是否加载到页面上（有性能开销） 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。当条件不成立时, v-if 的所有子节点不会解析 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被 ‘打断’。 v-show是控制元素的显示与隐藏 （初始创建时加载一次） 切换频率较高的场景。不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 123456789&lt;p v-if=&#x27;flag&#x27;&gt;海底月是天上月&lt;/p&gt;&lt;p v-else&gt;眼前人是心上人&lt;/p&gt;&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;一般&lt;/p&gt;&lt;p v-else=&quot;type === &#x27;D&#x27;&quot;&gt;差&lt;/p&gt;&lt;p v-show=&#x27;flag&#x27;&gt;&lt;/p&gt; 列表渲染指令v-for指令: 1、用于展示列表数据 2、语法：v-for&#x3D;“(item, index) in xxx” :key&#x3D;“yyy” 3、可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 123456789101112131415161718192021222324252627282930&lt;!-- 遍历数组 --&gt;&lt;ul&gt; &lt;span&gt;key是唯一的标识 其数据类型只能是字符串或者数字&lt;/span&gt; &lt;!-- item代表数组中的每一项 --&gt; &lt;!-- 如果需要取下标 (item, index) --&gt; &lt;li v-for=&quot;(item,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历对象 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历字符串 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt; &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历指定次数 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125; &lt;/li&gt;&lt;/ul&gt; key使用注意事项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 面试题：react、vue中的key有什么作用？（key的内部原理）1. 虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：2.对比规则：(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 3. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key? 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。--&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;carname&#x27;&gt; &lt;button @click=&#x27;add&#x27;&gt;添加一辆车&lt;/button&gt; &lt;ul v-for=&#x27;(item, index) in list&#x27; :key=&#x27;item.id&#x27;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;input&gt;&lt;/input&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div &gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; carname: &#x27;&#x27;, nextId: 4, list: [ &#123;id: 001, name: &#x27;法拉利&#x27; &#125;, &#123;id: 002, name: &#x27;兰博基尼&#x27; &#125;, &#123;id: 003, name: &#x27;布加迪&#x27; &#125;] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.nextId, name: this.carname &#125;) this.nextId += 1 &#125; &#125; &#125;);&lt;/script&gt; 过滤器​ 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。 ​ 语法： ​ 1.注册过滤器：Vue.filter (name,callback) 或 new Vue { filters:{} } ​ 2.使用过滤器： 1&#x27;&#123;&#123; xxx | 过滤器名 &#125;&#125;&#x27; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot; ​ 备注： ​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联 ​ 2.并没有改变原本的数据, 是产生新的对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt; !--准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; fmtTime &#125;&#125;&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; getFmtTime() &#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;&lt;/h3&gt; &lt;h3 :x=&quot;msg | mySlice&quot;&gt;哈哈哈&lt;/h3&gt; &lt;/div &gt; &lt;div id=&quot;root2&quot;&gt; &lt;h2&gt;&#123;&#123; msg | mySlice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body &gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //全局过滤器 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4) &#125;) new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; time:1621561377603, //时间戳 msg:&#x27;你好，vue&#x27; &#125;, computed: &#123; fmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, methods: &#123; getFmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, //局部过滤器 filters:&#123; timeFormater(value, str = &#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123; // console.log(&#x27;@&#x27;,value) return dayjs(value).format(str) &#125; &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; msg:&#x27;hello,vue!&#x27; &#125; &#125;) computed和method123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt; &lt;!-- 插值表达式的实现 简单的js逻辑表达式 --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName +&#x27;-&#x27;+ lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName&#125;&#125; - &#123;&#123;lastName&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- 更复杂的通过方法的实现 methods中的方法调用一次就会执行一次 如果数据不需要更新 会造成性能的浪费--&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // 定义到data中的数据默认会被响应式监听 firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27; &#125;, methods: &#123; // fullName() &#123; // console.log(111); // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125;, // 计算属性computed: 计算属性的值本身不存在 是需要通过计算得到的 // 底层也是通过object.defineProperty来实现的 // computed 与 methods的区别 // 1、是否存在缓存: methods调用一次执行一次 // computed第一次调用时会将结果缓存 (有缓存)、后续调用在所依赖的数据不发生变化的前提下 直接返回缓存的结果 =&gt; 复用率高 提升性能 // 2、调用方式不同: methods使用时，一般情况需要加括号，而computed则不需要 // 3、绑定方式不同: methods是单向数据绑定 只有getter, computed是双向数据绑定, 有setter和getter // 使用场景 // 某个属性的值需要来自多个属性的简单计算或者复杂逻辑计算得出的值时, 推荐使用computed属性, 比如购物车的总价计算 computed: &#123; // 完整写法 fullName: &#123; // get作用: 当使用到fullName的时候 默认会调用get方法 // get特点: // 1、初次使用计算属性的时候会执行 // 2、当依赖的响应式数据发生变化的时候会执行 get() &#123; console.log(111); return this.firstName + &#x27;-&#x27; + this.lastName &#125;, // 如果需要修改计算属性 需要提供一个set方法 // 并且这个set方法中要能够引起依赖的数据的变化 set(val) &#123; let arr = val.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;, // 简写 // fullName()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.21.4/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;name&#x27;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&#x27;student.loves.playGame.tencent.name&#x27;&gt; &lt;/div&gt; &lt;script&gt; // watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作 var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // _data会收集data中的数据 处理成响应式 // 再将其挂载到vm实例对象下方便开发者使用 =&gt; 数据代理 // 响应式: 简单的说就是数据发生变化 页面会重新渲染 // 页面发生变化 数据也会随之变化 name: &#x27;admin&#x27;, message: &#x27;&#x27;, student: &#123; loves: &#123; playGame: &#123; tencent: &#123; name: &#x27;王者荣耀&#x27;, price: 99 &#125;, wangyi: &#123; name: &#x27;和平精英&#x27;, &#125; &#125; &#125; &#125; &#125;, methods: &#123;&#125;, watch: &#123; // 侦听器本质是一个函数 需要侦听谁 就将侦听的属性当作函数名放到watch中即可 // 当被监视的属性发生变化时，回调函数自动调用，执行函数中的代码 // name() &#123; // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125; // 有配置项的情况 将函数改造成对象的形式 // name: &#123; // async handler(newVal, oldVal) &#123; // console.log(111); // console.log(&#x27;新值&#x27;+ newVal, &#x27;老值&#x27;+ oldVal); // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125;, // 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器 // 执行handler函数中的内容 // immediate: true, // &#125;, // 如果层次不深 可以直接通过这种方式侦听 // &#x27;student.name&#x27;:&#123;&#125; // &#x27;student.loves.playGame.tencent.name&#x27;:&#123; // handler(newVal)&#123; // console.log(11111); // console.log(newVal); // &#125; // &#125; // vue中的watch默认不监视对象内部的值改变 student: &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 // deep: true &#125; &#125; &#125;); vm.$watch(&#x27;student&#x27;, &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 deep: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed和watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, // 侦听器的方式 watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, // 计算属性的方式 computed: &#123; fullName() &#123; this.fullName = this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; // computed和watch的区别 // 1、computed是有缓存的 watch没有 // 2、computed一般执行同步操作 异步操作在watch中实现 // 3、computed监听的那个数据的数据发生变化时,不会重新计算,只有依赖的数据发生变化时才会重新调用getter来计算 // watch监听的数据发生变化时 立马执行相应的回调函数重新计算 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据代理什么是数据代理？ 通过一个对象代理对另一个对象中属性的操作（读&#x2F;写） 123456789101112let obj1 = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.defineProperty(obj2, &#x27;x&#x27;, &#123; get() &#123; return obj1.x &#125;, set(value) &#123; obj1.x = value &#125;&#125;)此时操作obj2实际上在操作obj1 vue中的数据代理 vue里面data的数据代理 通过_data收集data中的数据 利用Object.defineProperty中的get和set将data中的每个数据进行数据代理 再将代理好的数据挂载到vm实例上 好处: 方便开发者操作data中的数据 Vue.set()注意：受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新 如果想要数据是响应式的并且能触发视图更新 使用Vue.set() (比如 this.myObject.newProperty &#x3D; ‘hi’) 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100自定义指令总结：一、定义语法：(1).局部指令：new Vue(&#123; new Vue(&#123;directives:&#123;指令名:配置对象&#125; 或 directives&#123;指令名:回调函数&#125;&#125;) &#125;)(2).全局指令：Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：(1).bind：指令与元素成功绑定时调用。(2).inserted：指令所在元素被插入页面时调用。(3).update：指令所在模板结构被重新解析时调用。三、备注：1.指令定义时不加v-，但使用时要加v-；2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; v-focus&gt; --&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; 自定义指令: &lt;p v-two-double.flag=&quot;number&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;number += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; 自动聚焦: &lt;input type=&quot;text&quot; v-focus v-if=&quot;flag&quot;&gt;&lt;br&gt; &lt;button @click=&quot;del&quot;&gt;移除元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // ctrl+shift+k 删除当前行 Vue.config.productionTip = false // 1、自定义指令什么时候会被执行 ? // - 指令与页面元素绑定成功时(页面一打开) // - 自定义指令所在的vue模板被重新解析时 // 函数式写法 Vue.directive(&#x27;two-double&#x27;, (el, binding) =&gt; &#123; el.innerText = binding.value * 2 &#125;) // Vue.directive(&#x27;focus&#x27;, (el, binding) =&gt; &#123; // // 聚焦失败 原因是此时元素并没有渲染到页面上 // el.focus() // &#125;) // 对象式写法 Vue.directive(&#x27;focus&#x27;, &#123; // 指令与元素成功绑定时调用 bind(el,binding)&#123; el.style.backgroundColor = &#x27;skyblue&#x27; &#125;, // 指令所在元素被插入页面时调用 inserted(el,binding)&#123; el.focus() &#125;, // 指令所在模板结构被重新解析时调用 update(el,binding) &#123; console.log(&#x27;update&#x27;) &#125;, unbind()&#123; console.log(&#x27;unbind&#x27;) &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; number: 1, age: 1, flag: true &#125;, methods: &#123; del()&#123; this.flag = false &#125; &#125;, // 局部自定义指令 // directives: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"Vue 周边生态","date":"2022-09-12T11:17:50.202Z","updated":"2022-09-12T11:17:50.202Z","comments":true,"path":"vuesurroun/vuesurroun.html","permalink":"http://example.com/vuesurroun/vuesurroun.html","excerpt":"","text":"vue-cli：vue 脚手架vue-resource(axios)：ajax 请求vue-router：路由vuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）vue-lazyload：图片懒加载vue-scroller：页面滑动相关mint-ui：基于 vue 的 UI 组件库（移动端）element-ui：基于 vue 的 UI 组件库（PC 端）"},{"title":"computed和watch","date":"2022-09-12T11:26:44.984Z","updated":"2022-09-12T11:26:44.984Z","comments":true,"path":"vue-watch/com-and-watch.html","permalink":"http://example.com/vue-watch/com-and-watch.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, // 侦听器的方式 watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, // 计算属性的方式 computed: &#123; fullName() &#123; this.fullName = this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; // computed和watch的区别 // 1、computed是有缓存的 watch没有 // 2、computed一般执行同步操作 异步操作在watch中实现 // 3、computed监听的那个数据的数据发生变化时,不会重新计算,只有依赖的数据发生变化时才会重新调用getter来计算 // watch监听的数据发生变化时 立马执行相应的回调函数重新计算 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"}],"posts":[{"title":"Java学习","slug":"Java","date":"2023-03-28T05:27:03.673Z","updated":"2023-03-28T05:29:51.325Z","comments":true,"path":"2023/03/28/Java/","link":"","permalink":"http://example.com/2023/03/28/Java/","excerpt":"","text":"Java介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 Java标识符和关键字 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。 名称 说明字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 public 它用来表示公共类。另外，static 和 void 也是关键字，它们的使用将在本教程后面的章节中详细介绍。 final 是定义常量的关键字 final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量 声明变量 12345678 char usersex=&#x27;女&#x27;; // 直接赋值 ----------------------- String username; // 先声明 username =&quot;琪琪&quot;; // 后赋值-------------------------- String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 成员变量名称 修饰 访问 生命周期全局变量（实例变量）| 无 static 修饰 | 对象名.变量名 只要对象被当作引用，实例变量就将存在静态变量（类变量） | 用 static 修饰 | 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 123456 public class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = &quot;C语言中文网&quot;; // 成员变量、静态变量(类变量) static String URL = &quot;http://c.biancheng.net&quot;; // 成员变量、静态变量(类变量)&#125; 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 1234567891011 public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(&quot;s=&quot; + s); System.out.println(&quot;a=&quot; + a); &#125; System.out.println(&quot;a=&quot; + a); &#125;&#125;","categories":[],"tags":[]},{"title":"Nuxtjs学习","slug":"Nuxt","date":"2023-03-28T03:02:58.526Z","updated":"2023-03-28T03:20:13.618Z","comments":true,"path":"2023/03/28/Nuxt/","link":"","permalink":"http://example.com/2023/03/28/Nuxt/","excerpt":"","text":"官网介绍关于 Nuxt.js 2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。 Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（Microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxtjs特性 基于 Vue.js 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ES2015+ 语法支持 打包和压缩 JS 和 CSS HTML 头部标签管理 本地开发支持热加载 集成 ESLint 支持各种样式预处理器： SASS、LESS、 Stylus 等等 支持 HTTP&#x2F;2 推送* Nuxtjs 和 Vue的区别 路由 nuxt按照 pages 文件夹的目录结构自动生成路由 vue需在 src&#x2F;router&#x2F;index.js 手动配置路由 nuxt nuxt 类似 router-view , nuxt-link 类似 router-link webpack配置 nuxt内置webpack，允许根据服务端需求，在 nuxt.config.js 中的build属性自定义构建webpack的配置，覆盖默认配置 vue关于webpack的配置存放在build文件夹下 项目入口 nuxt: 没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置指定。 vue: &#x2F;src&#x2F;main.js，在main.js可以做一些全局注册的初始化工作； 网页渲染流程 vue: 客户端渲染，先下载js后，通过ajax来渲染页面； nuxt： 服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以做到无需发起ajax请求； build后目标产物不同 vue: dist uxt: .nuxt 安装123$ npx create-nuxt-app &lt;项目名&gt;// 或$ yarn create nuxt-app &lt;项目名&gt; 目录结构 资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录 layouts 用于组织应用的布局组件。 middleware 目录 用于存放应用的中间件。 页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。 插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 &#x2F; 下。 store 目录 用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。 nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。 路由 Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。 123 &lt;template&gt; &lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt;&lt;/template&gt; 举例 pages 文件下 12345pages/ --| user/ -----| index.vue -----| one.vue --| index.vue 生成的路由12345678910111213141516171819router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;user&#x27;, path: &#x27;/user&#x27;, component: &#x27;pages/user/index.vue&#x27; &#125;, &#123; name: &#x27;user-one&#x27;, path: &#x27;/user/one&#x27;, component: &#x27;pages/user/one.vue&#x27; &#125; ]&#125; 动态路由123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;users-id&#x27;, path: &#x27;/users/:id?&#x27;, component: &#x27;pages/users/_id.vue&#x27; &#125;, &#123; name: &#x27;slug&#x27;, path: &#x27;/:slug&#x27;, component: &#x27;pages/_slug/index.vue&#x27; &#125;, &#123; name: &#x27;slug-comments&#x27;, path: &#x27;/:slug/comments&#x27;, component: &#x27;pages/_slug/comments.vue&#x27; &#125; ]&#125;","categories":[],"tags":[]},{"title":"Nodejs内容","slug":"nodejs","date":"2023-03-28T02:43:17.669Z","updated":"2023-03-28T03:22:44.221Z","comments":true,"path":"2023/03/28/nodejs/","link":"","permalink":"http://example.com/2023/03/28/nodejs/","excerpt":"","text":"Nodejs简介 以下引自 Node.js 官网： 不是编程语言 也不是框架和库 是一个 JavaScript 运行时（环境） 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 文件 IO 网络 IO 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 Node 的特点事件驱动 非阻塞 IO（异步） 模型 单线程 跨平台 Node 的运行机制多线程处理机制： Web 服务器（Apache、Tomcat、IIS）：请求进来 Web 服务器开启一个线程来处理用户请求 同一时间有 n 请求，服务器就需要开启 n 个线程 一个线程最少得消耗 8MB 内存 对于一个 8GB 内存的服务器来说，它能应对的并发数是 1024 * 8 / 8 = 1024 个并发 事件驱动处理模型：Node 中低层封装了一堆的异步操作 API 文件操作 网络操作 ... JavaScript 语言本身是单线程的 模块通信规则require 模块导入 12345678910111213 // 核心模块var fs = require(&quot;fs&quot;);// 第三方模块// npm install markedvar marked = require(&quot;marked&quot;);// 用户模块（自己写的），正确的，正确的方式// 注意：加载自己写的模块，相对路径不能省略 ./var foo = require(&quot;./foo.js&quot;);// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .jsvar foo = require(&quot;./foo&quot;); require内部处理流程 检查Module._cache是够缓存到了指定模块 如果缓存没有的话，就创建一个新的module实例将他保存到缓存 module.load()加载指定模块 在解析的过程中如果发生异变，仓缓存中删除该模块 返回该模块的moudule.exprots exports 模块导出123456789101112131415161718192021// 导出多个成员：写法一module.exports.a = 123;module.exports.b = 456;module.exports.c = 789;//导出多个成员：写法二（推荐）Node 为了降低开发人员的痛苦，所以为 module.exports 提供了一个别名 exports （下面协大等价于上面的写法）。 console.log(exports === module.exports); // =&gt; trueexports.a = 123;exports.b = 456;exports.c = 789;exports.fn = function() &#123;&#125;;//导出单个成员：（唯一的写法）：// 导出单个成员：错误的写法// 因为每个模块最终导出是 module.exports 而不是 exports 这个别名// exports = function (x, y) &#123;// return x + y// &#125;// 导出单个成员：必须这么写module.exports = function(x, y) &#123; return x + y;&#125;; exports 和 module.exports 的区别 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 true 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 文件操作fs模块 | API | 作用 | 备注 | 123456789101112131415161718192021fs.access(path, callback) 判断路径是否存在 fs.appendFile(file, data, callback) 向文件中追加内容 fs.copyFile(src, callback) 复制文件 fs.mkdir(path, callback) 创建目录 fs.readDir(path, callback) 读取目录列表 fs.rename(oldPath, newPath, callback) 重命名文件/目录 fs.rmdir(path, callback) 删除目录 只能删除空目录fs.stat(path, callback) 获取文件/目录信息 fs.unlink(path, callback) 删除文件 fs.watch(filename[, options][, listener]) 监视文件/目录 fs.watchFile(filename[, options], listener) 监视文件 path 模块参考文档：https://nodejs.org/dist/latest-v9.x/docs/api/path.htmlpath 是 Node 本身提供的一个核心模块，专门用来处理路径。使用它的第一步就是先加载： 12const path = require(&quot;path&quot;); path.basename获取一个路径的文件名部分 12345path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;);// Returns: &#x27;quux.html&#x27;path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;, &quot;.html&quot;);// Returns: &#x27;quux&#x27; path.dirname 获取一个路径的目录部分 12 path.dirname(&quot;/foo/bar/baz/asdf/quux&quot;);// Returns: &#x27;/foo/bar/baz/asdf&#x27; path.extname获取一个路径的后缀名部分 1234567891011121314path.extname(&quot;index.html&quot;);// Returns: &#x27;.html&#x27;path.extname(&quot;index.coffee.md&quot;);// Returns: &#x27;.md&#x27;path.extname(&quot;index.&quot;);// Returns: &#x27;.&#x27;path.extname(&quot;index&quot;);// Returns: &#x27;&#x27;path.extname(&quot;.index&quot;);// Returns: &#x27;&#x27; Node + expressExpress 介绍 Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它可以轻松构建各种web应用，例如： 接口服务 传统的web网站 开发工具集成等（例如webpack的devServer） Express本身是极简的，仅仅提供了web开发的基础功能，但是它通过中间件的方式集成了许许多多的外部插件来处理HTTP请求。 body-parser：解析HTTP请求体 compression：压缩HTTP响应 cookie-parser：解析cookie 数据 cors：处理跨域资源请求 morgan：HTTP请求日志记录 Express中间件的特性固然强大，但是它所提供的灵活性是一把双刃剑。 它让Express本身变得更加灵活和简单 缺点在于虽然有一些中间件包可以解决几乎所有问题或需求，但是挑选合适的包有时也会成为一个挑战 有很多流行框架基于 Express Express 官网 express 安装 参考文档：http://expressjs.com/en/starter/installing.html 123456789 # 创建并切换到 myapp 目录mkdir myappcd myapp# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express Hello World 123456789101112131415// 0. 加载 Expressconst express = require(&quot;express&quot;);// 1. 调用 express() 得到一个 app// 类似于 http.createServer()const app = express();// 2. 设置请求对应的处理函数// 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);// 3. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log(&quot;app listening on port 3000!&quot;)); 查看更多Express内容","categories":[],"tags":[]},{"title":"React","slug":"React","date":"2023-03-28T02:41:15.712Z","updated":"2023-03-28T03:21:30.072Z","comments":true,"path":"2023/03/28/React/","link":"","permalink":"http://example.com/2023/03/28/React/","excerpt":"","text":"react简介 React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。React 中拥有多种不同类型的组件，我们先从 React.Component 的子类开始介绍： 12345678910111213141516class ShoppingList extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;shopping-list&quot;&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 用法示例: &lt;ShoppingList name=&quot;Mark&quot; /&gt; 我们马上会讨论这些又奇怪、又像 XML 的标签。我们通过使用组件来告诉 React 我们希望在屏幕上看到什么。当数据发生改变时，React 会高效地更新并重新渲染我们的组件。 创建react项目1npx create-react-app 项目名 清空src目录创建index.js 12rm src/*touch src/index.js index.js 入口js: 用react-dom渲染注入点 12const root = ReactDOM.createRoot(dom节点)root.render(&lt;App /&gt;) JSXJSX: Javascript + XMLJSX是一个语法糖，React.createElement的语法糖 React.createElement定义 1React.createElement(组件, [属性props], [...children]) // 返回jsx元素 12345678910const element1 = &lt;h1&gt;hello&lt;/h1&gt; // element1的值叫做jsx的元素 // h1叫做jsx的组件const element2 = &lt;App /&gt; // element2是元素 // App是组件const element3 = &lt;button id=&#x27;okBtn&#x27; type=&#x27;button&#x27;&gt;OK&lt;/button&gt;const element4 = ( &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;/select&gt;) React.createElement函数表达以上的代码(Babel转换成下面的代码)： 123456789const element1 = React.createElement(&#x27;h1&#x27;, null, &#x27;hello&#x27;)const element2 = React.createElement(App)const element3 = React.createElement( &#x27;button&#x27;, &#123;id: &#x27;okBtn&#x27;, type: &#x27;button&#x27;&#125;, &#x27;OK&#x27;)const element4 = React.createElement( &#x27;select&#x27;, &#123;name: &#x27;city&#x27;&#125;, React.createElement(&#x27;option&#x27;, &#123;value: &quot;1&quot;&#125;, &#x27;北京&#x27;), React.createElement(&#x27;option&#x27;, &#123;value: &quot;2&quot;&#125;, &#x27;上海&#x27;)) html和jsx的转换关系第一点：jsx要符合xml的标准，jsx的html组件必须名字为小写： tag必须成对出现(&lt;div&gt;...&lt;/div&gt;) 或者自结束标签(&lt;input /&gt;)html的tag结构不严谨1234const el1 = &lt;h1&gt;&lt;/H1&gt; // ❌ 大小写不一样const el2 = &lt;H1&gt;&lt;/H1&gt; // ❌ 不是html里的h1对应的组件，而是自定义H1组件const el3 = &lt;img &gt; // ❌ 无关闭标记const el4 = &lt;div&gt;&lt;b&gt;hello &lt;i&gt;world&lt;/b&gt;&lt;/i&gt;&lt;/div&gt; // ❌ 没有正确嵌套 第二点，jsx的属性名称由两个单词组成，用驼峰形式书写；html属性是不区分大小写的。 12&lt;input value=&#x27;&#x27; autoComplete=&#x27;on&#x27; data-id=&#x27;name&#x27;&gt;&lt;td colSpan=&#x27;2&#x27;&gt; 第三点：有一些属性名称在jsx中改变了: class -&gt; className for -&gt; htmlFor因为class和for都是js里的关键字，避免用关键字命名 第四点：有一些属性是html没有的 key - 值字符串，为了表示元素唯一性 ref - 为了引用dom元素或者jsx元素 defaultValue 用来代替 value属性 defaultChecked 用来代替checked属性 1234&lt;input type=&#x27;text&#x27; value=&#x27;abc&#x27;/&gt;&lt;input type=&#x27;text&#x27; defaultValue=&#x27;abc&#x27;/&gt;&lt;input type=&#x27;checkbox&#x27; checked /&gt;&lt;input type=&#x27;checkbox&#x27; defaultChecked /&gt; 第五点，html的style是字符串，jsx的style属性是object（dom里style对象的方式书写） 1&lt;span style=&#x27;font-size: 18px; color: red; text-decoration: underline&#x27;&gt;Hello World&lt;/span&gt; 1234&lt;span style=&#123;&#123;fontSize: &quot;18px&quot;, color: &quot;red&quot;, textDecoration: &quot;underline&quot;&#125;&#125;&gt;Hello World&lt;/span&gt;const styles = &#123;fontSize: &quot;18px&quot;, color: &quot;red&quot;, textDecoration: &quot;underline&quot;&#125;&lt;span style=&#123;styles&#125;&gt;Hello World&lt;/span&gt; 第六点，开关属性（cheched, disabled, readOnly）值是布尔类型 12345678&lt;input type=&#x27;text&#x27; readOnly=&#123;true&#125; /&gt;&lt;input type=&#x27;text&#x27; readOnly=&quot;true&quot; /&gt; &#123;/*错*/&#125;&lt;div className=&quot;container&quot;&gt;&lt;/div&gt;&lt;div className=&#123;&quot;container&quot;&#125;&gt;&lt;/div&gt;&lt;Counter value=&quot;1&quot; /&gt;&lt;Counter value=&#123;1&#125; /&gt; 第七点，children位置（指元素标记之间的内容&lt;b&gt;...&lt;/b&gt;）用字符串表达式，里面的内容会自动转义（html特殊字符会转换成html entity，&gt; 转换成 &amp;gt; ）避免XSS攻击 12&lt;div&gt;&#123;&quot;&lt;b&gt;hello&lt;/b&gt; world&quot;&#125;&lt;/div&gt;&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &quot;&lt;b&gt;hello&lt;/b&gt; world&quot;&#125;&#125;&gt;&lt;/div&gt; 第八点，html的注释&lt;!-- 注释内容 --&gt;，jsx的注释&#123;/* 注释 */&#125; 第九点，html里换行也是一个空格，jsx里换行不是空格 123&lt;span&gt;红灯&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;&lt;!-- 红灯 绿灯 --&gt; 123456&lt;span&gt;红灯&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;&#123;/* 红灯绿灯 */&#125;&lt;span&gt;红灯&lt;/span&gt;&#123;&#x27; &#x27;&#125;&lt;span&gt;绿灯&lt;/span&gt; 表达式使用表达式用&#123;表达式&#125;，表达式只能写一个语句（if&#x2F;for&#x2F;while&#x2F;switch不能在表达式里使用） 表达式可以用在children位置或者属性值位置 children位置的表达式里不能是普通object 有一些值放在表达式里没有任何渲染内容：false&#x2F;true&#x2F;null&#x2F;undefined&#x2F;NaN 12345678910111213141516171819&#123;1&#125;&#123;&#x27;1&#x27;&#125;&#123;false&#125;&#123;null&#125;&#123;1+1&#125;&#123;Math.random()&#125;&#123;&lt;div&gt;123&lt;/div&gt;&#125;&#123;Math.random() &gt; 0.5 ? &#x27;正面&#x27; : &#x27;背面&#x27;&#125;&#123;[1,2,3].map(n =&gt; n * 2).join(&#x27;, &#x27;)&#125;&#123;(function()&#123; if(Math.random()&gt;0.5) &#123; return 1 &#125; else &#123; return 2 &#125;&#125;)()&#125;&lt;div className=&#123;`row $&#123;index%2 ? &#x27;bg&#x27; : &#x27;&#x27;&#125;`&#125;&gt;&lt;/div&gt;&lt;div&gt;&#123;[1,2,3]&#125;&lt;/div&gt;&lt;ul&gt;&#123;[&lt;li&gt;1&lt;/li&gt;,&lt;li&gt;3&lt;/li&gt;,&lt;li&gt;2&lt;/li&gt;]&#125;&lt;/ul&gt; 表达式的扩展语法 123456789const params = &#123; className: &#x27;abc&#x27;, style: &#123;border: &#x27;1px solid red&#x27;&#125;, defaultValue: &#x27;hello&#x27;&#125;&lt;input className=&#123;params.className&#125; style=&#123;params.style&#125; defaultValue=&#123;params.defaultValue&#125; /&gt;&lt;input className=&#x27;xyz&#x27; &#123;...params&#125; className=&#x27;a&#x27;/&gt;","categories":[],"tags":[]},{"title":"欢迎来到我的博客","slug":"hello-world","date":"2023-03-28T02:02:31.258Z","updated":"2023-03-28T02:38:25.876Z","comments":true,"path":"2023/03/28/hello-world/","link":"","permalink":"http://example.com/2023/03/28/hello-world/","excerpt":"","text":"介绍 世上有两句疑问：这个程序怎么不运行？这个程序怎么运行了？我的博客 记录与2022.9.1这意味着这是一个新的开始这里面包括了 vue2&#x2F;3 javascript React Html css Es6 还有Nodejs，一串代码往往伴随着优化，接下来让我们一起努力吧","categories":[],"tags":[]},{"title":"小程序","slug":"Small_program","date":"2022-09-11T10:26:06.000Z","updated":"2023-03-28T03:25:45.756Z","comments":true,"path":"2022/09/11/Small_program/","link":"","permalink":"http://example.com/2022/09/11/Small_program/","excerpt":"","text":"浅谈小程序 在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来： “ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。 小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M； 2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。 什么样的应用适合使用小程序开发?虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。 基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。 逻辑简单：是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。 使用低频：是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。 对性能要求不极致：是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。 当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现 小程序与H5，原生应用有何区别？很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？ H5 移动应用我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。 同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。 原生应用原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。 既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。 混合应用混合应用一般被称为 Hybrid App。简单来说，混合应用就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳） ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。 我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。 小程序严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。 相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；能获取更多系统权限，完成更加丰富的产品设计；可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；","categories":[],"tags":[]},{"title":"vue2内容","slug":"vue","date":"2022-09-11T05:55:03.000Z","updated":"2023-03-28T07:01:01.172Z","comments":true,"path":"2022/09/11/vue/","link":"","permalink":"http://example.com/2022/09/11/vue/","excerpt":"","text":"vue 简介 Vue 是一套用于构建用户界面的 渐进式框架 。 与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 自从Vue 2.0 发布之后，Vue 就成了前端领域的热门话题。 2019.02.05，Vue 发布了 2.6.0 ，这是一个承前启后的版本，在它之后，推出了 3.0.0。 2019.12.05，在万众期待中，尤雨溪公布了 Vue 3 源代码，此时的 Vue 3仍 处于 Alpha 版本。 2020年09月18日，Vue.js 3.0 正式发布。 Vue 周边生态 vue-cli：vue 脚手架vue-resource(axios)：ajax 请求vue-router：路由vuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）vue-lazyload：图片懒加载vue-scroller：页面滑动相关mint-ui：基于 vue 的 UI 组件库（移动端）element-ui：基于 vue 的 UI 组件库（PC 端） 原生计数器 1234567891011121314151617// 1. 获取DOM原生const titleEl = document.querySelector(&quot;.title&quot;);const btnInEl = document.querySelector(&#x27;.increment&#x27;);const btnDeEl = document.querySelector(&#x27;.decrement&#x27;);// 2. 默认设置的是Hello Worldlet counter = 0// 3. 设置titleEl的内容titleEl.innerHTML = counter;// 4. 监听按钮的点击btnInEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter += 1; titleEl.innerHTML =counter;&#125;)btnDeEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter -=1; titleEl.innerHTML = counter;&#125;) vue写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue指令: v-on:事件类型 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;!-- 简写 比如: @click @keyup @keydown --&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &#123;&#123; count &#125;&#125; &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 关闭生产提示 Vue.config.productionTip = false var vm = new Vue(&#123; el: &#x27;#app&#x27;, // 数据 data: &#123; count: 0 &#125;, // 方法 methods: &#123; increment()&#123; // this =&gt; vue实例 this.count++ &#125;, decrement()&#123; this.count-- &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 指令语法123456789101112131415161718192021222324252627282930313233343536373839404142434445# 属性绑定 v-bind:# 功能：指定变化的属性值# 完整写法 v-bind:xxx=&#x27;yyy&#x27; // yyy会作为表达式解析执行# 简洁写法 :xxx=&#x27;yyy&#x27;# 属性绑定应用&lt;div id=&quot;app&quot;&gt; &lt;!-- 数组 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套三元表达式 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, isactive?&#x27;active&#x27;: &#x27;&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, &#123;active: isactive&#125;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class=&quot;&#123;red:true&#125;&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;h1 :class=&quot;styles&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&#x27;click&#x27;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, info: &#x27;明天就中秋了，你们的中秋节目准备的咋样了？&#x27;, isactive: true, index: 1, styles: &#123; red: true, thin: true, active: true &#125; &#125;, methods: &#123; click() &#123; console.log(this); &#125; &#125;, &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 单向数据绑定# 语法：v-bind:href =&quot;xxx&quot; 或简写为 :href =&quot;xxx&quot;# 特点：数据只能从 data 流向页面# 双向数据绑定 指令 v-model# 语法：v-mode:value=&quot;xxx&quot; 或简写为 v-model=&quot;xxx&quot;# 特点：数据不仅能从 data 流向页面，还能从页面流向 datav-model应用v-model:用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据&lt;p&gt;选择的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&#x27;province&#x27;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;杭州&lt;/option&gt;&lt;/select&gt;&lt;p&gt;您选中的是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;man&quot;&gt;man&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;woman&quot;&gt;woman&lt;p&gt;您的爱好是: &#123;&#123;loves&#125;&#125;&lt;/p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;game&quot; v-model=loves value=&quot;玩游戏&quot;&gt;玩游戏&lt;input type=&quot;checkbox&quot; name=&quot;music&quot; v-model=loves value=&quot;听音乐&quot;&gt;听音乐&lt;input type=&quot;checkbox&quot; name=&quot;basketball&quot; v-model=loves value=&quot;打篮球&quot;&gt;打篮球&lt;input type=&quot;checkbox&quot; name=&quot;eat&quot; v-model=loves value=&quot;吃东西&quot;&gt;吃东西&lt;input type=&quot;checkbox&quot; name=&quot;treenp&quot; v-model=loves value=&quot;吹牛皮&quot;&gt;吹牛皮.number: 将输入值转化为数字类型想要严格限制输入框只允许输入数字，请使用属性type=&quot;number&quot;&lt;input type=&quot;text&quot; v-model.number=&#x27;first&#x27; @keyup=&#x27;sum&#x27;&gt;+&lt;input type=&quot;text&quot; v-model.number=&#x27;last&#x27; @keyup=&#x27;sum&#x27;&gt; =&lt;span&gt;&#123;&#123;result&#125;&#125;&lt;/span&gt;.lazy: 当添加了.lazy修饰符后，双向绑定的数据就不同步了，相当于在input输入框失去焦点后触发的change事件中同步&lt;div&gt; &lt;input v-model.lazy=&quot;msg&quot; @change=&quot;show&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 老许 &#125; &#125;, methods: &#123; show () &#123; console.log(this.msg) &#125; &#125;&#125;&lt;/script&gt;.trim 自动去除输入框前后(首尾)空格如下: 如果直接在开头输入空格，或者是在末尾输入空格，是不会显示有输入内容的&lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt; v-on指令12345678v-on:click=&#x27;xxx&#x27;v-on:keyup=&#x27;xxx(参数)&#x27;v-on:keyup.enter=&#x27;xxx&#x27;功能：绑定指定事件名的回调函数简洁写法@click=&#x27;xxx&#x27;@keyup=&#x27;xxx&#x27;@keyup.enter=&#x27;xxx&#x27; 事件修饰符prevent：阻止默认事件（常用）； 12&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我&lt;/a&gt; stop：阻止事件冒泡（常用）； 12345&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;&lt;button @click.stop=&quot;showInfo&quot;&gt;点我&lt;/button&gt;&lt;!-- 修饰符可以连续写 先写的先起作用: 这样写就是先阻止默认行为后阻止冒泡--&gt;&lt;!-- &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我&lt;/a&gt; --&gt;&lt;/div&gt; once：事件只触发一次（常用） 123&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我&lt;/button&gt; 指令语法：条件渲染指令v-if是控制元素是否加载到页面上（有性能开销） 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。当条件不成立时, v-if 的所有子节点不会解析 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被 ‘打断’。 v-show是控制元素的显示与隐藏 （初始创建时加载一次） 切换频率较高的场景。不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 123456789&lt;p v-if=&#x27;flag&#x27;&gt;海底月是天上月&lt;/p&gt;&lt;p v-else&gt;眼前人是心上人&lt;/p&gt;&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;一般&lt;/p&gt;&lt;p v-else=&quot;type === &#x27;D&#x27;&quot;&gt;差&lt;/p&gt;&lt;p v-show=&#x27;flag&#x27;&gt;&lt;/p&gt; 列表渲染指令v-for指令: 1、用于展示列表数据 2、语法：v-for&#x3D;“(item, index) in xxx” :key&#x3D;“yyy” 3、可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 123456789101112131415161718192021222324252627282930&lt;!-- 遍历数组 --&gt;&lt;ul&gt; &lt;span&gt;key是唯一的标识 其数据类型只能是字符串或者数字&lt;/span&gt; &lt;!-- item代表数组中的每一项 --&gt; &lt;!-- 如果需要取下标 (item, index) --&gt; &lt;li v-for=&quot;(item,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历对象 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历字符串 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt; &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历指定次数 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125; &lt;/li&gt;&lt;/ul&gt; key使用注意事项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 面试题：react、vue中的key有什么作用？（key的内部原理）1. 虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：2.对比规则：(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 3. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key? 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。--&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;carname&#x27;&gt; &lt;button @click=&#x27;add&#x27;&gt;添加一辆车&lt;/button&gt; &lt;ul v-for=&#x27;(item, index) in list&#x27; :key=&#x27;item.id&#x27;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;input&gt;&lt;/input&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div &gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; carname: &#x27;&#x27;, nextId: 4, list: [ &#123;id: 001, name: &#x27;法拉利&#x27; &#125;, &#123;id: 002, name: &#x27;兰博基尼&#x27; &#125;, &#123;id: 003, name: &#x27;布加迪&#x27; &#125;] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.nextId, name: this.carname &#125;) this.nextId += 1 &#125; &#125; &#125;);&lt;/script&gt; 过滤器​ 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。 ​ 语法： ​ 1.注册过滤器：Vue.filter (name,callback) 或 new Vue { filters:{} } ​ 2.使用过滤器： 1&#x27;&#123;&#123; xxx | 过滤器名 &#125;&#125;&#x27; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot; ​ 备注： ​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联 ​ 2.并没有改变原本的数据, 是产生新的对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt; !--准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; fmtTime &#125;&#125;&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; getFmtTime() &#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;&lt;/h3&gt; &lt;h3 :x=&quot;msg | mySlice&quot;&gt;哈哈哈&lt;/h3&gt; &lt;/div &gt; &lt;div id=&quot;root2&quot;&gt; &lt;h2&gt;&#123;&#123; msg | mySlice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body &gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //全局过滤器 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4) &#125;) new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; time:1621561377603, //时间戳 msg:&#x27;你好，vue&#x27; &#125;, computed: &#123; fmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, methods: &#123; getFmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, //局部过滤器 filters:&#123; timeFormater(value, str = &#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123; // console.log(&#x27;@&#x27;,value) return dayjs(value).format(str) &#125; &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; msg:&#x27;hello,vue!&#x27; &#125; &#125;) computed和method123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt; &lt;!-- 插值表达式的实现 简单的js逻辑表达式 --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName +&#x27;-&#x27;+ lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName&#125;&#125; - &#123;&#123;lastName&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- 更复杂的通过方法的实现 methods中的方法调用一次就会执行一次 如果数据不需要更新 会造成性能的浪费--&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // 定义到data中的数据默认会被响应式监听 firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27; &#125;, methods: &#123; // fullName() &#123; // console.log(111); // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125;, // 计算属性computed: 计算属性的值本身不存在 是需要通过计算得到的 // 底层也是通过object.defineProperty来实现的 // computed 与 methods的区别 // 1、是否存在缓存: methods调用一次执行一次 // computed第一次调用时会将结果缓存 (有缓存)、后续调用在所依赖的数据不发生变化的前提下 直接返回缓存的结果 =&gt; 复用率高 提升性能 // 2、调用方式不同: methods使用时，一般情况需要加括号，而computed则不需要 // 3、绑定方式不同: methods是单向数据绑定 只有getter, computed是双向数据绑定, 有setter和getter // 使用场景 // 某个属性的值需要来自多个属性的简单计算或者复杂逻辑计算得出的值时, 推荐使用computed属性, 比如购物车的总价计算 computed: &#123; // 完整写法 fullName: &#123; // get作用: 当使用到fullName的时候 默认会调用get方法 // get特点: // 1、初次使用计算属性的时候会执行 // 2、当依赖的响应式数据发生变化的时候会执行 get() &#123; console.log(111); return this.firstName + &#x27;-&#x27; + this.lastName &#125;, // 如果需要修改计算属性 需要提供一个set方法 // 并且这个set方法中要能够引起依赖的数据的变化 set(val) &#123; let arr = val.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;, // 简写 // fullName()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.21.4/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;name&#x27;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&#x27;student.loves.playGame.tencent.name&#x27;&gt; &lt;/div&gt; &lt;script&gt; // watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作 var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // _data会收集data中的数据 处理成响应式 // 再将其挂载到vm实例对象下方便开发者使用 =&gt; 数据代理 // 响应式: 简单的说就是数据发生变化 页面会重新渲染 // 页面发生变化 数据也会随之变化 name: &#x27;admin&#x27;, message: &#x27;&#x27;, student: &#123; loves: &#123; playGame: &#123; tencent: &#123; name: &#x27;王者荣耀&#x27;, price: 99 &#125;, wangyi: &#123; name: &#x27;和平精英&#x27;, &#125; &#125; &#125; &#125; &#125;, methods: &#123;&#125;, watch: &#123; // 侦听器本质是一个函数 需要侦听谁 就将侦听的属性当作函数名放到watch中即可 // 当被监视的属性发生变化时，回调函数自动调用，执行函数中的代码 // name() &#123; // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125; // 有配置项的情况 将函数改造成对象的形式 // name: &#123; // async handler(newVal, oldVal) &#123; // console.log(111); // console.log(&#x27;新值&#x27;+ newVal, &#x27;老值&#x27;+ oldVal); // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125;, // 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器 // 执行handler函数中的内容 // immediate: true, // &#125;, // 如果层次不深 可以直接通过这种方式侦听 // &#x27;student.name&#x27;:&#123;&#125; // &#x27;student.loves.playGame.tencent.name&#x27;:&#123; // handler(newVal)&#123; // console.log(11111); // console.log(newVal); // &#125; // &#125; // vue中的watch默认不监视对象内部的值改变 student: &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 // deep: true &#125; &#125; &#125;); vm.$watch(&#x27;student&#x27;, &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 deep: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed和watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, // 侦听器的方式 watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, // 计算属性的方式 computed: &#123; fullName() &#123; this.fullName = this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; // computed和watch的区别 // 1、computed是有缓存的 watch没有 // 2、computed一般执行同步操作 异步操作在watch中实现 // 3、computed监听的那个数据的数据发生变化时,不会重新计算,只有依赖的数据发生变化时才会重新调用getter来计算 // watch监听的数据发生变化时 立马执行相应的回调函数重新计算 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据代理什么是数据代理？ 通过一个对象代理对另一个对象中属性的操作（读&#x2F;写） 123456789101112let obj1 = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.defineProperty(obj2, &#x27;x&#x27;, &#123; get() &#123; return obj1.x &#125;, set(value) &#123; obj1.x = value &#125;&#125;)此时操作obj2实际上在操作obj1 vue中的数据代理 vue里面data的数据代理 通过_data收集data中的数据 利用Object.defineProperty中的get和set将data中的每个数据进行数据代理 再将代理好的数据挂载到vm实例上 好处: 方便开发者操作data中的数据 Vue.set()注意：受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新 如果想要数据是响应式的并且能触发视图更新 使用Vue.set() (比如 this.myObject.newProperty &#x3D; ‘hi’) 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100自定义指令总结：一、定义语法：(1).局部指令：new Vue(&#123; new Vue(&#123;directives:&#123;指令名:配置对象&#125; 或 directives&#123;指令名:回调函数&#125;&#125;) &#125;)(2).全局指令：Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：(1).bind：指令与元素成功绑定时调用。(2).inserted：指令所在元素被插入页面时调用。(3).update：指令所在模板结构被重新解析时调用。三、备注：1.指令定义时不加v-，但使用时要加v-；2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; v-focus&gt; --&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; 自定义指令: &lt;p v-two-double.flag=&quot;number&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;number += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; 自动聚焦: &lt;input type=&quot;text&quot; v-focus v-if=&quot;flag&quot;&gt;&lt;br&gt; &lt;button @click=&quot;del&quot;&gt;移除元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // ctrl+shift+k 删除当前行 Vue.config.productionTip = false // 1、自定义指令什么时候会被执行 ? // - 指令与页面元素绑定成功时(页面一打开) // - 自定义指令所在的vue模板被重新解析时 // 函数式写法 Vue.directive(&#x27;two-double&#x27;, (el, binding) =&gt; &#123; el.innerText = binding.value * 2 &#125;) // Vue.directive(&#x27;focus&#x27;, (el, binding) =&gt; &#123; // // 聚焦失败 原因是此时元素并没有渲染到页面上 // el.focus() // &#125;) // 对象式写法 Vue.directive(&#x27;focus&#x27;, &#123; // 指令与元素成功绑定时调用 bind(el,binding)&#123; el.style.backgroundColor = &#x27;skyblue&#x27; &#125;, // 指令所在元素被插入页面时调用 inserted(el,binding)&#123; el.focus() &#125;, // 指令所在模板结构被重新解析时调用 update(el,binding) &#123; console.log(&#x27;update&#x27;) &#125;, unbind()&#123; console.log(&#x27;unbind&#x27;) &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; number: 1, age: 1, flag: true &#125;, methods: &#123; del()&#123; this.flag = false &#125; &#125;, // 局部自定义指令 // directives: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue组件组件化和模块化的区别模块化 站在代码逻辑的角度来划分 解决js依赖等问题 方便分层开发 保证每个模块职能单一 组件化 站在UI界面的角度来划分 方便将来UI组件的复用 全局组件第一种注册方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 在页面中使用组件 --&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;/div&gt; &lt;script&gt; // 关闭生产环境下的vue提示 Vue.config.productionTip = false // 使用组件三步骤 // 1、通过Vue.extend(options)定义组件 // 2、通过Vue.component(&#x27;组件名&#x27;, 定义好的组件)注册全局组件 // 3、在页面结构中通过&lt;组件名&gt;&lt;/组件名&gt;使用组件 // 注意事项 // 1、template有且只能有一个根元素 // 2、不要写el属性 定义的组件都要交给vm管理 由vm中的el来决定服务于哪个容器 // 3、如果自定义组件名使用了驼峰命名法(myCom) 在页面中使用的时候要用-分割组件名并且转为小写(my-com) // 4、组件名不要使用已有的元素名称，比如：div、span都不行。 // 5、组件中的data必须定义为一个函数 函数中必须返回一个对象 避免组件在复用时 数据直接相互引用导致冲突问题 // 6、不用使用脚手架时，单标签会导致复用组件后续无法渲染的问题 // 7、组件中的this指向的是当前组件的实例对象 // 8、使用name配置项指定组件在开发者工具中呈现的名字 // 第一种注册方式 Vue.extend + Vue.component 结合 // 定义组件 let mycom = Vue.extend(&#123; // el: &#x27;#app&#x27;, 违背设计组件的初心 // template: 将来展示在页面上的结构 // name: &#x27;qwer&#x27;, 使用name配置项指定组件在开发者工具中呈现的名字 template: `&lt;div&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: &#x27;hello component&#x27; &#125; &#125;, methods: &#123; show()&#123; // this指向的是当前组件的实例对象 console.log(this); &#125; &#125;, &#125;) // 注册全局组件 Vue.component(&#x27;my-com&#x27;, mycom) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123;&#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第二种注册方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;mycom1&gt;&lt;/mycom1&gt; &lt;/div&gt; &lt;!-- .vue文件中也是通过这种方式定义页面结构 --&gt; &lt;!-- template模板 只会将template中的内容渲染到页面上 不会将template标签渲染到页面上 --&gt; &lt;template id=&quot;mycom1&quot;&gt; &lt;div&gt; &lt;h1&gt;第三种注册方式&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 第二种注册方式 =&gt; template没有提示 // Vue.component(&#x27;mycom1&#x27;, Vue.extend(&#123; // template: &#x27;&lt;h1&gt;第二种注册方式&lt;/h1&gt;&#x27;, // &#125;)) // 简写 Vue.component(&#x27;组件名&#x27;, 配置对象) 内部会帮我们调用Vue.extend // Vue.component(&#x27;mycom1&#x27;, &#123; // template: &#x27;&lt;h1&gt;第二种注册方式&lt;/h1&gt;&#x27;, // &#125;) // 第三种注册方式 Vue.component(&#x27;mycom1&#x27;, &#123; template: &#x27;#mycom1&#x27; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件data详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;/div&gt; &lt;script&gt; // 定义一个名为 button-counter 的新组件 Vue.component(&#x27;button-counter&#x27;, &#123; data() &#123; return &#123; count: 0 &#125; &#125;, template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27; &#125;) // 为什么data必须是一个函数且返回一个对象 // 如果是对象的话多个页面可能会复用这个组件 如果其中一个页面对组件data进行修改的话 其它页面的data也会发生变化 造成数据冲突 (引用问题) // 而定义成一个函数 每次返回一个新的对象 保证了对象的唯一性 避免了组件数据修改影响其他组件数据 var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123;&#125; &#125;, components: &#123; &#125;, methods: &#123;&#125; &#125;); // var obj = &#123;x:100, y:100&#125; // var obj2 = obj // obj2.x = 1000 // console.log(obj); // &#123;x:1000, y:100&#125; // =================================== // function getObj()&#123; // return &#123;x: 100, y:100&#125; // &#125; // var obj = getObj() // var obj2 = getObj() // obj2.x = 1000 // console.log(obj); // &#123;x:100, y:100&#125; &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 局部组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;mycom&gt;&lt;/mycom&gt; &lt;mycom2&gt;&lt;/mycom2&gt; &lt;/div&gt; &lt;!-- 模板 --&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; let mycom = Vue.extend(&#123; template: &#x27;#tmpl&#x27;, data()&#123; return &#123; msg: &#x27;局部组件注册&#x27; &#125; &#125; &#125;) let mycom2 = Vue.extend(&#123; template: &#x27;#tmpl&#x27;, data()&#123; return &#123; msg: &#x27;局部组件注册222&#x27; &#125; &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; mycom, mycom2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 嵌套组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;app&gt;&lt;/app&gt; --&gt; &lt;/div&gt; &lt;template id=&quot;bwm&quot;&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;template id=&quot;car&quot;&gt; &lt;div&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;bwm&gt;&lt;/bwm&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;app2&quot;&gt; &lt;div&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;car&gt;&lt;/car&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.config.productionTip = false // 宝马组件 let bwm = Vue.extend(&#123; template: &#x27;#bwm&#x27;, data() &#123; return &#123; msg: &#x27;宝马最新款x7只需要100w&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;仅仅100w 心动不如行动&#x27;); &#125; &#125;, &#125;) // 车组件 let car = Vue.extend(&#123; template: &#x27;#car&#x27;, data() &#123; return &#123; msg: &#x27;男人必须有一辆爱车~&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;比如说劳斯莱斯&#x27;); &#125; &#125;, components: &#123; bwm &#125; &#125;) // App组件 let App = Vue.extend(&#123; template: &#x27;#app2&#x27;, data() &#123; return &#123; msg: &#x27;app2&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;app2&#x27;); &#125; &#125;, components: &#123; car &#125; &#125;) var vm = new Vue(&#123; template: &#x27;&lt;App&gt;&lt;/App&gt;&#x27;, components: &#123; App &#125;, data: &#123;&#125;, methods: &#123;&#125; &#125;).$mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue 生命周期12345678910111213141516171819beforeCreate(创建前): 在实例初始化之后，数据代理和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods, data等上的方法和数据，这个钩子一般不会做太多功能，会初始化自己的生命周期，事件方法如：$on $emitcreated(创建完成): 此时已经完成了数据响应式监听和数据代理，可以获取数据和调用方法 但是DOM未渲染 在这个周期里面，可以去发送请求, 因为请求是异步的，不会阻碍实例加载，除非是那些同步操走才会导致页面空白。站在这个角度说来，在这个周期里面进行请求，渲染速度反而会更快。beforeMount(挂载前): 检测有没有template属性 有的话会把template渲染成一个render函数，开始解析模板，生成虚拟dom，没有则将外部的html作为模板进行解析。此时数据虽然初始化完成，DOM未完成挂载，页面还不能显示解析好的内容，数据的双向绑定还是显示&#123;&#123;&#125;&#125;上下两者中间还有一个创建vm.$el保存真实dom的过程，将来虚拟dom对比发现可复用的元素，就从该属性身上取出来渲染 同学们切记 !!!mounted(挂载完成): 数据和真实DOM都完成挂载，这个周期适合执行初始化需要操作DOM的方法。至此初始化操作完成，一般在此进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作beforeUpdate(更新前): 只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，页面和数据没有同步，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。中间还有个虚拟DOM对比的过程，根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面更新，如果真实DOM可以复用 则从vm.$el中取出对应的真实DOM直接渲染 即:完成了Model =&gt; View的更新，同学们切记 !!!updated(更新完成): 只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。此时页面和数据保持同步beforeDestroy(销毁前): 这个周期是在组件销毁之前执行，此时: vm中所有的: data、methods、指令等等，都处于可用状态，马上要执行销毁过程，一般在此阶段:关闭定时器、取消订阅消息、解绑自定义事件等收尾操作destroyed(销毁完成): 在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，自定义事件会被移除 vue 动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active &#123; transition: all .5s ease &#125; .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(150px); &#125; .my-enter-active, .my-leave-active &#123; transition: all .5s cubic-bezier(0, 1.95, .89, .38) &#125; &lt;/style&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&#x27;flag = !flag&#x27;&gt;Toggle&lt;/button&gt; &lt;!-- 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;transition&gt; &lt;h3 v-if=&#x27;flag&#x27;&gt;有些同学的心已经到家了&lt;/h3&gt; &lt;/transition&gt; &lt;hr&gt; &lt;!-- 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。 如果需要自定义类名 可以通过name属性: name=&#x27;my&#x27; .my-enter --&gt; &lt;transition name=&#x27;my&#x27;&gt; &lt;h3 v-if=&#x27;flag&#x27;&gt;有些同学的心已经到家了&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; flag: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue2响应式原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到let obj = &#123; name: &#x27;zs&#x27;, age: 18, phone: &#123; name: &#x27;iphone&#x27; &#125;&#125;// let obj = [1, 2, 3, 4, 5]// 视图更新的方法function render() &#123; console.log(&#x27;视图更新了 ~&#x27;);&#125;let methods = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;]// 将数组的原型保存一份let arrProto = Array.prototype// 创建原型 将数组原型拷贝一份let proto = Object.create(arrProto)// 重写数组的方法methods.forEach(method =&gt; &#123; proto[method] = function () &#123; // AOP 面向切面编程 // 改变了数组的数据 arrProto[method].call(this, ...arguments) // 重新渲染视图 render() &#125;&#125;)// 观察者模式 function observe(obj) &#123; // 判断一个对象是不是数组 // if(Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;)&#123; if (Array.isArray(obj)) &#123; // 让观测的对象的原型和我们自己重写的原型建立关系 obj.__proto__ = proto return; &#125; // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get) if (Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;) &#123; // 取出对象中的每一个键和值 for (let key in obj) &#123; // 调用响应式处理函数 defineReactive(obj, key, obj[key]) &#125; &#125;&#125;// 观察obj对象observe(obj)// 响应式处理// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。function defineReactive(obj, key, val) &#123; // 检测对象的属性值是否还是对象 observe(val) Object.defineProperty(obj, key, &#123; // 获取 get() &#123; return val &#125;, // 设置 set(newVal) &#123; // 检测设置的值是不是对象 observe(newVal) // 新值和旧值不相等的时候 if (newVal !== val) &#123; // 覆盖掉原来的val值 val = newVal // 通知render函数重新渲染视图 render() &#125; &#125; &#125;)&#125;// obj.name = &#x27;lisi&#x27;// obj.age = 20// console.log(obj.name, obj.age);// 至此 基本可以实现数据发生变化 视图更新的效果// 但是 如果数据有多层呢 也就是属性对应的值也是对象?// obj.phone.name = &#x27;huawei&#x27;// console.log(obj.phone.name);// 修改的值和原来的值一样 不需要重新渲染视图// obj.phone.name = &#x27;iphone&#x27;// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染// obj.phone = &#123;name: &#x27;huawei&#x27;&#125;// 并且当修改新的对象的属性值时 视图也要重新渲染// obj.phone.name = &#x27;zs&#x27;// 为对象新增属性值呢? 也是没有办法监测到的// obj.sex = &#x27;man&#x27;// $set来解决这个function $myset(obj, key, val)&#123; if(Array.isArray(obj))&#123; return obj.splice(key, val) &#125; defineReactive(obj, key, val)&#125;// $myset(obj, &#x27;sex&#x27;, &#x27;man&#x27;)// 修改新增的属性值 视图也能更新// obj.sex = &#x27;woman&#x27;// obj.phone = Object.assign(obj.phone, &#123;price: &#x27;666&#x27;&#125;)// obj.phone.price = 888// obj.phone = &#123;...obj.phone, ...&#123;price: &#x27;666&#x27;&#125;&#125;// obj.phone.price = &#x27;888&#x27;// 以后vue涉及到给data中的对象新增属性时 有三种方式// 1、this.$set() || Vue.set()// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))// 2、obj = &#123;...原对象, ...新对象(新增的属性:值)&#125;// =================== 数组 ======================// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写// obj.push(6)// obj.length ++ // obj[0] = 88// $myset(obj, &#x27;0&#x27;, 66) props (父传子)父组件要正向地向子组件传递数据或参数，子组件收到后，根据传递过来的数据不同，渲染不同的页面内容，或者执行操作。这个正向传递数据的过程是通过props来实现的。子组件使用props来声明需要从父组件接受的数据。 注意:1、所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。2、每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 两种常见的试图变更一个 prop 的情形1、这个 prop 用来传递一个初始值 这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值2、这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性 nextTick作用: 在下次 DOM 更新循环结束之后执行其指定的回调。应用场景:1、在修改数据之后，要基于更新后的新dom进行某些操作时，可以立即使用这个方法，获取更新后的 DOM。2、在created中需要操作dom，此时dom并没有加载完毕 Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 是异步执行 DOM 更新的，简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 mixinmixinVue.mixin给我们提供了一种混入Vue实例的方法，创建了混入对象之后，我们自定义的方法或者变量可以很轻松的挂载在Vue实例上，给我们带来方便 Vue.mixin为我们提供了两种混入方式：局部混入和全局混入局部混入：顾名思义就是部分混入，也就是只有引入了mixin的混入对象才可以使用，并且只有在引入了mixin混入对象的组件中才生效 全局混入：全局混入我们只需要把mixin.js引入到main.js中，然后将mixin放入到Vue.mixin()方法中即可；全局混入更为便捷，我们将不用在子组件声明，全局混入将会影响每一个组件的实例，使用的时候需要小心谨慎；这样全局混入之后，我们可以直接在组件中通过this.变量&#x2F;方法来调用mixin混入对象的变量&#x2F;方法； mixin可以定义公用的变量或方法，但是mixin中的数据是不共享的，也就是每个组件中的mixin实例都是不一样的，都是单独存在的个体，不存在相互影响的； mixin合并策略1、datamixins中的data会合并到data中，有冲突的话，data中数据覆盖mixins中的数据。 2、methods、components 和 directivesmethods、components 和 directives会执行，但有冲突时，组件中的methods、components 和 directives会覆盖 mixins 中的methods、components 和 directives。 3、特殊的钩子函数（生命周期） 组件和mixin的生命周期都要执行，但是mixin的生命周期优先于组件生命周期执行mixin beforeCreate -&gt; component beforeCreate -&gt; mixin created -&gt; component created 动态组件什么是动态组件？ 动态组件指的是动态切换组件的显示与隐藏 如何实现？vue提供了一个内置的组件，专门用来实现动态组件的渲染 123456789101112131415161718192021&lt;button @click=&quot;comName=&#x27;MyLeft&#x27;&quot;&gt;显示Left组件&lt;/button&gt;&lt;button @click=&quot;comName=&#x27;MyRight&#x27;&quot;&gt;显示Right组件&lt;/button&gt;&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;script&gt;import MyLeft from &#x27;@/components/Left.vue&#x27;import MyRight from &#x27;@/components/Right.vue&#x27;export default &#123; // 组件的交互 name: &#x27;App&#x27;, data() &#123; return &#123; comName: &#x27;MyLeft&#x27;, &#125; &#125;, components: &#123; MyLeft, MyRight, &#125;,&#125;&lt;/script&gt; keep-alive12345678910111213141516171819202122&lt;script&gt;export default &#123; name: &#x27;left&#x27;, data() &#123; return &#123; count: 0, &#125;; &#125;, created() &#123; console.log(&quot;left组件被创建了&quot;); &#125;, destroyed() &#123; console.log(&quot;left组件被销毁了&quot;); &#125;, deactivated() &#123; console.log(&quot;组件被缓存了&quot;); &#125;, activated() &#123; console.log(&quot;组件被激活了&quot;); &#125;,&#125;;&lt;/script&gt; devServer代理跨域 vue.config.js配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const path = require(&quot;path&quot;);function resolve(dir) &#123; return path.join(__dirname, dir);&#125;module.exports = &#123; chainWebpack: config =&gt; &#123; config.resolve.alias .set(&quot;@&quot;, resolve(&quot;src&quot;)) .set(&quot;assets&quot;, resolve(&quot;src/assets&quot;)) .set(&quot;components&quot;, resolve(&quot;src/components&quot;)) .set(&quot;base&quot;, resolve(&quot;baseConfig&quot;)) .set(&quot;public&quot;, resolve(&quot;public&quot;)); &#125;, pages: &#123; index: &#123; // page 的入口 entry: &#x27;src/index.js&#x27;, &#125; &#125;, // 关闭eslint语法校验 lintOnSave: false, devServer: &#123; // 代理的方式配置跨域 // 缺点: // 1、会先从本地public下查找有没有对应接口的文件 如果有 先返回本地的文件数据 没有再去发起请求访问服务器的数据 (优先匹配前端资源) // 2、没法配置多个代理 // proxy: &#x27;http://localhost:3000/&#x27;, proxy: &#123; // 正则匹配所有以&#x27;/api&#x27;开头的请求路径 &#x27;/api&#x27;: &#123; // http://localhost:8080/api/teachers // http://localhost:3000/teachers // target: 代理目标的基础路径 // http://localhost:8080/teachers target: &#x27;http://localhost:3000/&#x27;, // 路径重写 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;, // ws：websocket // ws: true, // 改变源, 也就是控制host // changeOrigin: true &#125;, &#x27;/v1&#x27;: &#123; // target: 代理目标的基础路径 target: &#x27;http://localhost:3001&#x27;, // 路径重写 pathRewrite: &#123; &#x27;^/v1&#x27;: &#x27;&#x27; &#125; &#125;, &#125; &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}