{"meta":{"title":"周贺涛的博客","subtitle":null,"description":null,"author":null,"url":"http://example.com","root":"/"},"pages":[{"title":"Java学习","date":"2022-11-21T02:06:37.946Z","updated":"2022-11-21T02:06:37.946Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Java介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 Java标识符和关键字 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。 名称 说明字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 public 它用来表示公共类。另外，static 和 void 也是关键字，它们的使用将在本教程后面的章节中详细介绍。 final 是定义常量的关键字 final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量 声明变量 12345678 char usersex=&#x27;女&#x27;; // 直接赋值 ----------------------- String username; // 先声明 username =&quot;琪琪&quot;; // 后赋值-------------------------- String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 成员变量名称 修饰 访问 生命周期全局变量（实例变量）| 无 static 修饰 | 对象名.变量名 只要对象被当作引用，实例变量就将存在静态变量（类变量） | 用 static 修饰 | 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 123456 public class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = &quot;C语言中文网&quot;; // 成员变量、静态变量(类变量) static String URL = &quot;http://c.biancheng.net&quot;; // 成员变量、静态变量(类变量)&#125; 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 1234567891011 public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(&quot;s=&quot; + s); System.out.println(&quot;a=&quot; + a); &#125; System.out.println(&quot;a=&quot; + a); &#125;&#125;"},{"title":"分类","date":"2022-09-11T09:42:31.000Z","updated":"2022-11-01T05:58:41.601Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":"vue2vue 简介Vue 是一套用于构建用户界面的 渐进式框架 。与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 小程序浅谈小程序在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来： “ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。 小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M；2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。 NodejsNodejs简介以下引自 Node.js 官网：Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. 不是编程语言 也不是框架和库 是一个 JavaScript 运行时（环境） 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 文件 IO 网络 IO 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 Node 的特点事件驱动 非阻塞 IO（异步） 模型 单线程 跨平台 Nuxtjs官网介绍关于 Nuxt.js2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。 Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（Microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 javaJava介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 更多内容后续更新 敬请期待 ！ 如有问题请联系&#x31;&#54;&#x37;&#56;&#x37;&#x37;&#49;&#x33;&#51;&#54;&#x40;&#113;&#x71;&#46;&#x63;&#111;&#109; 欢迎指导"},{"title":"Java学习","date":"2022-11-08T06:16:44.309Z","updated":"2022-11-08T06:16:44.309Z","comments":true,"path":"java-about/index.html","permalink":"http://example.com/java-about/index.html","excerpt":"","text":"Java介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 Java标识符和关键字 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。 名称 说明字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 public 它用来表示公共类。另外，static 和 void 也是关键字，它们的使用将在本教程后面的章节中详细介绍。 final 是定义常量的关键字 final 关键字表示最终的，它可以修改很多元素，修饰变量就变成了常量 声明变量 12345678 char usersex=&#x27;女&#x27;; // 直接赋值 ----------------------- String username; // 先声明 username =&quot;琪琪&quot;; // 后赋值-------------------------- String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 成员变量名称 修饰 访问 生命周期全局变量（实例变量）| 无 static 修饰 | 对象名.变量名 只要对象被当作引用，实例变量就将存在静态变量（类变量） | 用 static 修饰 | 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 123456 public class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = &quot;C语言中文网&quot;; // 成员变量、静态变量(类变量) static String URL = &quot;http://c.biancheng.net&quot;; // 成员变量、静态变量(类变量)&#125; 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 1234567891011 public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(&quot;s=&quot; + s); System.out.println(&quot;a=&quot; + a); &#125; System.out.println(&quot;a=&quot; + a); &#125;&#125;"},{"title":"Nuxtjs学习","date":"2023-03-28T03:04:11.354Z","updated":"2023-03-28T03:04:11.354Z","comments":true,"path":"Nuxt-about/index.html","permalink":"http://example.com/Nuxt-about/index.html","excerpt":"","text":"|官网介绍关于 Nuxt.js 2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。 Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（Microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxtjs特性 基于 Vue.js 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ES2015+ 语法支持 打包和压缩 JS 和 CSS HTML 头部标签管理 本地开发支持热加载 集成 ESLint 支持各种样式预处理器： SASS、LESS、 Stylus 等等 支持 HTTP&#x2F;2 推送* Nuxtjs 和 Vue的区别 路由 nuxt按照 pages 文件夹的目录结构自动生成路由 vue需在 src&#x2F;router&#x2F;index.js 手动配置路由 nuxt nuxt 类似 router-view , nuxt-link 类似 router-link webpack配置 nuxt内置webpack，允许根据服务端需求，在 nuxt.config.js 中的build属性自定义构建webpack的配置，覆盖默认配置 vue关于webpack的配置存放在build文件夹下 项目入口 nuxt: 没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置指定。 vue: &#x2F;src&#x2F;main.js，在main.js可以做一些全局注册的初始化工作； 网页渲染流程 vue: 客户端渲染，先下载js后，通过ajax来渲染页面； nuxt： 服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以做到无需发起ajax请求； build后目标产物不同 vue: dist uxt: .nuxt 安装123$ npx create-nuxt-app &lt;项目名&gt;// 或$ yarn create nuxt-app &lt;项目名&gt; 目录结构 资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录 layouts 用于组织应用的布局组件。 middleware 目录 用于存放应用的中间件。 页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。 插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 &#x2F; 下。 store 目录 用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。 nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。 路由 Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。 123 &lt;template&gt; &lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt;&lt;/template&gt; 举例 pages 文件下 12345pages/ --| user/ -----| index.vue -----| one.vue --| index.vue 生成的路由12345678910111213141516171819router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;user&#x27;, path: &#x27;/user&#x27;, component: &#x27;pages/user/index.vue&#x27; &#125;, &#123; name: &#x27;user-one&#x27;, path: &#x27;/user/one&#x27;, component: &#x27;pages/user/one.vue&#x27; &#125; ]&#125; 动态路由123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;users-id&#x27;, path: &#x27;/users/:id?&#x27;, component: &#x27;pages/users/_id.vue&#x27; &#125;, &#123; name: &#x27;slug&#x27;, path: &#x27;/:slug&#x27;, component: &#x27;pages/_slug/index.vue&#x27; &#125;, &#123; name: &#x27;slug-comments&#x27;, path: &#x27;/:slug/comments&#x27;, component: &#x27;pages/_slug/comments.vue&#x27; &#125; ]&#125;"},{"title":"Express内容","date":"2023-03-28T02:56:56.080Z","updated":"2023-03-28T02:56:56.080Z","comments":true,"path":"node-about/express.html","permalink":"http://example.com/node-about/express.html","excerpt":"","text":"|Express 介绍 Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它可以轻松构建各种web应用，例如： 接口服务 传统的web网站 开发工具集成等（例如webpack的devServer） Express本身是极简的，仅仅提供了web开发的基础功能，但是它通过中间件的方式集成了许许多多的外部插件来处理HTTP请求。 body-parser：解析HTTP请求体 compression：压缩HTTP响应 cookie-parser：解析cookie 数据 cors：处理跨域资源请求 morgan：HTTP请求日志记录 Express中间件的特性固然强大，但是它所提供的灵活性是一把双刃剑。 它让Express本身变得更加灵活和简单 缺点在于虽然有一些中间件包可以解决几乎所有问题或需求，但是挑选合适的包有时也会成为一个挑战 有很多流行框架基于 Express Express 官网 express 安装 参考文档：http://expressjs.com/en/starter/installing.html 123456789 # 创建并切换到 myapp 目录mkdir myappcd myapp# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express Hello World 123456789101112131415// 0. 加载 Expressconst express = require(&quot;express&quot;);// 1. 调用 express() 得到一个 app// 类似于 http.createServer()const app = express();// 2. 设置请求对应的处理函数// 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);// 3. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log(&quot;app listening on port 3000!&quot;)); 基本路由参考文档：http://expressjs.com/en/starter/basic-routing.html 路由（Routing）是由一个 URI（或者叫路径标识）和一个特定的 HTTP 方法（GET、POST 等）组成的，涉及到应用如何处理响应客户端请求。 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这个&#x2F;些函数将被执行。 路由的定义的结构如下： 1app.METHOD(PATH, HANDLER); ● app 是 express 实例● METHOD 是一个 HTTP 请求方法● PATH 是服务端路径（定位标识）● HANDLER 是当路由匹配到时需要执行的处理函数 举例1234567891011121314// 当你以 GET 方法请求 / 的时候，执行对应的处理函数app.get(&quot;/&quot;, function(req, res) &#123; res.send(&quot;Hello World!&quot;);&#125;);// 当你以 POST 方法请求 / 的时候，指定对应的处理函数app.post(&quot;/&quot;, function(req, res) &#123; res.send(&quot;Got a POST request&quot;);&#125;);app.put(&quot;/user&quot;, function(req, res) &#123; res.send(&quot;Got a PUT request at /user&quot;);&#125;);app.delete(&quot;/user&quot;, function(req, res) &#123; res.send(&quot;Got a DELETE request at /user&quot;);&#125;); 路由路径路由路径与请求方法结合，定义了可以进行请求的端点。路由路径可以是字符串，字符串模式或正则表达式。字符?，+，*，和()是他们的正则表达式的对应的子集。连字符（-）和点(.)由基于字符串的路径按字面意义进行解释。如果您需要$在路径字符串中使用美元字符()，请将其转义([并括在和中]) 例如，“&#x2F;data &#x2F;$book”处用于请求的路径字符串将为$ Express使用path-to-regexp来匹配路由路径; 有关定义路由路径的所有可能性，请参见正则表达式路径文档。Express Route Tester尽管不支持模式匹配，但却是用于测试基本Express路由的便捷工具。 ● *查询字符串不是路由路径的一部分。 动态路径123app.get(&quot;/users/:userId/books/:bookId&quot;, function(req, res) &#123; res.send(req.params);&#125;); 路径参数路由参数被命名为URL段，用于捕获URL中在其位置处指定的值。捕获的值将填充到req.params对象中，并将路径中指定的route参数的名称作为其各自的键。 123Route path: /flights/ :from-:toRequest URL:http:// localhost: 3000/flights/LAX-SFOreq.params : &#123; &quot;from&quot; : &quot;LAX&quot;,&quot;to&quot; : &quot;SFO&quot; &#125; 路径参数的名称必须由“文字字符”([A-Za-zO-9_]）组成。由于连字符(-）和点（.)是按字面解释的，因此可以将它们与路由参数一起使用，以实现有用的目的。 123Route path : /plantae/ :genus.:speciesRequest URL: http : // localhost : 3000/plantae/Prunus.persicareq.params : &#123; &quot;genus &quot; : &quot;prunus &quot; , &quot; species &quot; : &quot;persica&quot; &#125; 路由处理方法app.route() express.Router 1234567891011121314151617onst express = require(&quot;express&quot;);const router = express.Router();router.get(&quot;/&quot;, function(req, res) &#123; res.send(&quot;home page&quot;);&#125;);router.get(&quot;/about&quot;, function(req, res) &#123; res.send(&quot;About page&quot;);&#125;);const router = require(&quot;./router&quot;);// ...app.use(router);module.exports = router; 在 Express 中获取客户端请求参数的三种方式例如，有一个地址：&#x2F;a&#x2F;b&#x2F;c?foo&#x3D;bar&amp;id&#x3D;123 查询字符串参数1console.log(req.query); 请求体参数POST 请求才有请求体，我们需要单独配置 body-parser 中间件才可以获取。只要程序中配置了 body-parser 中间件，我们就可以通过 req.body 来获取表单 POST 请求体数据。 12req.body// =&gt; 得到一个请求体对象 动态的路径参数在 Express 中，支持把一个路由设计为动态的。例如： 12345678910111213141516171819202122232425262728293031// /users/:id 要求必须以 /users/ 开头，:id 表示动态的，1、2、3、abc、dnsaj 任意都行// 注意：:冒号很重要，如果你不加，则就变成了必须 === /users/id// 为啥叫 id ，因为是动态的路径，服务器需要单独获取它，所以得给它起一个名字// 那么我们就可以通过 req.params 来获取路径参数app.get(&quot;/users/:id&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /users/*/abc// req.params.idapp.get(&quot;/users/:id/abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /users/*/*// req.params.id// req.params.abcapp.get(&quot;/users/:id/:abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /*/*/*// req.params.usersapp.get(&quot;/:users/:id/:abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;);// /*/id/*app.get(&quot;/:users/id/:abc&quot;, (req, res, next) =&gt; &#123; console.log(req.params.id);&#125;); 请求和响应Express应用使用路由回调函数的参数：request和response 对象来处理请求和响应的数据。Express不对Node.js 已有的特性进行二次抽象，只是在它之上扩展了web应用所需的基本功能。● 内部使用的还是 http 模块● 请求对象继承自: http.IncomingMessage● 响应对象继承自: http.ServerResponse 处理静态资源12345678910111213141516// 开放 public 目录中的资源// 不需要访问前缀app.use(express.static(&quot;public&quot;));// 开放 files 目录资源，同上app.use(express.static(&quot;files&quot;));// 开放 public 目录，限制访问前缀app.use(&quot;/public&quot;, express.static(&quot;public&quot;));// 开放 public 目录资源，限制访问前缀app.use(&quot;/static&quot;, express.static(&quot;public&quot;));// 开放 publi 目录，限制访问前缀// path.join(__dirname, &#x27;public&#x27;) 会得到一个动态的绝对路径app.use(&quot;/static&quot;, express.static(path.join(__dirname, &quot;public&quot;))); Nodejs + express案例"},{"title":"Node+express案例","date":"2023-03-28T02:57:35.518Z","updated":"2023-03-28T02:57:35.518Z","comments":true,"path":"node-about/node-case.html","permalink":"http://example.com/node-about/node-case.html","excerpt":"","text":"|登陆页面&#x2F;html版本(静态资源) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const http = require(&#x27;http&#x27;)const app = http.createServer()const fs = require(&#x27;fs&#x27;)const url = require(&#x27;url&#x27;)const path = require(&#x27;path&#x27;)const &#123; json &#125; = require(&#x27;express&#x27;)let lodash = require(&#x27;lodash&#x27;)app.on(&#x27;request&#x27;, (req, res) =&gt; &#123; req.url = req.url.toLowerCase() let urlObj = url.parse(req.url, true) if (req.url == &#x27;/&#x27; || req.url == &#x27;index&#x27; || req.url == &#x27;submit&#x27;) &#123; fs.readFile(path.join(__dirname, &#x27;view&#x27;, &#x27;submit.html&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.end(data) &#125;) &#125; else if (req.url == &#x27;/login&#x27;) &#123; fs.readFile(path.join(__dirname, &#x27;view&#x27;, &#x27;login.html&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.end(data) &#125;) &#125; else if(req.url == &quot;/home&quot;)&#123; fs.readFile(path.join(__dirname, &#x27;view&#x27;, &#x27;home.html&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.end(data) &#125;) &#125; else if (req.url.startsWith(&#x27;/add&#x27;) &amp;&amp; req.method == &#x27;GET&#x27;) &#123; let content = urlObj.query fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;kaoshi.json&#x27;), &#x27;utf8&#x27;, (err, data) =&gt; &#123; if (err &amp;&amp; err.code != &#x27;ENOENT&#x27;) throw err let arr = JSON.parse(data || &#x27;[]&#x27;) arr.push(content) fs.writeFile(path.join(__dirname,&#x27;data&#x27;,&#x27;kaoshi.json&#x27;),JSON.stringify(arr,null,&#x27; &#x27;),(err)=&gt;&#123; if(err) throw err res.writeHead(302, &#x27;Found&#x27;, &#123; &#x27;Location&#x27;: &#x27;login&#x27; &#125;) res.end() &#125;) &#125;) &#125; else if(req.url.startsWith(&#x27;/out&#x27;)&amp;&amp; req.method==&#x27;GET&#x27;)&#123; let count = urlObj.query fs.readFile(path.join(__dirname,&#x27;data&#x27;,&#x27;kaoshi.json&#x27;),&#x27;utf-8&#x27;,(err,data)=&gt;&#123; if(err) throw err let arr = JSON.parse(data) var m = lodash.findIndex(arr, count) if(m&gt;=0)&#123; res.writeHead(302, &#x27;Found&#x27;, &#123; &#x27;Location&#x27;: &#x27;/home&#x27; &#125;) res.end() &#125; &#125;) &#125;&#125;).listen(3000, () =&gt; &#123; console.log(&quot;服务启动,请访问:http://localhost:3000&quot;)&#125;) express + cors跨域123var app = express();var cors = require(&quot;cors&quot;) //cors同源跨域app.use(cors) header跨域12345678910111213app.all(&#x27;*&#x27;, function (req, res, next) &#123; res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;); //跨域 res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;X-Requested-With&#x27;); res.header(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;); res.header(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;); res.header(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;) // res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;content-type,curUserId,token,platform&#x27;); // res.header(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;curUserId,token,platform&#x27;); res.header(&#x27;X-Powered-By&#x27;, &#x27;3.2.1&#x27;); res.header(&#x27;Content-Type&#x27;, &#x27;application/json;charset=utf-8&#x27;); next();&#125;) 用户 注册 &#x2F; 登陆 &#x2F; 验证注册1234567891011121314151617181920212223242526272829app.use(cors()) //设置cores同源跨域app.post(&#x27;/user/add&#x27;, urlencodedParser, (req, res) =&gt; &#123; let content = req.body fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var m = lodash.findIndex(str, content);//判断账户名密码是否正确 var n = lodash.findIndex(str, function (o) &#123;//判断用户名是否存在 return o.userName === content.userName; &#125;); if (m &gt;= 0 || n &gt;= 0) &#123; res.send(&#123; code: 201, message: &quot;该用户已经存在&quot; &#125;) &#125; else &#123; content.id = JSON.parse(data).length + 1 content.time = moment(Date.now()).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) //用户注册时间 const secret = &#x27;yating&#x27;; content.token = jwt.sign(content, secret)//生成用户专属令牌token var arr = JSON.parse(data || &quot;[]&quot;) arr.push(content) fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), JSON.stringify(arr, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(&#123; code: 200, message: &quot;已添加该用户&quot; &#125;) &#125;) &#125;) &#125; &#125;)&#125;) 登陆12345678910111213141516app.use(cors())app.post(&quot;/login/add&quot;, urlencodedParser, (req, res) =&gt; &#123; let content = req.body console.log(content); fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;Login.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err var arr = JSON.parse(data) var m = lodash.findIndex(arr, content) if (m &gt;= 0) &#123; const token = jwtSign(&#123;_id:arr[m].id&#125;) //返回带有时效的token res.send(&#123; code: 200, message: &quot;登陆成功&quot;, token:token &#125;) &#125; else &#123; res.send(&#123; code: 201, message: &quot;登陆失败该用户不存在/密码错误&quot; &#125;) &#125; &#125;)&#125;) 验证token jwt插件1234567891011121314151617181920212223242526272829//utils/jswconst jwt = require(&#x27;jsonwebtoken&#x27;)const jwtKey = &#x27;junkaicool&#x27; // token生成的密匙const jwtSign = (data) =&gt; &#123; // token生成函数，有效时间为一个小时 const token = jwt.sign(data, jwtKey, &#123;expiresIn:60*60&#125;) return token&#125;const jwtCheck = (req, res, next) =&gt; &#123; // token验证函数 const token = req.headers.token jwt.verify(token, jwtKey, (err, data) =&gt; &#123; if (err) &#123; res.send(&#123; code: &#x27;99999999&#x27;, msg: &#x27;token无效&#x27; &#125;) &#125; else &#123; req.jwtInfo = data next() &#125; &#125;)&#125;module.exports = &#123; jwtSign, jwtCheck&#125; 12345678910//验证是否登陆const &#123;jwtCheck&#125; = require(&#x27;./utils/jsw&#x27;)// header传递token值判断是否登陆 和token值是否失效app.get(&quot;/token&quot;,jwtCheck,(req,res)=&gt;&#123; res.send(&#123; code:200, meg:&quot;验证成功&quot; &#125;)&#125;) 获取博客列表数据1234567891011//获取博客所有文章app.get(&quot;/blog/list&quot;, (req, res) =&gt; &#123; fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err res.send(&#123; code:200, message:&quot;数据获取成功&quot;, list:data &#125;) &#125;)&#125;) 添加博客12345678910111213141516171819202122232425//添加博客app.post(&quot;/blog/add&quot;, urlencodedParser, (req, res) =&gt; &#123; let content = req.body//获取传递的数据 fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err if(content.categoryId!=undefined)&#123; content.id = JSON.parse(data).length + 1 //id content.categoryId = Number(content.categoryId) //用户id content.time = moment(Date.now()).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;)//生成添加时间 moment插件 var arr = JSON.parse(data || &quot;[]&quot;) arr.push(content) fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), JSON.stringify(arr, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(data) &#125;) &#125;) &#125;else&#123; res.send(&#123; code:201, message:&quot;缺少必要参数&quot; &#125;) &#125; &#125;)&#125;) 获取单条博客数据123456789101112131415161718//获取单条博客文章详情app.post(&quot;/blog/list/:id&quot;, (req, res) =&gt; &#123; var arg = url.parse(req.url).path var ids = arg.match(/\\d+/g).join(&quot; &quot;) fs.readFile(path.join(__dirname, &quot;data&quot;, &quot;list.json&quot;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var n = lodash.findIndex(str, function (o) &#123; return o.id == ids; &#125;) if (n &gt;= 0) &#123; res.send(str[n]) &#125; else &#123; res.send(&#123; code: 201, message: &quot;暂无此数据&quot; &#125;) &#125; &#125;)&#125;) 删除博客123456789101112131415161718//删除博客文章app.delete(&quot;/blog/list/delete/:id&quot;, (req, res) =&gt; &#123; var arg = url.parse(req.url).path var ids = arg.match(/\\d+/g).join(&quot; &quot;) fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var s = lodash.remove(str, function (n) &#123; return n.id == ids; &#125;); fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), JSON.stringify(str, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(data) &#125;) &#125;) &#125;)&#125;) 博客更新12345678910111213141516171819202122232425//更新博客app.put(&quot;/blog/list/put/:id&quot;, (req, res) =&gt; &#123; let content = req.body var arg = url.parse(req.url).path var ids = arg.match(/\\d+/g).join(&quot; &quot;) fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) throw err let str = JSON.parse(data) var n = lodash.findIndex(str, function (o) &#123; return o.id == ids; &#125;) if (n &gt;= 0) &#123; content.time = moment(Date.now()).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) content.id = str[n].id str[n] = content fs.writeFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), JSON.stringify(str, null, &quot; &quot;), (err) =&gt; &#123; if (err) throw err fs.readFile(path.join(__dirname, &#x27;data&#x27;, &#x27;list.json&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; res.send(data) &#125;) &#125;) &#125; else &#123; res.send(&#123; code: 201, message: &quot;暂无数据&quot; &#125;) &#125; &#125;)&#125;)"},{"title":"小程序","date":"2022-09-11T10:26:06.000Z","updated":"2023-03-30T01:03:08.828Z","comments":true,"path":"smallcx/index.html","permalink":"http://example.com/smallcx/index.html","excerpt":"","text":"浅谈小程序在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来： “ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。 小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M； 2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。 什么样的应用适合使用小程序开发?虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。 基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。 逻辑简单：是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。 使用低频：是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。 对性能要求不极致：是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。 当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现 小程序与H5，原生应用有何区别？很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？ H5 移动应用我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。 同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。 原生应用原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。 既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。 混合应用混合应用一般被称为 Hybrid App。简单来说，混合应用就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳） ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。 我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。 小程序严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。 相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；能获取更多系统权限，完成更加丰富的产品设计；可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；"},{"title":"标签","date":"2019-11-16T02:46:27.000Z","updated":"2023-03-28T02:06:03.565Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"React","date":"2022-09-13T12:11:58.529Z","updated":"2022-09-13T12:11:58.529Z","comments":true,"path":"react-about/index.html","permalink":"http://example.com/react-about/index.html","excerpt":"","text":"react简介React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。React 中拥有多种不同类型的组件，我们先从 React.Component 的子类开始介绍： 12345678910111213141516class ShoppingList extends React.Component &#123; render() &#123; return ( &lt;div className=&quot;shopping-list&quot;&gt; &lt;h1&gt;Shopping List for &#123;this.props.name&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Instagram&lt;/li&gt; &lt;li&gt;WhatsApp&lt;/li&gt; &lt;li&gt;Oculus&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125;// 用法示例: &lt;ShoppingList name=&quot;Mark&quot; /&gt; 我们马上会讨论这些又奇怪、又像 XML 的标签。我们通过使用组件来告诉 React 我们希望在屏幕上看到什么。当数据发生改变时，React 会高效地更新并重新渲染我们的组件。 创建react项目1npx create-react-app 项目名 清空src目录创建index.js 12rm src/*touch src/index.js index.js 入口js: 用react-dom渲染注入点 12const root = ReactDOM.createRoot(dom节点)root.render(&lt;App /&gt;) JSXJSX: Javascript + XMLJSX是一个语法糖，React.createElement的语法糖 React.createElement定义 1React.createElement(组件, [属性props], [...children]) // 返回jsx元素 12345678910const element1 = &lt;h1&gt;hello&lt;/h1&gt; // element1的值叫做jsx的元素 // h1叫做jsx的组件const element2 = &lt;App /&gt; // element2是元素 // App是组件const element3 = &lt;button id=&#x27;okBtn&#x27; type=&#x27;button&#x27;&gt;OK&lt;/button&gt;const element4 = ( &lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;2&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;北京&lt;/option&gt; &lt;/select&gt;) React.createElement函数表达以上的代码(Babel转换成下面的代码)： 123456789const element1 = React.createElement(&#x27;h1&#x27;, null, &#x27;hello&#x27;)const element2 = React.createElement(App)const element3 = React.createElement( &#x27;button&#x27;, &#123;id: &#x27;okBtn&#x27;, type: &#x27;button&#x27;&#125;, &#x27;OK&#x27;)const element4 = React.createElement( &#x27;select&#x27;, &#123;name: &#x27;city&#x27;&#125;, React.createElement(&#x27;option&#x27;, &#123;value: &quot;1&quot;&#125;, &#x27;北京&#x27;), React.createElement(&#x27;option&#x27;, &#123;value: &quot;2&quot;&#125;, &#x27;上海&#x27;)) html和jsx的转换关系第一点：jsx要符合xml的标准，jsx的html组件必须名字为小写： tag必须成对出现(&lt;div&gt;...&lt;/div&gt;) 或者自结束标签(&lt;input /&gt;)html的tag结构不严谨1234const el1 = &lt;h1&gt;&lt;/H1&gt; // ❌ 大小写不一样const el2 = &lt;H1&gt;&lt;/H1&gt; // ❌ 不是html里的h1对应的组件，而是自定义H1组件const el3 = &lt;img &gt; // ❌ 无关闭标记const el4 = &lt;div&gt;&lt;b&gt;hello &lt;i&gt;world&lt;/b&gt;&lt;/i&gt;&lt;/div&gt; // ❌ 没有正确嵌套 第二点，jsx的属性名称由两个单词组成，用驼峰形式书写；html属性是不区分大小写的。 12&lt;input value=&#x27;&#x27; autoComplete=&#x27;on&#x27; data-id=&#x27;name&#x27;&gt;&lt;td colSpan=&#x27;2&#x27;&gt; 第三点：有一些属性名称在jsx中改变了: class -&gt; className for -&gt; htmlFor因为class和for都是js里的关键字，避免用关键字命名 第四点：有一些属性是html没有的 key - 值字符串，为了表示元素唯一性 ref - 为了引用dom元素或者jsx元素 defaultValue 用来代替 value属性 defaultChecked 用来代替checked属性 1234&lt;input type=&#x27;text&#x27; value=&#x27;abc&#x27;/&gt;&lt;input type=&#x27;text&#x27; defaultValue=&#x27;abc&#x27;/&gt;&lt;input type=&#x27;checkbox&#x27; checked /&gt;&lt;input type=&#x27;checkbox&#x27; defaultChecked /&gt; 第五点，html的style是字符串，jsx的style属性是object（dom里style对象的方式书写） 1&lt;span style=&#x27;font-size: 18px; color: red; text-decoration: underline&#x27;&gt;Hello World&lt;/span&gt; 1234&lt;span style=&#123;&#123;fontSize: &quot;18px&quot;, color: &quot;red&quot;, textDecoration: &quot;underline&quot;&#125;&#125;&gt;Hello World&lt;/span&gt;const styles = &#123;fontSize: &quot;18px&quot;, color: &quot;red&quot;, textDecoration: &quot;underline&quot;&#125;&lt;span style=&#123;styles&#125;&gt;Hello World&lt;/span&gt; 第六点，开关属性（cheched, disabled, readOnly）值是布尔类型 12345678&lt;input type=&#x27;text&#x27; readOnly=&#123;true&#125; /&gt;&lt;input type=&#x27;text&#x27; readOnly=&quot;true&quot; /&gt; &#123;/*错*/&#125;&lt;div className=&quot;container&quot;&gt;&lt;/div&gt;&lt;div className=&#123;&quot;container&quot;&#125;&gt;&lt;/div&gt;&lt;Counter value=&quot;1&quot; /&gt;&lt;Counter value=&#123;1&#125; /&gt; 第七点，children位置（指元素标记之间的内容&lt;b&gt;...&lt;/b&gt;）用字符串表达式，里面的内容会自动转义（html特殊字符会转换成html entity，&gt; 转换成 &amp;gt; ）避免XSS攻击 12&lt;div&gt;&#123;&quot;&lt;b&gt;hello&lt;/b&gt; world&quot;&#125;&lt;/div&gt;&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &quot;&lt;b&gt;hello&lt;/b&gt; world&quot;&#125;&#125;&gt;&lt;/div&gt; 第八点，html的注释&lt;!-- 注释内容 --&gt;，jsx的注释&#123;/* 注释 */&#125; 第九点，html里换行也是一个空格，jsx里换行不是空格 123&lt;span&gt;红灯&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;&lt;!-- 红灯 绿灯 --&gt; 123456&lt;span&gt;红灯&lt;/span&gt;&lt;span&gt;绿灯&lt;/span&gt;&#123;/* 红灯绿灯 */&#125;&lt;span&gt;红灯&lt;/span&gt;&#123;&#x27; &#x27;&#125;&lt;span&gt;绿灯&lt;/span&gt; 表达式使用表达式用&#123;表达式&#125;，表达式只能写一个语句（if&#x2F;for&#x2F;while&#x2F;switch不能在表达式里使用） 表达式可以用在children位置或者属性值位置 children位置的表达式里不能是普通object 有一些值放在表达式里没有任何渲染内容：false&#x2F;true&#x2F;null&#x2F;undefined&#x2F;NaN 12345678910111213141516171819&#123;1&#125;&#123;&#x27;1&#x27;&#125;&#123;false&#125;&#123;null&#125;&#123;1+1&#125;&#123;Math.random()&#125;&#123;&lt;div&gt;123&lt;/div&gt;&#125;&#123;Math.random() &gt; 0.5 ? &#x27;正面&#x27; : &#x27;背面&#x27;&#125;&#123;[1,2,3].map(n =&gt; n * 2).join(&#x27;, &#x27;)&#125;&#123;(function()&#123; if(Math.random()&gt;0.5) &#123; return 1 &#125; else &#123; return 2 &#125;&#125;)()&#125;&lt;div className=&#123;`row $&#123;index%2 ? &#x27;bg&#x27; : &#x27;&#x27;&#125;`&#125;&gt;&lt;/div&gt;&lt;div&gt;&#123;[1,2,3]&#125;&lt;/div&gt;&lt;ul&gt;&#123;[&lt;li&gt;1&lt;/li&gt;,&lt;li&gt;3&lt;/li&gt;,&lt;li&gt;2&lt;/li&gt;]&#125;&lt;/ul&gt; 表达式的扩展语法 123456789const params = &#123; className: &#x27;abc&#x27;, style: &#123;border: &#x27;1px solid red&#x27;&#125;, defaultValue: &#x27;hello&#x27;&#125;&lt;input className=&#123;params.className&#125; style=&#123;params.style&#125; defaultValue=&#123;params.defaultValue&#125; /&gt;&lt;input className=&#x27;xyz&#x27; &#123;...params&#125; className=&#x27;a&#x27;/&gt;"},{"title":"computed和method","date":"2022-09-12T11:23:00.620Z","updated":"2022-09-12T11:23:00.620Z","comments":true,"path":"vue-computed/com-and-met.html","permalink":"http://example.com/vue-computed/com-and-met.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt; &lt;!-- 插值表达式的实现 简单的js逻辑表达式 --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName +&#x27;-&#x27;+ lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName&#125;&#125; - &#123;&#123;lastName&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- 更复杂的通过方法的实现 methods中的方法调用一次就会执行一次 如果数据不需要更新 会造成性能的浪费--&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // 定义到data中的数据默认会被响应式监听 firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27; &#125;, methods: &#123; // fullName() &#123; // console.log(111); // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125;, // 计算属性computed: 计算属性的值本身不存在 是需要通过计算得到的 // 底层也是通过object.defineProperty来实现的 // computed 与 methods的区别 // 1、是否存在缓存: methods调用一次执行一次 // computed第一次调用时会将结果缓存 (有缓存)、后续调用在所依赖的数据不发生变化的前提下 直接返回缓存的结果 =&gt; 复用率高 提升性能 // 2、调用方式不同: methods使用时，一般情况需要加括号，而computed则不需要 // 3、绑定方式不同: methods是单向数据绑定 只有getter, computed是双向数据绑定, 有setter和getter // 使用场景 // 某个属性的值需要来自多个属性的简单计算或者复杂逻辑计算得出的值时, 推荐使用computed属性, 比如购物车的总价计算 computed: &#123; // 完整写法 fullName: &#123; // get作用: 当使用到fullName的时候 默认会调用get方法 // get特点: // 1、初次使用计算属性的时候会执行 // 2、当依赖的响应式数据发生变化的时候会执行 get() &#123; console.log(111); return this.firstName + &#x27;-&#x27; + this.lastName &#125;, // 如果需要修改计算属性 需要提供一个set方法 // 并且这个set方法中要能够引起依赖的数据的变化 set(val) &#123; let arr = val.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;, // 简写 // fullName()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"指令语法","date":"2022-09-12T11:20:38.897Z","updated":"2022-09-12T11:20:38.897Z","comments":true,"path":"vue-instruction/instruction.html","permalink":"http://example.com/vue-instruction/instruction.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445# 属性绑定 v-bind:# 功能：指定变化的属性值# 完整写法 v-bind:xxx=&#x27;yyy&#x27; // yyy会作为表达式解析执行# 简洁写法 :xxx=&#x27;yyy&#x27;# 属性绑定应用&lt;div id=&quot;app&quot;&gt; &lt;!-- 数组 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套三元表达式 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, isactive?&#x27;active&#x27;: &#x27;&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, &#123;active: isactive&#125;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class=&quot;&#123;red:true&#125;&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;h1 :class=&quot;styles&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&#x27;click&#x27;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, info: &#x27;明天就中秋了，你们的中秋节目准备的咋样了？&#x27;, isactive: true, index: 1, styles: &#123; red: true, thin: true, active: true &#125; &#125;, methods: &#123; click() &#123; console.log(this); &#125; &#125;, &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 单向数据绑定# 语法：v-bind:href =&quot;xxx&quot; 或简写为 :href =&quot;xxx&quot;# 特点：数据只能从 data 流向页面# 双向数据绑定 指令 v-model# 语法：v-mode:value=&quot;xxx&quot; 或简写为 v-model=&quot;xxx&quot;# 特点：数据不仅能从 data 流向页面，还能从页面流向 datav-model应用v-model:用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据&lt;p&gt;选择的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&#x27;province&#x27;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;杭州&lt;/option&gt;&lt;/select&gt;&lt;p&gt;您选中的是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;man&quot;&gt;man&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;woman&quot;&gt;woman&lt;p&gt;您的爱好是: &#123;&#123;loves&#125;&#125;&lt;/p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;game&quot; v-model=loves value=&quot;玩游戏&quot;&gt;玩游戏&lt;input type=&quot;checkbox&quot; name=&quot;music&quot; v-model=loves value=&quot;听音乐&quot;&gt;听音乐&lt;input type=&quot;checkbox&quot; name=&quot;basketball&quot; v-model=loves value=&quot;打篮球&quot;&gt;打篮球&lt;input type=&quot;checkbox&quot; name=&quot;eat&quot; v-model=loves value=&quot;吃东西&quot;&gt;吃东西&lt;input type=&quot;checkbox&quot; name=&quot;treenp&quot; v-model=loves value=&quot;吹牛皮&quot;&gt;吹牛皮.number: 将输入值转化为数字类型想要严格限制输入框只允许输入数字，请使用属性type=&quot;number&quot;&lt;input type=&quot;text&quot; v-model.number=&#x27;first&#x27; @keyup=&#x27;sum&#x27;&gt;+&lt;input type=&quot;text&quot; v-model.number=&#x27;last&#x27; @keyup=&#x27;sum&#x27;&gt; =&lt;span&gt;&#123;&#123;result&#125;&#125;&lt;/span&gt;.lazy: 当添加了.lazy修饰符后，双向绑定的数据就不同步了，相当于在input输入框失去焦点后触发的change事件中同步&lt;div&gt; &lt;input v-model.lazy=&quot;msg&quot; @change=&quot;show&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 老许 &#125; &#125;, methods: &#123; show () &#123; console.log(this.msg) &#125; &#125;&#125;&lt;/script&gt;.trim 自动去除输入框前后(首尾)空格如下: 如果直接在开头输入空格，或者是在末尾输入空格，是不会显示有输入内容的&lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt; v-on指令12345678v-on:click=&#x27;xxx&#x27;v-on:keyup=&#x27;xxx(参数)&#x27;v-on:keyup.enter=&#x27;xxx&#x27;功能：绑定指定事件名的回调函数简洁写法@click=&#x27;xxx&#x27;@keyup=&#x27;xxx&#x27;@keyup.enter=&#x27;xxx&#x27; 事件修饰符prevent：阻止默认事件（常用）； 12&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我&lt;/a&gt; stop：阻止事件冒泡（常用）； 12345&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;&lt;button @click.stop=&quot;showInfo&quot;&gt;点我&lt;/button&gt;&lt;!-- 修饰符可以连续写 先写的先起作用: 这样写就是先阻止默认行为后阻止冒泡--&gt;&lt;!-- &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我&lt;/a&gt; --&gt;&lt;/div&gt; once：事件只触发一次（常用） 123&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我&lt;/button&gt; 指令语法：条件渲染指令v-if是控制元素是否加载到页面上（有性能开销） 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。当条件不成立时, v-if 的所有子节点不会解析 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被 ‘打断’。 v-show是控制元素的显示与隐藏 （初始创建时加载一次） 切换频率较高的场景。不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 123456789&lt;p v-if=&#x27;flag&#x27;&gt;海底月是天上月&lt;/p&gt;&lt;p v-else&gt;眼前人是心上人&lt;/p&gt;&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;一般&lt;/p&gt;&lt;p v-else=&quot;type === &#x27;D&#x27;&quot;&gt;差&lt;/p&gt;&lt;p v-show=&#x27;flag&#x27;&gt;&lt;/p&gt; 列表渲染指令v-for指令: 1、用于展示列表数据 2、语法：v-for&#x3D;“(item, index) in xxx” :key&#x3D;“yyy” 3、可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 123456789101112131415161718192021222324252627282930&lt;!-- 遍历数组 --&gt;&lt;ul&gt; &lt;span&gt;key是唯一的标识 其数据类型只能是字符串或者数字&lt;/span&gt; &lt;!-- item代表数组中的每一项 --&gt; &lt;!-- 如果需要取下标 (item, index) --&gt; &lt;li v-for=&quot;(item,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历对象 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历字符串 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt; &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历指定次数 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125; &lt;/li&gt;&lt;/ul&gt; key使用注意事项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 面试题：react、vue中的key有什么作用？（key的内部原理）1. 虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：2.对比规则：(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 3. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key? 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。--&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;carname&#x27;&gt; &lt;button @click=&#x27;add&#x27;&gt;添加一辆车&lt;/button&gt; &lt;ul v-for=&#x27;(item, index) in list&#x27; :key=&#x27;item.id&#x27;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;input&gt;&lt;/input&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div &gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; carname: &#x27;&#x27;, nextId: 4, list: [ &#123;id: 001, name: &#x27;法拉利&#x27; &#125;, &#123;id: 002, name: &#x27;兰博基尼&#x27; &#125;, &#123;id: 003, name: &#x27;布加迪&#x27; &#125;] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.nextId, name: this.carname &#125;) this.nextId += 1 &#125; &#125; &#125;);&lt;/script&gt; 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100自定义指令总结：一、定义语法：(1).局部指令：new Vue(&#123; new Vue(&#123;directives:&#123;指令名:配置对象&#125; 或 directives&#123;指令名:回调函数&#125;&#125;) &#125;)(2).全局指令：Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：(1).bind：指令与元素成功绑定时调用。(2).inserted：指令所在元素被插入页面时调用。(3).update：指令所在模板结构被重新解析时调用。三、备注：1.指令定义时不加v-，但使用时要加v-；2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; v-focus&gt; --&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; 自定义指令: &lt;p v-two-double.flag=&quot;number&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;number += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; 自动聚焦: &lt;input type=&quot;text&quot; v-focus v-if=&quot;flag&quot;&gt;&lt;br&gt; &lt;button @click=&quot;del&quot;&gt;移除元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // ctrl+shift+k 删除当前行 Vue.config.productionTip = false // 1、自定义指令什么时候会被执行 ? // - 指令与页面元素绑定成功时(页面一打开) // - 自定义指令所在的vue模板被重新解析时 // 函数式写法 Vue.directive(&#x27;two-double&#x27;, (el, binding) =&gt; &#123; el.innerText = binding.value * 2 &#125;) // Vue.directive(&#x27;focus&#x27;, (el, binding) =&gt; &#123; // // 聚焦失败 原因是此时元素并没有渲染到页面上 // el.focus() // &#125;) // 对象式写法 Vue.directive(&#x27;focus&#x27;, &#123; // 指令与元素成功绑定时调用 bind(el,binding)&#123; el.style.backgroundColor = &#x27;skyblue&#x27; &#125;, // 指令所在元素被插入页面时调用 inserted(el,binding)&#123; el.focus() &#125;, // 指令所在模板结构被重新解析时调用 update(el,binding) &#123; console.log(&#x27;update&#x27;) &#125;, unbind()&#123; console.log(&#x27;unbind&#x27;) &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; number: 1, age: 1, flag: true &#125;, methods: &#123; del()&#123; this.flag = false &#125; &#125;, // 局部自定义指令 // directives: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"Nodejs内容","date":"2023-03-28T02:56:12.672Z","updated":"2023-03-28T02:56:12.672Z","comments":true,"path":"node-about/nodeall.html","permalink":"http://example.com/node-about/nodeall.html","excerpt":"","text":"|Nodejs简介 以下引自 Node.js 官网： 不是编程语言 也不是框架和库 是一个 JavaScript 运行时（环境） 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 文件 IO 网络 IO 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 Node 的特点事件驱动 非阻塞 IO（异步） 模型 单线程 跨平台 Node 的运行机制多线程处理机制： Web 服务器（Apache、Tomcat、IIS）：请求进来 Web 服务器开启一个线程来处理用户请求 同一时间有 n 请求，服务器就需要开启 n 个线程 一个线程最少得消耗 8MB 内存 对于一个 8GB 内存的服务器来说，它能应对的并发数是 1024 * 8 / 8 = 1024 个并发 事件驱动处理模型：Node 中低层封装了一堆的异步操作 API 文件操作 网络操作 ... JavaScript 语言本身是单线程的 模块通信规则require 模块导入 12345678910111213 // 核心模块var fs = require(&quot;fs&quot;);// 第三方模块// npm install markedvar marked = require(&quot;marked&quot;);// 用户模块（自己写的），正确的，正确的方式// 注意：加载自己写的模块，相对路径不能省略 ./var foo = require(&quot;./foo.js&quot;);// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .jsvar foo = require(&quot;./foo&quot;); require内部处理流程 检查Module._cache是够缓存到了指定模块 如果缓存没有的话，就创建一个新的module实例将他保存到缓存 module.load()加载指定模块 在解析的过程中如果发生异变，仓缓存中删除该模块 返回该模块的moudule.exprots exports 模块导出123456789101112131415161718192021// 导出多个成员：写法一module.exports.a = 123;module.exports.b = 456;module.exports.c = 789;//导出多个成员：写法二（推荐）Node 为了降低开发人员的痛苦，所以为 module.exports 提供了一个别名 exports （下面协大等价于上面的写法）。 console.log(exports === module.exports); // =&gt; trueexports.a = 123;exports.b = 456;exports.c = 789;exports.fn = function() &#123;&#125;;//导出单个成员：（唯一的写法）：// 导出单个成员：错误的写法// 因为每个模块最终导出是 module.exports 而不是 exports 这个别名// exports = function (x, y) &#123;// return x + y// &#125;// 导出单个成员：必须这么写module.exports = function(x, y) &#123; return x + y;&#125;; exports 和 module.exports 的区别 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 true 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 文件操作fs模块 | API | 作用 | 备注 | 123456789101112131415161718192021fs.access(path, callback) 判断路径是否存在 fs.appendFile(file, data, callback) 向文件中追加内容 fs.copyFile(src, callback) 复制文件 fs.mkdir(path, callback) 创建目录 fs.readDir(path, callback) 读取目录列表 fs.rename(oldPath, newPath, callback) 重命名文件/目录 fs.rmdir(path, callback) 删除目录 只能删除空目录fs.stat(path, callback) 获取文件/目录信息 fs.unlink(path, callback) 删除文件 fs.watch(filename[, options][, listener]) 监视文件/目录 fs.watchFile(filename[, options], listener) 监视文件 path 模块参考文档：https://nodejs.org/dist/latest-v9.x/docs/api/path.htmlpath 是 Node 本身提供的一个核心模块，专门用来处理路径。使用它的第一步就是先加载： 12const path = require(&quot;path&quot;); path.basename获取一个路径的文件名部分 12345path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;);// Returns: &#x27;quux.html&#x27;path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;, &quot;.html&quot;);// Returns: &#x27;quux&#x27; path.dirname 获取一个路径的目录部分 12 path.dirname(&quot;/foo/bar/baz/asdf/quux&quot;);// Returns: &#x27;/foo/bar/baz/asdf&#x27; path.extname获取一个路径的后缀名部分 1234567891011121314path.extname(&quot;index.html&quot;);// Returns: &#x27;.html&#x27;path.extname(&quot;index.coffee.md&quot;);// Returns: &#x27;.md&#x27;path.extname(&quot;index.&quot;);// Returns: &#x27;.&#x27;path.extname(&quot;index&quot;);// Returns: &#x27;&#x27;path.extname(&quot;.index&quot;);// Returns: &#x27;&#x27; Node + expressExpress 介绍 Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它可以轻松构建各种web应用，例如： 接口服务 传统的web网站 开发工具集成等（例如webpack的devServer） Express本身是极简的，仅仅提供了web开发的基础功能，但是它通过中间件的方式集成了许许多多的外部插件来处理HTTP请求。 body-parser：解析HTTP请求体 compression：压缩HTTP响应 cookie-parser：解析cookie 数据 cors：处理跨域资源请求 morgan：HTTP请求日志记录 Express中间件的特性固然强大，但是它所提供的灵活性是一把双刃剑。 它让Express本身变得更加灵活和简单 缺点在于虽然有一些中间件包可以解决几乎所有问题或需求，但是挑选合适的包有时也会成为一个挑战 有很多流行框架基于 Express Express 官网 express 安装 参考文档：http://expressjs.com/en/starter/installing.html 123456789 # 创建并切换到 myapp 目录mkdir myappcd myapp# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express Hello World 123456789101112131415// 0. 加载 Expressconst express = require(&quot;express&quot;);// 1. 调用 express() 得到一个 app// 类似于 http.createServer()const app = express();// 2. 设置请求对应的处理函数// 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);// 3. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log(&quot;app listening on port 3000!&quot;)); 查看更多Express内容"},{"title":"vue2简介","date":"2022-09-11T05:55:03.000Z","updated":"2022-09-12T08:59:54.282Z","comments":true,"path":"vueall/jianjie.html","permalink":"http://example.com/vueall/jianjie.html","excerpt":"","text":"Vue 是一套用于构建用户界面的 渐进式框架 。 与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 自从Vue 2.0 发布之后，Vue 就成了前端领域的热门话题。 2019.02.05，Vue 发布了 2.6.0 ，这是一个承前启后的版本，在它之后，推出了 3.0.0。 2019.12.05，在万众期待中，尤雨溪公布了 Vue 3 源代码，此时的 Vue 3仍 处于 Alpha 版本。 2020年09月18日，Vue.js 3.0 正式发布。"},{"title":"vue2内容","date":"2022-09-11T05:55:03.000Z","updated":"2023-03-28T02:55:15.366Z","comments":true,"path":"vue2/index.html","permalink":"http://example.com/vue2/index.html","excerpt":"","text":"|vue 简介 Vue 是一套用于构建用户界面的 渐进式框架 。 与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 自从Vue 2.0 发布之后，Vue 就成了前端领域的热门话题。 2019.02.05，Vue 发布了 2.6.0 ，这是一个承前启后的版本，在它之后，推出了 3.0.0。 2019.12.05，在万众期待中，尤雨溪公布了 Vue 3 源代码，此时的 Vue 3仍 处于 Alpha 版本。 2020年09月18日，Vue.js 3.0 正式发布。 Vue 周边生态 vue-cli：vue 脚手架vue-resource(axios)：ajax 请求vue-router：路由vuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）vue-lazyload：图片懒加载vue-scroller：页面滑动相关mint-ui：基于 vue 的 UI 组件库（移动端）element-ui：基于 vue 的 UI 组件库（PC 端） 原生计数器 1234567891011121314151617// 1. 获取DOM原生const titleEl = document.querySelector(&quot;.title&quot;);const btnInEl = document.querySelector(&#x27;.increment&#x27;);const btnDeEl = document.querySelector(&#x27;.decrement&#x27;);// 2. 默认设置的是Hello Worldlet counter = 0// 3. 设置titleEl的内容titleEl.innerHTML = counter;// 4. 监听按钮的点击btnInEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter += 1; titleEl.innerHTML =counter;&#125;)btnDeEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter -=1; titleEl.innerHTML = counter;&#125;) vue写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue指令: v-on:事件类型 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;!-- 简写 比如: @click @keyup @keydown --&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &#123;&#123; count &#125;&#125; &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 关闭生产提示 Vue.config.productionTip = false var vm = new Vue(&#123; el: &#x27;#app&#x27;, // 数据 data: &#123; count: 0 &#125;, // 方法 methods: &#123; increment()&#123; // this =&gt; vue实例 this.count++ &#125;, decrement()&#123; this.count-- &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 指令语法123456789101112131415161718192021222324252627282930313233343536373839404142434445# 属性绑定 v-bind:# 功能：指定变化的属性值# 完整写法 v-bind:xxx=&#x27;yyy&#x27; // yyy会作为表达式解析执行# 简洁写法 :xxx=&#x27;yyy&#x27;# 属性绑定应用&lt;div id=&quot;app&quot;&gt; &lt;!-- 数组 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套三元表达式 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, isactive?&#x27;active&#x27;: &#x27;&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, &#123;active: isactive&#125;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class=&quot;&#123;red:true&#125;&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;h1 :class=&quot;styles&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&#x27;click&#x27;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, info: &#x27;明天就中秋了，你们的中秋节目准备的咋样了？&#x27;, isactive: true, index: 1, styles: &#123; red: true, thin: true, active: true &#125; &#125;, methods: &#123; click() &#123; console.log(this); &#125; &#125;, &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 单向数据绑定# 语法：v-bind:href =&quot;xxx&quot; 或简写为 :href =&quot;xxx&quot;# 特点：数据只能从 data 流向页面# 双向数据绑定 指令 v-model# 语法：v-mode:value=&quot;xxx&quot; 或简写为 v-model=&quot;xxx&quot;# 特点：数据不仅能从 data 流向页面，还能从页面流向 datav-model应用v-model:用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据&lt;p&gt;选择的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&#x27;province&#x27;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;杭州&lt;/option&gt;&lt;/select&gt;&lt;p&gt;您选中的是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;man&quot;&gt;man&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;woman&quot;&gt;woman&lt;p&gt;您的爱好是: &#123;&#123;loves&#125;&#125;&lt;/p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;game&quot; v-model=loves value=&quot;玩游戏&quot;&gt;玩游戏&lt;input type=&quot;checkbox&quot; name=&quot;music&quot; v-model=loves value=&quot;听音乐&quot;&gt;听音乐&lt;input type=&quot;checkbox&quot; name=&quot;basketball&quot; v-model=loves value=&quot;打篮球&quot;&gt;打篮球&lt;input type=&quot;checkbox&quot; name=&quot;eat&quot; v-model=loves value=&quot;吃东西&quot;&gt;吃东西&lt;input type=&quot;checkbox&quot; name=&quot;treenp&quot; v-model=loves value=&quot;吹牛皮&quot;&gt;吹牛皮.number: 将输入值转化为数字类型想要严格限制输入框只允许输入数字，请使用属性type=&quot;number&quot;&lt;input type=&quot;text&quot; v-model.number=&#x27;first&#x27; @keyup=&#x27;sum&#x27;&gt;+&lt;input type=&quot;text&quot; v-model.number=&#x27;last&#x27; @keyup=&#x27;sum&#x27;&gt; =&lt;span&gt;&#123;&#123;result&#125;&#125;&lt;/span&gt;.lazy: 当添加了.lazy修饰符后，双向绑定的数据就不同步了，相当于在input输入框失去焦点后触发的change事件中同步&lt;div&gt; &lt;input v-model.lazy=&quot;msg&quot; @change=&quot;show&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 老许 &#125; &#125;, methods: &#123; show () &#123; console.log(this.msg) &#125; &#125;&#125;&lt;/script&gt;.trim 自动去除输入框前后(首尾)空格如下: 如果直接在开头输入空格，或者是在末尾输入空格，是不会显示有输入内容的&lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt; v-on指令12345678v-on:click=&#x27;xxx&#x27;v-on:keyup=&#x27;xxx(参数)&#x27;v-on:keyup.enter=&#x27;xxx&#x27;功能：绑定指定事件名的回调函数简洁写法@click=&#x27;xxx&#x27;@keyup=&#x27;xxx&#x27;@keyup.enter=&#x27;xxx&#x27; 事件修饰符prevent：阻止默认事件（常用）； 12&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我&lt;/a&gt; stop：阻止事件冒泡（常用）； 12345&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;&lt;button @click.stop=&quot;showInfo&quot;&gt;点我&lt;/button&gt;&lt;!-- 修饰符可以连续写 先写的先起作用: 这样写就是先阻止默认行为后阻止冒泡--&gt;&lt;!-- &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我&lt;/a&gt; --&gt;&lt;/div&gt; once：事件只触发一次（常用） 123&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我&lt;/button&gt; 指令语法：条件渲染指令v-if是控制元素是否加载到页面上（有性能开销） 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。当条件不成立时, v-if 的所有子节点不会解析 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被 ‘打断’。 v-show是控制元素的显示与隐藏 （初始创建时加载一次） 切换频率较高的场景。不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 123456789&lt;p v-if=&#x27;flag&#x27;&gt;海底月是天上月&lt;/p&gt;&lt;p v-else&gt;眼前人是心上人&lt;/p&gt;&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;一般&lt;/p&gt;&lt;p v-else=&quot;type === &#x27;D&#x27;&quot;&gt;差&lt;/p&gt;&lt;p v-show=&#x27;flag&#x27;&gt;&lt;/p&gt; 列表渲染指令v-for指令: 1、用于展示列表数据 2、语法：v-for&#x3D;“(item, index) in xxx” :key&#x3D;“yyy” 3、可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 123456789101112131415161718192021222324252627282930&lt;!-- 遍历数组 --&gt;&lt;ul&gt; &lt;span&gt;key是唯一的标识 其数据类型只能是字符串或者数字&lt;/span&gt; &lt;!-- item代表数组中的每一项 --&gt; &lt;!-- 如果需要取下标 (item, index) --&gt; &lt;li v-for=&quot;(item,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历对象 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历字符串 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt; &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历指定次数 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125; &lt;/li&gt;&lt;/ul&gt; key使用注意事项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 面试题：react、vue中的key有什么作用？（key的内部原理）1. 虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：2.对比规则：(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 3. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key? 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。--&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;carname&#x27;&gt; &lt;button @click=&#x27;add&#x27;&gt;添加一辆车&lt;/button&gt; &lt;ul v-for=&#x27;(item, index) in list&#x27; :key=&#x27;item.id&#x27;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;input&gt;&lt;/input&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div &gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; carname: &#x27;&#x27;, nextId: 4, list: [ &#123;id: 001, name: &#x27;法拉利&#x27; &#125;, &#123;id: 002, name: &#x27;兰博基尼&#x27; &#125;, &#123;id: 003, name: &#x27;布加迪&#x27; &#125;] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.nextId, name: this.carname &#125;) this.nextId += 1 &#125; &#125; &#125;);&lt;/script&gt; 过滤器​ 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。 ​ 语法： ​ 1.注册过滤器：Vue.filter (name,callback) 或 new Vue { filters:{} } ​ 2.使用过滤器： 1&#x27;&#123;&#123; xxx | 过滤器名 &#125;&#125;&#x27; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot; ​ 备注： ​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联 ​ 2.并没有改变原本的数据, 是产生新的对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt; !--准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; fmtTime &#125;&#125;&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; getFmtTime() &#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;&lt;/h3&gt; &lt;h3 :x=&quot;msg | mySlice&quot;&gt;哈哈哈&lt;/h3&gt; &lt;/div &gt; &lt;div id=&quot;root2&quot;&gt; &lt;h2&gt;&#123;&#123; msg | mySlice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body &gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //全局过滤器 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4) &#125;) new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; time:1621561377603, //时间戳 msg:&#x27;你好，vue&#x27; &#125;, computed: &#123; fmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, methods: &#123; getFmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, //局部过滤器 filters:&#123; timeFormater(value, str = &#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123; // console.log(&#x27;@&#x27;,value) return dayjs(value).format(str) &#125; &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; msg:&#x27;hello,vue!&#x27; &#125; &#125;) computed和method123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt; &lt;!-- 插值表达式的实现 简单的js逻辑表达式 --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName +&#x27;-&#x27;+ lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName&#125;&#125; - &#123;&#123;lastName&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- 更复杂的通过方法的实现 methods中的方法调用一次就会执行一次 如果数据不需要更新 会造成性能的浪费--&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // 定义到data中的数据默认会被响应式监听 firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27; &#125;, methods: &#123; // fullName() &#123; // console.log(111); // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125;, // 计算属性computed: 计算属性的值本身不存在 是需要通过计算得到的 // 底层也是通过object.defineProperty来实现的 // computed 与 methods的区别 // 1、是否存在缓存: methods调用一次执行一次 // computed第一次调用时会将结果缓存 (有缓存)、后续调用在所依赖的数据不发生变化的前提下 直接返回缓存的结果 =&gt; 复用率高 提升性能 // 2、调用方式不同: methods使用时，一般情况需要加括号，而computed则不需要 // 3、绑定方式不同: methods是单向数据绑定 只有getter, computed是双向数据绑定, 有setter和getter // 使用场景 // 某个属性的值需要来自多个属性的简单计算或者复杂逻辑计算得出的值时, 推荐使用computed属性, 比如购物车的总价计算 computed: &#123; // 完整写法 fullName: &#123; // get作用: 当使用到fullName的时候 默认会调用get方法 // get特点: // 1、初次使用计算属性的时候会执行 // 2、当依赖的响应式数据发生变化的时候会执行 get() &#123; console.log(111); return this.firstName + &#x27;-&#x27; + this.lastName &#125;, // 如果需要修改计算属性 需要提供一个set方法 // 并且这个set方法中要能够引起依赖的数据的变化 set(val) &#123; let arr = val.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;, // 简写 // fullName()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.21.4/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;name&#x27;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&#x27;student.loves.playGame.tencent.name&#x27;&gt; &lt;/div&gt; &lt;script&gt; // watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作 var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // _data会收集data中的数据 处理成响应式 // 再将其挂载到vm实例对象下方便开发者使用 =&gt; 数据代理 // 响应式: 简单的说就是数据发生变化 页面会重新渲染 // 页面发生变化 数据也会随之变化 name: &#x27;admin&#x27;, message: &#x27;&#x27;, student: &#123; loves: &#123; playGame: &#123; tencent: &#123; name: &#x27;王者荣耀&#x27;, price: 99 &#125;, wangyi: &#123; name: &#x27;和平精英&#x27;, &#125; &#125; &#125; &#125; &#125;, methods: &#123;&#125;, watch: &#123; // 侦听器本质是一个函数 需要侦听谁 就将侦听的属性当作函数名放到watch中即可 // 当被监视的属性发生变化时，回调函数自动调用，执行函数中的代码 // name() &#123; // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125; // 有配置项的情况 将函数改造成对象的形式 // name: &#123; // async handler(newVal, oldVal) &#123; // console.log(111); // console.log(&#x27;新值&#x27;+ newVal, &#x27;老值&#x27;+ oldVal); // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125;, // 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器 // 执行handler函数中的内容 // immediate: true, // &#125;, // 如果层次不深 可以直接通过这种方式侦听 // &#x27;student.name&#x27;:&#123;&#125; // &#x27;student.loves.playGame.tencent.name&#x27;:&#123; // handler(newVal)&#123; // console.log(11111); // console.log(newVal); // &#125; // &#125; // vue中的watch默认不监视对象内部的值改变 student: &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 // deep: true &#125; &#125; &#125;); vm.$watch(&#x27;student&#x27;, &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 deep: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed和watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, // 侦听器的方式 watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, // 计算属性的方式 computed: &#123; fullName() &#123; this.fullName = this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; // computed和watch的区别 // 1、computed是有缓存的 watch没有 // 2、computed一般执行同步操作 异步操作在watch中实现 // 3、computed监听的那个数据的数据发生变化时,不会重新计算,只有依赖的数据发生变化时才会重新调用getter来计算 // watch监听的数据发生变化时 立马执行相应的回调函数重新计算 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据代理什么是数据代理？ 通过一个对象代理对另一个对象中属性的操作（读&#x2F;写） 123456789101112let obj1 = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.defineProperty(obj2, &#x27;x&#x27;, &#123; get() &#123; return obj1.x &#125;, set(value) &#123; obj1.x = value &#125;&#125;)此时操作obj2实际上在操作obj1 vue中的数据代理 vue里面data的数据代理 通过_data收集data中的数据 利用Object.defineProperty中的get和set将data中的每个数据进行数据代理 再将代理好的数据挂载到vm实例上 好处: 方便开发者操作data中的数据 Vue.set()注意：受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新 如果想要数据是响应式的并且能触发视图更新 使用Vue.set() (比如 this.myObject.newProperty &#x3D; ‘hi’) 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100自定义指令总结：一、定义语法：(1).局部指令：new Vue(&#123; new Vue(&#123;directives:&#123;指令名:配置对象&#125; 或 directives&#123;指令名:回调函数&#125;&#125;) &#125;)(2).全局指令：Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：(1).bind：指令与元素成功绑定时调用。(2).inserted：指令所在元素被插入页面时调用。(3).update：指令所在模板结构被重新解析时调用。三、备注：1.指令定义时不加v-，但使用时要加v-；2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; v-focus&gt; --&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; 自定义指令: &lt;p v-two-double.flag=&quot;number&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;number += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; 自动聚焦: &lt;input type=&quot;text&quot; v-focus v-if=&quot;flag&quot;&gt;&lt;br&gt; &lt;button @click=&quot;del&quot;&gt;移除元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // ctrl+shift+k 删除当前行 Vue.config.productionTip = false // 1、自定义指令什么时候会被执行 ? // - 指令与页面元素绑定成功时(页面一打开) // - 自定义指令所在的vue模板被重新解析时 // 函数式写法 Vue.directive(&#x27;two-double&#x27;, (el, binding) =&gt; &#123; el.innerText = binding.value * 2 &#125;) // Vue.directive(&#x27;focus&#x27;, (el, binding) =&gt; &#123; // // 聚焦失败 原因是此时元素并没有渲染到页面上 // el.focus() // &#125;) // 对象式写法 Vue.directive(&#x27;focus&#x27;, &#123; // 指令与元素成功绑定时调用 bind(el,binding)&#123; el.style.backgroundColor = &#x27;skyblue&#x27; &#125;, // 指令所在元素被插入页面时调用 inserted(el,binding)&#123; el.focus() &#125;, // 指令所在模板结构被重新解析时调用 update(el,binding) &#123; console.log(&#x27;update&#x27;) &#125;, unbind()&#123; console.log(&#x27;unbind&#x27;) &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; number: 1, age: 1, flag: true &#125;, methods: &#123; del()&#123; this.flag = false &#125; &#125;, // 局部自定义指令 // directives: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"},{"title":"Vue 周边生态","date":"2022-09-12T11:17:50.202Z","updated":"2022-09-12T11:17:50.202Z","comments":true,"path":"vuesurroun/vuesurroun.html","permalink":"http://example.com/vuesurroun/vuesurroun.html","excerpt":"","text":"vue-cli：vue 脚手架vue-resource(axios)：ajax 请求vue-router：路由vuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）vue-lazyload：图片懒加载vue-scroller：页面滑动相关mint-ui：基于 vue 的 UI 组件库（移动端）element-ui：基于 vue 的 UI 组件库（PC 端）"},{"title":"computed和watch","date":"2022-09-12T11:26:44.984Z","updated":"2022-09-12T11:26:44.984Z","comments":true,"path":"vue-watch/com-and-watch.html","permalink":"http://example.com/vue-watch/com-and-watch.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, // 侦听器的方式 watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, // 计算属性的方式 computed: &#123; fullName() &#123; this.fullName = this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; // computed和watch的区别 // 1、computed是有缓存的 watch没有 // 2、computed一般执行同步操作 异步操作在watch中实现 // 3、computed监听的那个数据的数据发生变化时,不会重新计算,只有依赖的数据发生变化时才会重新调用getter来计算 // watch监听的数据发生变化时 立马执行相应的回调函数重新计算 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"}],"posts":[{"title":"vue3内容","slug":"vue3","date":"2022-10-16T02:46:27.000Z","updated":"2023-03-31T07:13:19.544Z","comments":true,"path":"2022/10/16/vue3/","link":"","permalink":"http://example.com/2022/10/16/vue3/","excerpt":"","text":"vue3简介2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 vue3带来了什么 1.性能的提升打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% … 2.源码的升级使用Proxy代替defineProperty实现响应式 重写虚拟DOM的实现和Tree-Shaking … 3.拥抱TypeScriptVue3可以更好的支持TypeScript vue3新的特性 Composition API（组合API） setup配置ref与reactivewatch与watchEffectprovide与inject…新的内置组件 FragmentTeleportSuspense其他改变 新的生命周期钩子data 选项应始终被声明为一个函数移除keyCode支持作为 v-on 的修饰符…… 创建vue3项目 123456789 ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue3_study## 启动cd vue3_studynpm run serve vue2 Options API的弊端 在Vue2中，我们编写组件的方式是 OptionsAPI： Options API的一大特点就是在对应的属性中编写对应的功能模块； 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子；但是这种代码有一个很大的弊端： 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中； 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散； 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）； setup函数我们先来研究一个setup函数的参数，它主要有两个参数： 第一个参数：props 第二个参数：context props非常好理解，它其实就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取： 对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义； 并且在template中依然是可以正常去使用props中的属性，比如message； 如果我们在setup函数中想要使用props，那么不可以通过 this 去获取（后面我会讲到为什么）； 因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可； 另外一个参数是context，我们也称之为是一个SetupContext，它里面包含三个属性： attrs：所有的非prop的attribute； slots：父组件传递过来的插槽（这个在以渲染函数返回时会有作用，后面会讲到）； emit：当我们组件内部需要发出事件时会用到emit（因为我们不能访问this，所以不可以通过 this.$emit发出事件）； setup函数的返回值setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）若返回一个渲染函数：则可以自定义渲染内容 reactive函数作用: 定义一个对象类型的响应式数据（基本类型不要用它，控制台会报警告，要用ref函数）语法：const 代理对象&#x3D; reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）reactive定义的响应式数据是“深层次的”。内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 ref函数作用: 定义一个响应式的数据语法: const xxx &#x3D; ref(initValue)创建一个包含响应式数据的引用对象（reference对象，简称ref对象）, 其内部的值是在ref.value属性中被维护的 。JS中操作数据： xxx.value模板中读取数据: vue自动帮我们进行解包操作，不需要.value，直接：备注：接收的数据可以是：基本类型、也可以是对象类型。基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。对象类型的数据：内部 求助 了Vue3.0中的一个新函数—— reactive函数。 toRefs 如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后无论是修改解构后的变量，还是修改reactive返回的state对象，数据都不再是响应式的：Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref； 1const &#123;name,age&#125; = toRefs(state) 那么我们再次进行结构出来的 name 和 age 本身都是 ref的；这种做法相当于已经在state.name和ref.value之间建立了 链接，任何一个修改都会引起另外一个变化； toRef 123 const name= toRef(state, &#x27;name &#x27; );const &#123;age&#125; = state;const changeName = ()=&gt;state.name = &quot;coderwhy&quot;; 如果我们只希望转换一个reactive对象中的属性为ref, 那么可以使用toRef的方法 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 ref 的其他APIunref如果我们想要获取一个ref引用中的value，那么也可以通过unref方法： 如果参数是一个 ref，则返回内部值，否则返回参数本身； 这是 val &#x3D; isRef(val) ? val.value : val 的语法糖函数； isRef判断值是否是一个ref对象。 shallowRef创建一个浅层的ref对象； triggerRef手动触发和 shallowRef 相关联的副作用shallowRefshallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。如果有一个对象数据，后续功能不会修改该对象中的属性，而是产生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。customRef创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制： 它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数； 并且应该返回一个带有 get 和 set 的对象； ref &amp; reactive从定义数据角度对比：ref用来定义：基本类型数据。reactive用来定义：对象（或数组）类型数据。备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。从原理角度对比：ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。从使用角度对比：ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。reactive定义的数据：操作数据与读取数据：均不需要.value。 响应式原理vu2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 // vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到let obj = &#123; name: &#x27;zs&#x27;, age: 18, phone: &#123; name: &#x27;iphone&#x27; &#125;&#125;// let obj = [1, 2, 3, 4, 5]// 视图更新的方法function render() &#123; console.log(&#x27;视图更新了 ~&#x27;);&#125;let methods = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;]// 将数组的原型保存一份let arrProto = Array.prototype// 创建原型 将数组原型拷贝一份let proto = Object.create(arrProto)// 重写数组的方法methods.forEach(method =&gt; &#123; proto[method] = function () &#123; // AOP 面向切面编程 // 改变了数组的数据 arrProto[method].call(this, ...arguments) // 重新渲染视图 render() &#125;&#125;)// 观察者模式 function observe(obj) &#123; // 判断一个对象是不是数组 // if(Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;)&#123; if (Array.isArray(obj)) &#123; // 让观测的对象的原型和我们自己重写的原型建立关系 obj.__proto__ = proto return; &#125; // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get) if (Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;) &#123; // 取出对象中的每一个键和值 for (let key in obj) &#123; // 调用响应式处理函数 defineReactive(obj, key, obj[key]) &#125; &#125;&#125;// 观察obj对象observe(obj)// 响应式处理// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。function defineReactive(obj, key, val) &#123; // 检测对象的属性值是否还是对象 observe(val) Object.defineProperty(obj, key, &#123; // 获取 get() &#123; return val &#125;, // 设置 set(newVal) &#123; // 检测设置的值是不是对象 observe(newVal) // 新值和旧值不相等的时候 if (newVal !== val) &#123; // 覆盖掉原来的val值 val = newVal // 通知render函数重新渲染视图 render() &#125; &#125; &#125;)&#125;// obj.name = &#x27;lisi&#x27;// obj.age = 20// console.log(obj.name, obj.age);// 至此 基本可以实现数据发生变化 视图更新的效果// 但是 如果数据有多层呢 也就是属性对应的值也是对象?// obj.phone.name = &#x27;huawei&#x27;// console.log(obj.phone.name);// 修改的值和原来的值一样 不需要重新渲染视图// obj.phone.name = &#x27;iphone&#x27;// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染// obj.phone = &#123;name: &#x27;huawei&#x27;&#125;// 并且当修改新的对象的属性值时 视图也要重新渲染// obj.phone.name = &#x27;zs&#x27;// 为对象新增属性值呢? 也是没有办法监测到的// obj.sex = &#x27;man&#x27;// $set来解决这个function $myset(obj, key, val)&#123; if(Array.isArray(obj))&#123; return obj.splice(key, val) &#125; defineReactive(obj, key, val)&#125;// $myset(obj, &#x27;sex&#x27;, &#x27;man&#x27;)// 修改新增的属性值 视图也能更新// obj.sex = &#x27;woman&#x27;// obj.phone = Object.assign(obj.phone, &#123;price: &#x27;666&#x27;&#125;)// obj.phone.price = 888// obj.phone = &#123;...obj.phone, ...&#123;price: &#x27;666&#x27;&#125;&#125;// obj.phone.price = &#x27;888&#x27;// 以后vue涉及到给data中的对象新增属性时 有三种方式// 1、this.$set() || Vue.set()// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))// 2、obj = &#123;...原对象, ...新对象(新增的属性:值)&#125;// =================== 数组 ======================// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写// obj.push(6)// obj.length ++ // obj[0] = 88// $myset(obj, &#x27;0&#x27;, 66) vue3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 // vue3响应式原理利用了es6提供的proxy Api// 可以直接监听到对象和数组内容及长度的变化// 缺点: 兼容性差 支持就用proxy 不支持就用Objcet.definePropertylet obj = &#123; name: &#x27;zs&#x27;, girlFriend: &#123; name: &#x27;刘亦菲&#x27; &#125;, arr: [1, 2, 3]&#125;function render() &#123; console.log(&#x27;视图重新渲染 ~&#x27;);&#125;let handler = &#123; get(target, key) &#123; // Reflect.get(target, propertyKey[, receiver]) // 获取对象身上某个属性的值，类似于 target[name]。 // 如果属性的值是一个对象的话 则重新进行代理 设置set&amp;get if(typeof target[key] == &#x27;object&#x27; &amp;&amp; target[key] != null)&#123; return new Proxy(target[key], handler) &#125; return Reflect.get(target, key) &#125;, set(target, key, val) &#123; // if(target[key] == &#x27;length&#x27;) return true Reflect.set(target, key, val) render() // return true表示赋值成功 如果不返回true 在严格模式下可能会报TypeError return true &#125;&#125;let proxy = new Proxy(obj, handler)// 使用代理后的对象// console.log(proxy.name);// console.log(proxy.grilFriend);// proxy.name = &#x27;lisi&#x27;// 修改深层次的对象的属性 无法监听到// proxy.grilFriend.name = &#x27;黄圣依&#x27;// console.log(proxy.name);// console.log(proxy.grilFriend);// console.log(obj.name);// console.log(obj.grilFriend);proxy.arr[0] = &#x27;11&#x27;proxy.arr.length ++// console.log(proxy.arr.length);console.log(obj.arr.length);","categories":[],"tags":[]},{"title":"小程序","slug":"Small_program","date":"2021-10-25T02:46:27.000Z","updated":"2023-03-31T07:13:13.618Z","comments":true,"path":"2021/10/25/Small_program/","link":"","permalink":"http://example.com/2021/10/25/Small_program/","excerpt":"","text":"浅谈小程序 在 2016 年的「微信公开课 Pro」演讲中，微信事业群总裁张小龙这样描述了小程序的前景与未来： “ 小程序是一种不需要下载安装即可使用的应用，它实现了应用 “触手可及” 的梦想，用户扫一扫或者搜一下即可打开应用。也体现了 “用完即走” 的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无须安装卸载 “。 小程序刚发布的时候要求压缩包的体积不能大于 1M，否则无法通过，在 2017 年 4 月做 了改进，由原来的 1M 提升到 2M； 2017 年 1 月 9 日 0 点，万众瞩目的微信第一批小程序正式低调上线。 什么样的应用适合使用小程序开发?虽然小程序市场时至今日依然是一片蓝海，但我想也不是所有应用「都可以，都应该」使用小程序开发的。 基于我们的经验与积累来说，符合「逻辑简单，使用低频，对性能要求不极致」的应用场景，更加适合使用小程序进行研发。 逻辑简单：是指应用的操作逻辑并不十分复杂，各类生活服务（如打车，订餐，查地图与导航等等）都需要给用户提供简单清晰的操作逻辑，而这一类也天然的符合起初小程序「用完即走」的定义，因此十分符合使用小程序研发。一些逻辑复杂的应用场景想要通过小程序进行适配，就可能会面临更多的设计与研发困难，同时在性能和体验也可能会面对更多需要解决的问题。 使用低频：是指小程序的使用频率不应该太高，比如社交类的钉钉或飞书，金融类的掌上生活或浦大喜奔，媒体类的网易云音乐或斗鱼都不太适合使用小程序进行重新设计。对于用户使用的频率较高的应用来说，直接打开应用进行体验的步骤肯定最快的，此外由于某些行业的特殊性质（比如具备交易，支付等能力）要求，对于安全性与保密性的首选风险判断原则，也不宜使用常见的小程序进行设计。 对性能要求不极致：是指由于小程序始终存在于某个独立应用（也被称为宿主应用）中，考虑到目前的性能与研发所限制，暂时不太适合开发对于这两者有更高要求的移动应用。比如把原神，王者荣耀这样的游戏应用通过小程序进行重新设计，在目前来说肯定是不现实的。 当然，随着相关研发实力的增强与产业生态的逐渐补充，也有越来越多的「不可能」变为了「可能」，比如华西证券的「华彩人生」，浦发银行的「浦大喜奔」，某省的移动警务平台等客户都选择使用小程序容器方案进行落地实现 小程序与H5，原生应用有何区别？很多朋友在了解小程序技术的时候，都会有这样的疑惑“到底与 H5，原生应用”这些技术相比，小程序具有哪些优势与劣势呢？ H5 移动应用我们常说的 H5 其实也通常可以被视为一种 Web App，相比于我们在桌面端浏览器中打开的网页，主要是增加了一些响应式的设计与交互优化，从而使得这些网页更适合在移动端的浏览器中显示运行。既然是网页应用，那依然是基于 JavaScript，CSS 和 HTML 进行实现的，由于是基于各类前端技术栈进行实现，最大的好处就是快速、简单、方便，且有各种技术资料可以参考。 同样，H5 的缺点与优点也是并存的，比如由于技术已经很成熟了，对于前端经验欠缺的新人来说，面对各式各样的框架，模块、任务管理工具，UI 库可能会出现无从下手的问题；此外相比于原生应用，对于系统权限的获取（比如数据缓存能力，网络通信状态等）都显得比较鸡肋，当低性能的设备加载包含复杂逻辑的页面时，会出现明显的卡顿与延迟问题。 原生应用原生应用也被叫做 Native App，相比于 H5 应用通过前端三大件进行实现不同，原生应用主要会采用 iOS 与 Android 的专有语言 Object-C（或 Swift），Java（或 Kotlin）进行实现，大多我们所常见的国民应用，比如微信，支付宝等都属于这种原生应用。 既然被叫做「原生应用」，就像操作系统的亲儿子一样，天然在性能与体验上具备优秀的潜质，也有组件库丰富，接口支持完善等各种优势特点。但原生应用最大的缺陷就是不能跨平台研发，以目前的主流市场为例，必须要支持 iOS 与 Android 两个主流平台。 混合应用混合应用一般被称为 Hybrid App。简单来说，混合应用就是将原生功能封装成对应的 JS 接口，在前端使用 H5 来开发对应的 App （即 H5 作为内容+原生应用作为壳） ，看上去虽然是一个移动原生应用整体，但实际的页面还是网页，一套代码可以生成 iOS 与 Android 两种安装包，开发成本较低。 我们常见的淘宝，京东等应用由于更新与优化节奏都十分快速，为了更好的响应「贴近用户」的目标，应用中有的功能通过原生 Native 实现，有的功能则通过 H5 页面进行实现，这种应用就属于我们所说的混合应用。 小程序严格意义上来说，小程序并不属于以上 3 种应用的任何一种。小程序主要通过 JavaScript 与 CSS 这种常见的前端技术进行开发，但又没有完全使用 HTML 进行实现，在不同的操作系统中，JavaScript 代码分别运行在 iOS 的 JavaScriptCore 与 Android 的 X5 JSCore 中，各家小程序平台或多或少都有一部分自研的核心，因此渲染视图层的组件也有所不同。 相比「 H5 移动应用」与「 移动原生应用」，小程序具备如下优势：具备跨平台的能力，一套代码可以在 iOS 与 Android 两个平台中运行；远超过 H5 的体验（支持本地缓存，Webview，有丰富的组件与支持库）；能获取更多系统权限，完成更加丰富的产品设计；可以避免 DOM 泄露（不使用常用的 window 对象与 document 对象）；开发简单，上手成本低（比如 FinClip 提供了 FIDE 与开发文档）；","categories":[],"tags":[]},{"title":"Nodejs内容","slug":"nodejs","date":"2021-10-22T01:32:27.000Z","updated":"2023-03-31T07:12:44.647Z","comments":true,"path":"2021/10/22/nodejs/","link":"","permalink":"http://example.com/2021/10/22/nodejs/","excerpt":"","text":"Nodejs简介 以下引自 Node.js 官网： 不是编程语言 也不是框架和库 是一个 JavaScript 运行时（环境） 能解析和执行 JavaScript 代码（严格来说应该是 ECMAScript 代码） 构建于 Chrome V8 JavaScript 引擎之上 为 JavaScript 提供了服务端编程的能力 文件 IO 网络 IO 从技术角度它的能力和 Java、PHP、Python、Perl、Ruby 等服务端技术类似 Node 的特点事件驱动 非阻塞 IO（异步） 模型 单线程 跨平台 Node 的运行机制多线程处理机制： Web 服务器（Apache、Tomcat、IIS）：请求进来 Web 服务器开启一个线程来处理用户请求 同一时间有 n 请求，服务器就需要开启 n 个线程 一个线程最少得消耗 8MB 内存 对于一个 8GB 内存的服务器来说，它能应对的并发数是 1024 * 8 / 8 = 1024 个并发 事件驱动处理模型：Node 中低层封装了一堆的异步操作 API 文件操作 网络操作 ... JavaScript 语言本身是单线程的 模块通信规则require 模块导入 12345678910111213 // 核心模块var fs = require(&quot;fs&quot;);// 第三方模块// npm install markedvar marked = require(&quot;marked&quot;);// 用户模块（自己写的），正确的，正确的方式// 注意：加载自己写的模块，相对路径不能省略 ./var foo = require(&quot;./foo.js&quot;);// 用户模块（自己写的），正确的（推荐），可以省略后缀名 .jsvar foo = require(&quot;./foo&quot;); require内部处理流程 检查Module._cache是够缓存到了指定模块 如果缓存没有的话，就创建一个新的module实例将他保存到缓存 module.load()加载指定模块 在解析的过程中如果发生异变，仓缓存中删除该模块 返回该模块的moudule.exprots exports 模块导出123456789101112131415161718192021// 导出多个成员：写法一module.exports.a = 123;module.exports.b = 456;module.exports.c = 789;//导出多个成员：写法二（推荐）Node 为了降低开发人员的痛苦，所以为 module.exports 提供了一个别名 exports （下面协大等价于上面的写法）。 console.log(exports === module.exports); // =&gt; trueexports.a = 123;exports.b = 456;exports.c = 789;exports.fn = function() &#123;&#125;;//导出单个成员：（唯一的写法）：// 导出单个成员：错误的写法// 因为每个模块最终导出是 module.exports 而不是 exports 这个别名// exports = function (x, y) &#123;// return x + y// &#125;// 导出单个成员：必须这么写module.exports = function(x, y) &#123; return x + y;&#125;; exports 和 module.exports 的区别 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 true 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 文件操作fs模块 | API | 作用 | 备注 | 123456789101112131415161718192021fs.access(path, callback) 判断路径是否存在 fs.appendFile(file, data, callback) 向文件中追加内容 fs.copyFile(src, callback) 复制文件 fs.mkdir(path, callback) 创建目录 fs.readDir(path, callback) 读取目录列表 fs.rename(oldPath, newPath, callback) 重命名文件/目录 fs.rmdir(path, callback) 删除目录 只能删除空目录fs.stat(path, callback) 获取文件/目录信息 fs.unlink(path, callback) 删除文件 fs.watch(filename[, options][, listener]) 监视文件/目录 fs.watchFile(filename[, options], listener) 监视文件 path 模块参考文档：https://nodejs.org/dist/latest-v9.x/docs/api/path.htmlpath 是 Node 本身提供的一个核心模块，专门用来处理路径。使用它的第一步就是先加载： 12const path = require(&quot;path&quot;); path.basename获取一个路径的文件名部分 12345path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;);// Returns: &#x27;quux.html&#x27;path.basename(&quot;/foo/bar/baz/asdf/quux.html&quot;, &quot;.html&quot;);// Returns: &#x27;quux&#x27; path.dirname 获取一个路径的目录部分 12 path.dirname(&quot;/foo/bar/baz/asdf/quux&quot;);// Returns: &#x27;/foo/bar/baz/asdf&#x27; path.extname获取一个路径的后缀名部分 1234567891011121314path.extname(&quot;index.html&quot;);// Returns: &#x27;.html&#x27;path.extname(&quot;index.coffee.md&quot;);// Returns: &#x27;.md&#x27;path.extname(&quot;index.&quot;);// Returns: &#x27;.&#x27;path.extname(&quot;index&quot;);// Returns: &#x27;&#x27;path.extname(&quot;.index&quot;);// Returns: &#x27;&#x27; Node + expressExpress 介绍 Express 是一个基于 Node.js 平台，快速、开放、极简的 web 开发框架。 它可以轻松构建各种web应用，例如： 接口服务 传统的web网站 开发工具集成等（例如webpack的devServer） Express本身是极简的，仅仅提供了web开发的基础功能，但是它通过中间件的方式集成了许许多多的外部插件来处理HTTP请求。 body-parser：解析HTTP请求体 compression：压缩HTTP响应 cookie-parser：解析cookie 数据 cors：处理跨域资源请求 morgan：HTTP请求日志记录 Express中间件的特性固然强大，但是它所提供的灵活性是一把双刃剑。 它让Express本身变得更加灵活和简单 缺点在于虽然有一些中间件包可以解决几乎所有问题或需求，但是挑选合适的包有时也会成为一个挑战 有很多流行框架基于 Express Express 官网 express 安装 参考文档：http://expressjs.com/en/starter/installing.html 123456789 # 创建并切换到 myapp 目录mkdir myappcd myapp# 初始化 package.json 文件npm init -y# 安装 express 到项目中npm i express Hello World 123456789101112131415// 0. 加载 Expressconst express = require(&quot;express&quot;);// 1. 调用 express() 得到一个 app// 类似于 http.createServer()const app = express();// 2. 设置请求对应的处理函数// 当客户端以 GET 方法请求 / 的时候就会调用第二个参数：请求处理函数app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(&quot;hello world&quot;);&#125;);// 3. 监听端口号，启动 Web 服务app.listen(3000, () =&gt; console.log(&quot;app listening on port 3000!&quot;)); nodejs + express + mysqlmysql 配置 MySQL 安装与配置 12345678下载 https://dev.mysql.com/downloads/installer/ 安装 https://dev.mysql.com/doc/refman/8.0/en/mysql-installer.html https://dev.mysql.com/doc/refman/8.0/en/osx-installation-pkg.html https://dev.mysql.com/doc/refman/8.0/en/linux-installation.html node中使用mysql安装node包(mysql) 1npm install mysql 连接mysql 12345678910111213141516171819202122232425 //新建一个db.js var mysql = require(&quot;mysql&quot;);const db = mysql.createPool(&#123; host: &#x27;localhost&#x27;, // 表示连接某个服务器上的mysql数据库 user: &#x27;root&#x27;, // 数据库的用户名 （默认为root） password: &#x27;100321&#x27;, // 数据库的密码 (默认为rot) database: &#x27;shop&#x27;,// 创建的本地数据库名称&#125;)pool.getConnection(function(err, connection) &#123; // Use the connection connection.query(&quot;SELECT something FROM sometable&quot;, function( error, results, fields ) &#123; // 释放回连接池 connection.release(); // 处理错误 if (error) throw error; // ... &#125;);&#125;); 增12345678910const db = require(&quot;../db&quot;);//链接db.jsconst content = req.body db.query(`insert into user set ?`,content, (err, data) =&gt; &#123; //sql语句 if (err) return console.log(err.message); if (data.affectedRows !== 1) return console.log(&#x27;数据写入失败&#x27;); res.send(&#123; code: 200, msg: &#x27;数据插入成功&#x27;, &#125;) &#125;) 删12345678910const db = require(&quot;../db&quot;)db.query(`delete from user where id = $&#123;req.params.id&#125;`, (err, data) =&gt; &#123; if (err) return console.log(err.message); if (data.affectedRows !== 1) return console.log(&#x27;数据删除失败&#x27;); // 否则写入成功 返回客户端 res.send(&#123; code: 200, msg: &#x27;数据删除成功&#x27;, &#125;) &#125;) 改12345678910const content = req.body const sql = &#x27;update user set ? where id = ?&#x27; db.query(sql,[content, req.params.id], (err, data) =&gt; &#123; if (err) return console.log(err.message); if (data.affectedRows !== 1) return console.log(&#x27;数据修改失败&#x27;); res.send(&#123; code: 200, msg: &#x27;数据修改成功&#x27;, &#125;) &#125;) 查12345678910111213141516171819202122//获取全部 db.query(&#x27;select * from user&#x27;, (err, data) =&gt; &#123; if (err) return console.log(err.message); // 连接失败 if (data.length === 0) return console.log(&#x27;数据为空&#x27;); // 数据长度为0 则没有获取到数据 // 否则获取成功，将结果返回给客户端res.send res.send(&#123; code: 200, msg: &#x27;数据获取成功&#x27;, data:data &#125;) &#125;) //获取单条 db.query(`select * from user where id = $&#123;req.params.id&#125;`, (err, data) =&gt; &#123; if (err) return console.log(err.message); // 连接失败 if (data.length === 0) return console.log(&#x27;数据为空&#x27;); // 数据长度为0 则没有获取到数据 // 否则获取成功，将结果返回给客户端res.send res.send(&#123; code: 200, msg: &#x27;数据获取成功&#x27;, data:data &#125;) &#125;) jwt登录 注册安装 jwt node包1npm i jsonwebtoken 使用jwt utils中新建jwt.js 内容如下 12345678910111213141516171819202122232425262728 const jwt = require(&#x27;jsonwebtoken&#x27;)const jwtKey = &#x27;junkaicool&#x27; // token生成的密匙const jwtSign = (data) =&gt; &#123; // token生成函数，有效时间为一个小时 const token = jwt.sign(data, jwtKey, &#123;expiresIn:60*60&#125;) return token&#125;const jwtCheck = (req, res, next) =&gt; &#123; // token验证函数 const token = req.headers.token jwt.verify(token, jwtKey, (err, data) =&gt; &#123; if (err) &#123; res.send(&#123; code: &#x27;99999999&#x27;, msg: &#x27;token无效&#x27; &#125;) &#125; else &#123; req.jwtInfo = data next() &#125; &#125;)&#125;module.exports = &#123; jwtSign, jwtCheck&#125; login配置 新建login.js 内容如下 12345678910111213141516171819202122232425262728293031const &#123; jwtSign &#125; = require(&quot;../../utils/jwt&quot;);const lodash = require(&quot;lodash&quot;)const db = require(&quot;../db&quot;);login(req,res)&#123; let count = req.body //获取客户端传递的数据 console.log(count.username); db.query(&#x27;select * from user&#x27;, (err, data) =&gt; &#123; if (err) return console.log(err.message); var m = lodash.findIndex(data, count) //查找用户名 密码是否存在 if(count.username == undefined || count.password == undefined)&#123; res.send(&#123; code:&quot;201&quot;, message:&quot;数据为空&quot; &#125;) &#125;else&#123; if (m &gt;= 0) &#123; const token = jwtSign(&#123; _id: data[m].id &#125;) res.send(&#123; code: 200, message: &quot;登陆成功&quot;, token: token &#125;) &#125;else&#123; res.send(&#123; code:201, message:&quot;登陆失败,请检查账户名或密码&quot;, &#125;) &#125; &#125; &#125;) &#125;, 注册 新建register.js 内容如下 123456789101112131415161718192021222324252627register(req,res)&#123; const data = req.body // 获取数据（要配置中间件来解析数据 否则显示undefind） const sql = &#x27;insert into user set ?&#x27; // 构建sql语句 // 执行sql语句 db.query(&#x27;select * from user&#x27;, (err, list) =&gt; &#123; if (err) return console.log(err.message); var m =lodash.findIndex(list, function(o) &#123; return o.username == data.username; &#125;) if (m &gt;= 0) &#123; res.send(&#123; code: 201, message: &quot;该用户已存在&quot; &#125;) &#125; else &#123; db.query(sql, data, (err, data) =&gt; &#123; if (err) return console.log(err.message); // 判断sql是否执行失败 // 判断数据是否插入成功 看affectedRows的值是否为1，不为1则写入失败 if (data.affectedRows !== 1) return console.log(&#x27;数据写入失败&#x27;); // 否则写入成功 返回客户端 res.send(&#123; code: 200, msg: &#x27;添加成功&#x27; &#125;) &#125;) &#125; &#125;) &#125;, nodejs 上传图片 安装 1npm i multer 新建multer.js 内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142 // 1. 引入依赖const multer = require(&#x27;multer&#x27;);// const md5 = require(&#x27;md5&#x27;);// 2. 引入工具const path = require(&#x27;path&#x27;) //const resolve = (dir) =&gt; &#123; return path.join(__dirname, &#x27;./&#x27;, dir)&#125;var fileFormat = &quot;&quot;// 3. multer的配置对象let storage = multer.diskStorage(&#123; // 3.1 存储路径 destination: function (req, file, cb) &#123; // 3.1.1 允许图片上传 if (file.mimetype === &#x27;image/jpeg&#x27; || file.mimetype === &#x27;image/png&#x27;) &#123; cb(null, resolve(&#x27;../public/headers&#x27;)) &#125; else &#123; // 3.1.2 限制其他文件上传类型 cb(&#123; error: &#x27;Mime type not supported&#x27; &#125;) &#125; &#125;, // 3.2 存储名称 filename: function (req, file, cb) &#123; // fileFormat = (file.originalname).split(&quot;.&quot;);//图片名称 fileFormat = file.originalname // cb(null,fileFormat+ &quot;.&quot; + fileFormat[fileFormat.length - 1]); cb(null,fileFormat); &#125;,&#125;);// 4. 添加配置const multerConfig = multer(&#123; storage: storage,&#125;);// 5. 导出配置好的multerConfigmodule.exports =&#123; multerConfig, fileFormat&#125; 获取图片路径 新建upload.js 内容如下 1234567891011121314151617181920212223242526// 1. 引入配置好的multerConfigconst mutlter = require(&#x27;./multer&#x27;);// 2. 定义静态变量const fileName = &quot;photo&quot; // 上传的 fileName 名称const updateBaseUrl = &quot;http://localhost:3099&quot; // 上传到服务器地址const imgPath = &quot;/public/headers/&quot; // 上传到的虚拟目录// 上传接口的 请求参数req 响应参数resfunction upload(req, res) &#123; return new Promise((resolve, reject) =&gt; &#123; mutlter.multerConfig.single(fileName)(req, res, function (err) &#123; if (err) &#123; reject(err) &#125; else &#123; // `req.file.filename` 请求文件名称后缀 // `updateBaseUrl + imgPath + req.file.filename` 完整的服务器虚拟目录 // console.log(updateBaseUrl,imgPath,req.file.filename) resolve(updateBaseUrl + imgPath + req.file.filename) &#125; &#125;); &#125;)&#125;module.exports = upload; 设置请求接口 12345678910111213 router.post(&#x27;/upload&#x27;, (req, res) =&gt; &#123; upload(req, res).then(imgsrc =&gt; &#123; // 上传成功 存储文件路径 到数据库中 // swq sql需要修改一下，变成新增，这里测试暂用更新 res.send(&#123; code:200, message:&quot;上传成功&quot;, imgurl:imgsrc &#125;) &#125;)&#125;) nodejs 设置图片验证码 安装第三方工具 1npm i svg-captcha 新建passport.js 内容如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var svgCaptcha = require(&#x27;svg-captcha&#x27;);var yzm = &quot;&quot;const Verificationcode = &#123; getCaptcha(req,res)&#123; var captcha = svgCaptcha.create(&#123; // 翻转颜色 inverse: false, // 字体大小 fontSize: 36, // 噪声线条数 noise: 2, // 宽度 width: 80, // 高度 height: 30, &#125;); // 保存到session,忽略大小写 req.session = captcha.text.toLowerCase(); yzm =req.session // console.log(req.session); //0xtg 生成的验证码 //保存到cookie 方便前端调用验证 res.cookie(&#x27;captcha&#x27;, req.session); res.setHeader(&#x27;Content-Type&#x27;, &#x27;image/svg+xml&#x27;); res.write(String(captcha.data)); res.end(); &#125;, check(req,res)&#123; // console.log(req.query); if(req.query.yzm == undefined)&#123; res.send(&#123; code:201, message:&quot;验证码为空&quot; &#125;) &#125;else if( yzm == req.query.yzm)&#123; res.send(&#123; code: 200, msg: &quot;正确&quot; &#125;) &#125;else&#123; res.send(&#123; code: 201, msg: &quot;不正确&quot; &#125;) &#125; &#125;&#125; module.exports = Verificationcode 查看更多Express内容","categories":[],"tags":[]},{"title":"Java学习","slug":"Java","date":"2021-10-19T02:46:27.000Z","updated":"2023-03-31T07:12:29.824Z","comments":true,"path":"2021/10/19/Java/","link":"","permalink":"http://example.com/2021/10/19/Java/","excerpt":"","text":"Java介绍 简单地说，Java 是由 Sun Microsystems 公司于 1995 年推出的一门面向对象程序设计语言。2010 年 Oracle 公司收购 Sun Microsystems，之后由 Oracle 公司负责 Java 的维护和版本升级。 其实，Java 还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口为此提供了一个独立于操作系统的标准接口，可分为基本部分和扩展部分。在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。 Java 平台已经嵌入了几乎所有的操作系统。这样 Java 程序只编译一次，就可以在各种系统中运行。Java 应用编程接口已经从 1.1x 版本发展到 1.2 版本。常用的 Java 平台基于 Java 1.6，最新版本为 Java 1.8。 Java 发展至今，就力图使之无所不能。在世界编程语言排行榜中，近年来 Java 一直稳居第一名，比第二名的C语言高出几个百分点。 Java标识符和关键字 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。 变量字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 声明变量 12345678 char usersex=&#x27;女&#x27;; // 直接赋值 ----------------------- String username; // 先声明 username =&quot;琪琪&quot;; // 后赋值-------------------------- String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 成员变量 Java 的成员变量有两种，分别是全局变量和静态变量（类变量）。定义在方法体和语句块之外，不属于任何一个方法，作用域是整个类。 全局变量（实例变量） 无 static 修饰 对象名.变量名 只要对象被当作引用，实例变量就将存在 静态变量（类变量） 用 static 修饰 类名.变量名或对象名.变量名 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 变量声明代码如下所示： 1234567public class DataClass &#123; String name; // 成员变量、实例变量 int age; // 成员变量、实例变量 static final String website = &quot;web周的博客&quot;; // 成员变量、静态变量(类变量) static String URL = &quot;http://www.hetao.asia&quot;; // 成员变量、静态变量(类变量)&#125; 局部变量 局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：方法参数变量（形参）：在整个方法内有效。方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 方法局部变量 1234567891011 public class Test2 &#123; public static void main(String[] args) &#123; int a = 7; if (5 &gt; 3) &#123; int s = 3; // 声明一个 int 类型的局部变量 System.out.println(&quot;s=&quot; + s); System.out.println(&quot;a=&quot; + a); &#125; System.out.println(&quot;a=&quot; + a); &#125;&#125; 方法参数变量 123456789 public class Test3 &#123; public static void testFun(int n) &#123; System.out.println(&quot;n=&quot; + n); &#125; public static void main(String[] args) &#123; testFun(3); &#125;&#125; 代码块局部变量代码块局部变量常用于 try catch 代码块中，成为异常处理参数变量。 异常处理参数变量的作用域是在异常处理块中，该变量是将异常处理参数传递给异常处理块，与方法参数变量类似。 12345678910111213public class Test4 &#123; public static void test() &#123; try &#123; System.out.println(&quot;Hello!Exception!&quot;); &#125; catch (Exception e) &#123; // 异常处理块，参数为 Exception 类型 e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; test(); &#125;&#125; 基本数据类型基本数据类型包括 boolean（布尔型）、float（单精度浮点型）、char（字符型）、byte（字节型）、short（短整型）、int（整型）、long（长整型）和 double （双精度浮点型）共 8 种，详见表 1 所示。 所有的基本数据类型的大小（所占用的字节数）都已明确规定，在各种不同的平台上保持不变，这一特性有助于提高 Java 程序的可移植性。 Java 数据类型的结构如图 1 所示。 基本数据类型又可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char），下面分别介绍这 4 大类数据类型。 整数类型 字节型（byte） byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。短整型（short） short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。整型（int） int 类型是最常使用的一种整数类型。长整型（long） 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 浮点类型浮点类型是带有小数部分的数据类型，也叫实型。浮点型数据包括单精度浮点型（float）和双精度浮点型（double），代表有小数精度要求的数字。 单精度浮点型（float）和双精度浮点型（double）之间的区别主要是所占用的内存大小不同，float 类型占用 4 字节的内存空间，double 类型占用 8 字节的内存空间。双精度类型 double 比单精度类型 float 具有更高的精度和更大的表示范围。 Java 默认的浮点型为 double，例如，11.11 和 1.2345 都是 double 型数值。如果要说明一个 float 类型数值，就需要在其后追加字母 f 或 F，如 11.11f 和 1.2345F 都是 float 类型的常数。 布尔类型布尔类型（boolean）用于对两个数值通过逻辑运算，判断结果是“真”还是“假”。Java 中用保留字 true 和 false 来代表逻辑运算中的“真”和“假”。因此，一个 boolean 类型的变量或表达式只能是取 true 和 false 这两个值中的一个。 在 Java 语言中，布尔类型的值不能转换成任何数据类型，true 常量不等于 1，而 false 常量也不等于 0。这两个值只能赋给声明为 boolean 类型的变量，或者用于布尔运算表达式中。 字符类型Java 语言中的字符类型（char）使用两个字节的 Unicode 编码表示，它支持世界上所有语言，可以使用单引号字符或者整数对 char 型赋值。 一般计算机语言使用 ASCII 编码，用一个字节表示一个字符。ASCII 码是 Unicode 码的一个子集，用 Unicode 表示 ASCII 码时，其高字节为 0，它是其前 255 个字符。 Unicode 字符通常用十六进制表示。例如“\\u0000”~“\\u00ff”表示 ASCII 码集。“\\u”表示转义字符，它用来表示其后 4 个十六进制数字是 Unicode 码。 引用数据类型引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型引用类型还有一种特殊的 null 类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针，只是 Java 语言里不再使用指针这个说法。 空类型（null type）就是 null 值的类型，这种类型没有名称。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。 空引用（null）是 null 类型变量唯一的值。空引用（null）可以转换为任何引用类型。 在实际开发中，程序员可以忽略 null 类型，假定 null 只是引用类型的一个特殊直接量。 注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。 数据类型转换隐式转换（自动类型转换） 当以上 2 个条件都满足时，拓宽转换（widening conversion）发生。例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。 在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下：数值型数据的转换：byte→short→int→long→float→double。字符型转换为整型：char→int。 以上数据类型的转换遵循从左到右的转换顺序，最终转换成表达式中表示范围最大的变量的数据类型。 显式转换（强制类型转换）这种转换不会自动进行，因为 double 型的变化范围比 int 型的要小。这种转换有使成为“缩小转换”，因为你肯定要将源数据类型的值变小才能适合目标数据类型。 所以当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换","categories":[],"tags":[]},{"title":"React","slug":"React","date":"2021-10-19T02:46:27.000Z","updated":"2023-03-31T07:13:08.700Z","comments":true,"path":"2021/10/19/React/","link":"","permalink":"http://example.com/2021/10/19/React/","excerpt":"","text":"学习React 什么是React?用于构建用户界面的JS库react只关注视图（也就是页面）AIA：是一个将数据渲染为HTML视图的开源JS库,感觉像是程序员和DOM之间的代理 步骤 发送请求获取数据 处理数据(过滤、整理格式) 操作DOM呈现页面 谁开发的？由Facebook开发，且开源软件工程师Jorda Walke创建 为什么用react 原生js操作DOM繁琐、效率低 使用JS直接操作DOM， 浏览器会进行大量的重绘重排 原生没有组件化编码方案，代码复用率低 React特点 采用组件化模式、声明式编码，提高开发效率及组件复用率 在React Native中可以使用React语法进行移动端开发 使用虚拟DOM+Diffing算法，减少与真实DOM交互 依赖包 babel.min.js (es6-&gt;es5 jsx-&gt;js) react.development.js(react核心库) react-dom.development(react扩展库) 虚拟DOM虚拟DOM的两种创建方式 使用jsx创建虚拟虚拟DOM 格式引入react核心库引入react-dom,用于支持react操作DOM引入babel 1234567891011&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;// 表示里面写jsx// 1. 创建虚拟DOMconst VDOM = &lt;h1&gt;Hello React&lt;/h1&gt; // 此处不要写引号 因为不是字符串const TDOM = document.getElementById(&#x27;demo&#x27;)// 2. 渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&quot;test&quot;))&lt;/script&gt; 使用js创建虚拟DOM 格式引入react核心库引入react-dom,用于支持react操作DOM 123456789101112&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 表示里面写jsx// 1. 创建虚拟DOMconst VDOM = React.createlement(标签名,标签属性,标签内容)const VDOM = React.createlement(&#x27;h1&#x27;,&#123;id:&#x27;title&#x27;&#125;,&#x27;Hello React&#x27;)const TDOM = document.getElementById(&#x27;demo&#x27;)// 2. 渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&quot;test&quot;))&lt;/script&gt; 关于虚拟DOM console.log(VDOM instanceof Object) 本质是 Object 类型的对象 虚拟DOM比较”轻”，属性少。因为虚拟DOM是react内部在用，无需真实DOM那么多的属性 123console.log(&#x27;虚拟DOM&#x27;,VDOM)console.log(&#x27;真实DOM&#x27;,TDOM) // 输出&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;，没法看属性debugger // 借助断点来看有多少属性 虚拟DOM最终会被React转化为真实DOM，呈现在页面上 JSX简介全称:javascript XML是一个 JavaScript 的语法扩展。在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。 为什么使用JSX？React 认为渲染逻辑本质上与其他UI逻辑内在耦合，比如上述例子若是在h1标签中再加一个span标签： 123456789// jsx:const VDOM = ( &lt;h1 id=&quot;title&quot;&gt; &lt;span&gt;Hello React&lt;/span&gt; &lt;/h1&gt;)// js:const VDOM = React.createlement(&#x27;h1&#x27;,&#123;id:&#x27;title&#x27;&#125;,React.createElement(&#x27;span&#x27;,&#123;&#125;,&#x27;Hello React&#x27;)) BTW——XML早期用于存储和传输数据 1234567&lt;student&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;19&lt;/age&gt;&lt;/student&gt;&lt;!-- 用json存储 json&#123;&#125;存储对象 js对象存储为json字符串--&gt;&#123;&quot;name&quot;:&#x27;Tom&#x27;,&quot;age&quot;:19&#125; BTW——json parse方法 stringify方法 jsx语法规则 定义虚拟DOM时不要写引号 标签中混入js表达式时用{}，myId，myData[注意]区分js表达式 和 js语句（代码） 表达式一定会产生一个值，可以放在任何一个需要值的地方下面这些都是表达式 : .a, .a+b .demo(1) arr.map(() &#x3D;&gt; {return}) function test() {} 语句(代码)下面这些都是语句(代码) .if() .for() .switch() {case:xxx} 样式的类名指定不要用class，要用className 内联样式要用,style&#x3D;两个大括号，里面写key:value的形式 去写比如两个大括号，中间写color:’white’ 虚拟DOM，只有一个根标签 在这个例子中所有东西都放h2里 标签必须闭合 标签首字母 （1）若小写字母开头，则将该标签转为html同名元素，若html中无该标签对应同名元素，则报错 （2）若大写字母开头，react就去渲染对应组件，若组件没有定义，则报错 12345678910111213141516171819&lt;style&gt; .title &#123; background:skyblue; &#125;&lt;/style&gt;&lt;script type=&quot;text/babel&quot;&gt; const myId = &#x27;ALin&#x27; const myData = &#x27;suibian&#x27; // 1. 创建虚拟DOM const VDOM = ( &lt;h1 id=&#123;myId.toLowerCase()&#125; className=&#x27;title&#x27;&gt; &lt;span&gt;&#123;myData.toLowerCase()&#125;&lt;/span&gt; &lt;/h1&gt; ) // 2. 渲染虚拟DOM ReactDOM.render(VDOM,document.getElementById(&#x27;test&#x27;))&lt;/script&gt; 例子：渲染数据 1234567891011121314151617&lt;script type=&quot;text/babel&quot;&gt;const data = [&#x27;Angular&#x27;,&#x27;React&#x27;,&#x27;Vue&#x27;]// 1.创建虚拟DOMconst VDOM = ( &lt;div&gt; &lt;h1&gt;前端js框架列表&lt;/h1&gt; &lt;ul&gt; &#123; data.map((item,index) =&gt;&#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; // 这样写少了key值，可以暂时用index来代替，但最好还是用id，因为index会变化 &#125;) &#125; &lt;/ul&gt; &lt;/div&gt;)&lt;/script&gt; 模块与组件、模块化与组件化的理解模块 向外提供特定的js程序，一般就是一个js文件 为什么要拆成模块？随着业务逻辑增加，代码越来越多越来越复杂 作用：复用js，提高js运行效率 组件 用来实现局部功能效果的代码和资源集合(html&#x2F;css&#x2F;image&#x2F;js) 为什么要拆成组件？一个界面功能更复杂 作用：复用代码，简化项目编码，提高运行效率 模块化当应用的js都以模块来编写的，这个应用就是一个模块化应用 组件化当应用是以多组件的方式实现，这个应用就是一个组件化的应用 react面向组件编程两种定义组件方式 函数式组件 12345678910111213141516171819&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt;// 1. 创建组函数式件function Demo() &#123; console.log(this) // 结果为undefined 因为函数要经过babel翻译，翻译后开启严格模式，禁止自定义函数里的this指向window return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;/h2&gt;&#125;// 2. 渲染组件到页面// ReactDOM.render(demo,document.getElementById(&#x27;test&#x27;)) 这样写会报错，不能直接写demoReactDOM.render(&lt;Demo/&gt;,document.getElementById(&#x27;test&#x27;)) 这样写会报错，不能直接写demo// D 大写因为是组件，闭合标签，以标签形式写出/*执行了ReactDOM.render(&lt;Demo/&gt;）......之后发生了什么？ 1. react 解析组件标签，找到Demo组件 2. 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实的DOM，随后呈现在页面中 */&lt;/script&gt; 类式组件 回顾一下es61234567891011121314151617181920212223242526272829303132333435363738394041424344// 创建一个Person类class Person &#123; // 接收new 传递过来的参数，用构造器方法 constructotr(name,age) &#123; // 构造器中的this指什么？类的实例对象 this.name = name this.age = age &#125; // 除了构造器方法，还有一般方法 speak() &#123; speak方法放在哪里了？ 类的原型对象上 speak方法给谁用的？给实例用 speak中this是谁？p1/p2 通过Person实例调用speak时，speak中的this就是Person实例 console.log(`我叫$&#123;this.name&#125;,我年龄是$&#123;this.age&#125;`) &#125;&#125;// 用类创建一个Person实例对象const p1 = new Person(&#x27;tom&#x27;,19)const p2 = new Person(&#x27;jerry&#x27;,17)console.log(p1)console.log(p2)p1.spaek()p2.speak()// 创建一个Student类，继承于Person类class Student extends Person &#123; constructor(name,age,grade) &#123; // 自己写构造器，有想添加的东西在这儿写 // 必须使用super,且在最前面 super(name,age) this.grade = grade &#125; // 重写从父类继承过来的方法 speak() &#123; console.log(`我叫$&#123;this.name&#125;,我年龄是$&#123;this.age&#125;,我是$&#123;this.grade&#125;年级`) &#125; study() &#123; // study方法放在哪儿？ 类的原型上，供实例使用 // 通过Student实例调用study时候,study中的this就是Student的实例 console.log(&#x27;我很努力的学习&#x27;) &#125;&#125;const s1 = new Student(&#x27;小张&#x27;,15,&#x27;高一&#x27;) // 若想再添加一个年级，但是继承的Person中没有console.log(s1)// 静态方法就是构造函数本身属性，不在类的原型对象上，所以实例无法调用 【AIA】 类中的构造器不是必须写，要对实例进行一些初始化操作，如指定添加属性时才写（比如grade） 如果A类继承B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的 类中所定义的方法，都是放在类的原型对象上，供实例使用 创建类式组件12345678910111213141516171819&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class MyComponent extends React.Component &#123; render() &#123; // render是放在哪里的？ 类（MyComponent）的原型对象上，供实例使用 // render中的this是谁？MyComponent的组件实例对象 return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;/h2&gt; &#125; &#125; // 2. 渲染组件到页面 ReactDOM.render(&lt;MyComponent/&gt;,document.getELementById(&#x27;test&#x27;)) /* 执行了ReactDOM.render(&lt;MyComponent/&gt;）......之后发生了什么？ 1. react 解析组件标签，找到MyComponent组件 2. 发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法 3. 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中 */&lt;/script&gt; 组件三大属性第一————组件的状态 像es6一样，我需要用到实例中的state，但天默认是空值,就是空对象。需要自己添加，所以用到constructor和super 123456789101112131415161718192021222324&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Weather extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123;isHot:true&#125; // 初始化状态 &#125; render() &#123; // 读取状态 const &#123;isHot&#125; = this.state // return &lt;h1&gt;今天天气&#123;this.state.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！&lt;/h1&gt; 有const声明就不需要写的那么麻烦了 return &lt;h1&gt;今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！&lt;/h1&gt; &#125; &#125; // 2. 渲染组件到页面 ReactDOM.render(&lt;Weather/&gt;,document.getELementById(&#x27;test&#x27;)) /* 执行了ReactDOM.render(&lt;MyComponent/&gt;）......之后发生了什么？ 1. react 解析组件标签，找到MyComponent组件 2. 发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法 3. 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中 */&lt;/script&gt; 事件绑定 回顾一下原生事件绑定12345678910111213141516171819202122&lt;button&gt;btn1&lt;/button&gt;&lt;button&gt;btn2&lt;/button&gt;&lt;button onclick=&quot;demo()&quot;&gt;btn3&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 方法一 const btn1 = document.getElementById(&#x27;btn1&#x27;) btn1.addEventListener(&#x27;click&#x27;,() =&gt; &#123; alert(&#x27;按钮1被点击了&#x27;) &#125;) // 方法二 const btn2 = document.getElementById(&#x27;btn2&#x27;) btn2.onclick = (() =&gt; &#123; alert(&#x27;按钮1被点击了&#x27;) &#125;) // 方法三 function demo() &#123; alert(&#x27;按钮3被点击了&#x27;) &#125;&lt;/script&gt; react事件绑定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; let that // 1. 创建类式组件 class Weather extends React.Component &#123; constructor(props) &#123; super(props) this.state=&#123;isHot:true&#125; // 初始化状态 that = this // 声明一个that，让下面的也可以用这个this // 解决this指向undefined问题 this.changeWeather = this.changeWeather.bind(this) // bind返回一个新函数，手动执行；新函数里的this变为Weather的实例对象，然后把函数放在实例自身，给函数起了个名字叫changeWeather，因此实例对象自身Weather，就多了一个方法叫changeWeather &#125; render() &#123; // 读取状态 const &#123;isHot&#125; = this.state // return &lt;h1&gt;今天天气&#123;this.state.isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！&lt;/h1&gt; 有const声明就不需要写的那么麻烦了 // return &lt;h1 id=&quot;title&quot;&gt;今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！&lt;/h1&gt; // return &lt;h1 onClick=&#123;demo()&#125; &gt;今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！&lt;/h1&gt; //直接在里面写onclick,demo不能用字符串形式，demo用函数的形式写出 return &lt;h1 onClick=&#123;this.changeWeather&#125; &gt;今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！&lt;/h1&gt; // 但是加了括号表示立即执行，所以要去掉 // 所以这个的onClick=&#123;this.changeWeather&#125;调用的是自身的changeWeather，不会去找原型上的changeWeather &#125; changeWeather() &#123; // changeWeather放在哪儿？放在weather的原型对象上，供实例使用 // 通过weather实例调用changeWeather时，changeWeather中的this就是Weather的实例 // 所以不需要that console.log(this.state.isHot) // 发现this，undefined，为什么this会丢失? 举一个原生例子 看下一个js // 所以这里相当于直接调用，changeWeather是作为onClick的回调，不是通过实例调用又因为类中方法默认开启局部的严格模式 &#125; &#125; // 2. 渲染组件到页面 ReactDOM.render(&lt;render/&gt;,document.getELementById(&#x27;test&#x27;)) const title = document.getElementById(&#x27;title&#x27;) /* 第一种 不建议要先document.getElementById(&#x27;title&#x27;)*/ title.addEventListener(&quot;click&quot;,() =&gt; &#123; console.log(&#x27;标题被点击&#x27;) &#125;) /*第二种 不建议要先document.getElementById(&#x27;title&#x27;)*/ title.onclick = () =&gt; &#123; console.log(&#x27;标题被点击&#x27;) &#125; /*第三种 */ function changeWeather() &#123; // 又需要将这个定义在类中 // 此处修改isHot的值 const &#123;isHot&#125; = this.state console.log(isHot) // 这样会报错，因为state undefined，demo函数不在weather类中，根本没有关系的两个东西 // 所以 console.log(that.state.isHot) &#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728class Person &#123; constructor(name,age) &#123; this.name = name this.age = age &#125; study() &#123; // study方法放在原型对象上，供实例对象使用 // 通过Person实例调用study时，study中的this就是Person实例 console.log(this) &#125;&#125;const p1 = new Person(&#x27;tom&#x27;,19)p1.study() // 通过实例调用study对象const x = p1.studyx() /* 这个时候study中的this打印为undefined，因为这个属于直接调用，上面p1.study() 是实例调用； 类中的定义的方法，全部局部自动开启严格模式 比如: function demo() &#123; console.log(this) // window &#125; demo() function demo() &#123; &#x27;use strict&#x27; console.log(this) // undefined &#125; demo*/ setState 应用 123456789101112131415161718192021222324252627282930313233343536373839 &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Weather extends React.Component &#123; // 构造器调用几次————1 次 console.log(constructor) constructor(props) &#123; super(props) // 初始化状态 this.state=&#123;isHot:true,wind:&#x27;微风&#x27;&#125; // 解决this指向undefined问题 this.changeWeather = this.changeWeather.bind(this) // bind返回一个新函数，手动执行；新函数里的this变为Weather的实例对象，然后把函数放在实例自身，给函数起了个名字叫changeWeather，因此实例对象自身Weather，就多了一个方法叫changeWeather &#125; // render 调用几次———— 1+n次 1是初始化那次，n是状态更新的次数 console.log(render) render() &#123; // 读取状态 const &#123;isHot&#125; = this.state return &lt;h1 onClick=&#123;this.changeWeather&#125; &gt;今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！,&#123;wind&#125;&lt;/h1&gt; // 但是加了括号表示立即执行，所以要去掉 // 所以这个的onClick=&#123;this.changeWeather&#125;调用的是自身的changeWeather，不会去找原型上的changeWeather &#125; // changeWeather 调用几次———— 点几次调用几次 console.log(render) changeWeather() &#123; // 获取原来的isHot值 const isHot = this.state.isHot // 严重注意状态必须通过setState进行更新,且合并（更改isHot,后面的wind不会变） this.setState(&#123;isHot:!isHot&#125;) // 严重注意，状态不可直接更改，要借助内置API直接更改 // this.state.isHot = !isHot console.log(this.state.isHot) // 这样两行改了，控制台点击true，false进行切换，但是react不认可，是单向数据流 &#125; &#125; // 2. 渲染组件到页面 ReactDOM.render(&lt;Weather/&gt;,document.getELementById(&#x27;test&#x27;))&lt;/script&gt; 上述代码精简方式类中可以直接写赋值语句不需要let什么的声明，直接a&#x3D;1所以 123456789101112131415161718192021222324252627282930313233 &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Weather extends React.Component &#123; // 可以不写构造器 // 想给Weather实例对象身上都添加一个state属性，那就拿出来直接赋值 state=&#123;isHot:true,wind:&#x27;微风&#x27;&#125; // 初始化状态 // 下面这行代码，可以把changeWeather变成赋值语句 // this.changeWeather = this.changeWeather.bind(this) // changeWeather = function()&#123; // // 这样changeWeather就放实例自身上了，但是这样仅仅只是换了个地方，之前在原型对象，现在在实例自身，所以换成箭头函数 // const isHot = this.state.isHot // this.setState(&#123;isHot:!isHot&#125;) // &#125; render() &#123; // 读取状态 const &#123;isHot&#125; = this.state return &lt;h1 onClick=&#123;this.changeWeather&#125; &gt;今天天气&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;！,&#123;wind&#125;&lt;/h1&gt; // 但是加了括号表示立即执行，所以要去掉 // 所以这个的onClick=&#123;this.changeWeather&#125;调用的是自身的changeWeather，不会去找原型上的changeWeather &#125; // 自定义方法（赋值语句+箭头函数） changeWeather = () =&gt; &#123; // 箭头函数没有自己的this，找外层函数的this const isHot = this.state.isHot this.setState(&#123;isHot:!isHot&#125;) console.log(this) // Weather的实例对象 &#125; &#125; // 2. 渲染组件到页面 ReactDOM.render(&lt;Weather/&gt;,document.getELementById(&#x27;test&#x27;))&lt;/script&gt; 【AIA】 state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合） 组件被称为“状态机”，像生活中的红绿灯，通过更新组件的state来更新对应的页面显示（重新渲染组件）[注意] 组件中render方法中的this为组件的实例对象 组件自定义方法中的this都是undefined，如何解决？a. 强制绑定this:通过函数对象的bind()b. 箭头函数 状态数据不能直接修改或更新 组件的第二个属性————props类里面的this指向组件的实例对象，里面有一个props空对象 12345678910111213141516171819202122232425262728293031 &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Person extends React.Component &#123; render() &#123; const &#123;name,age,sex&#125; = this.props return ( // &lt;ul&gt; // &lt;li&gt;姓名:&#123;this.props.name&#125;&lt;/li&gt; // &lt;li&gt;性别:&#123;this.props.sex&#125;&lt;/li&gt; // &lt;li&gt;年龄:&#123;this.props.age&#125;&lt;/li&gt; // &lt;/ul&gt; // 上面声明后可不需要写this.props &lt;ul&gt; &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别:&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄:&#123;age&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125; &#125; // 2. 渲染组件到页面 ReactDOM.render(&lt;Person name=&quot;tom&quot; sex=&quot;男&quot; age=&quot;18&quot; /&gt;,document.getELementById(&#x27;test&#x27;)) // 直接以key=&quot;valuw&quot;形式放上去，可以接收多个 // 但是上述写法太麻烦了，所以 const p = &#123;name=&quot;tom&quot; sex=&quot;男&quot; age=&quot;18&quot;&#125; ReactDOM.render(&lt;Person name=&#123;p.name&#125; sex=&#123;p.sex&#125; age=&#123;p.age&#125; /&gt;,document.getELementById(&#x27;test&#x27;)) // 这样还是太麻烦 ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getELementById(&#x27;test&#x27;)) console.log(...p) // 报错，仅仅适用于标签属性的传递，别的地方都不行&lt;/script&gt; 回顾一下扩展运算符123456789101112131415161718192021222324252627282930313233343536let arr1 = [1,2,3,4,5]let arr2 = [2,4,6,8,10]console.log(...arr1) // 1,2,3,4,5console.log(arr1) // [1,2,3,4,5]// 连接数组let arr3 = [...arr1,...arr2]console.log(arr3) // [1,2,3,4,5,2,4,6,8,10]function sum(a+b) &#123; return a+b&#125;console.log(sum(1,2))// 若有很多数字或者数字不固定function sum(...numbers) &#123; console.log(numbers) // [1,2] 是个数组，...可以批量都接收到 return numbers.reduce((preValue,currentValue) =&gt; &#123; // 函数体 return preValue + currentValue // 结果为3，1+2 &#125;)&#125;console.log(sum(1,2)) // 原生中与react不同，react中babel和引入的react，可以直接用根本没有触发什么赋值对象 // 构造字面量对象时使用展开语法let person = &#123;name:&#x27;tom&#x27;,age:&#x27;18&#x27;&#125;console.log(...person) // Found non-callable @@iterator at 展开运算符 意思是 对象类型没有接口 就是说展开运算符不能展开一个对象// 但如果let person = &#123;name:&#x27;tom&#x27;,age:&#x27;18&#x27;&#125;let person2 = &#123;...person&#125; // 表示赋值一个对象person.name = &#x27;jerry&#x27;console.log(person2) // &#123;name:&#x27;tom&#x27;,age:&#x27;18&#x27;&#125;console.log(person) // &#123;name:&#x27;jerry&#x27;,age:&#x27;18&#x27;&#125; // 合并let person3 = &#123;...person,name:&#x27;jack&#x27;,address:&#x27;地球&#x27;&#125;console.log(person3) // &#123;name:&#x27;jerry&#x27;,age:&#x27;18&#x27;,address:&#x27;地球&#x27;&#125; props有一些限制12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Person extends React.Component &#123; render() &#123; const &#123;name,age,sex&#125; = this.props // this.props.name = &#x27;jack&#x27; 此行代码会报错，因为props是只读的 return ( &lt;ul&gt; &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别:&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125; &#125; // 对标签属性进行类型、必要性的限制 Person.propsTypes = &#123; // props属性 // name:&#x27;必传，字符串&#x27; // name:React.propTypes.string // React.propTypes 这是react内置对象，react15用，但react16被弃用了 // 所以引入依赖包prop-types .js ,引入后多了一个对象PropType name:PropTypes.string.isRequired, // 加了isRequired表示名字必须传 sex:PropTypes.string, // 限制性别为字符串 age:PropTypes.number, // 限制年龄为数值 speak:PropTypes.func // 不能写function，会报错必须是一个function但得到了undefined，所以写func,function是个关键字 &#125; // 指定默认标签属性 Person.defaultProps = &#123; sex:&#x27;男&#x27;, // sex默认值为男 age:18 // 年龄默认值为18 &#125; // 2. 渲染组件到页面 // 需求希望年龄+1, 又不改真实年龄结果变成年龄：191，需要改变基本数据类型，把字符串变成number // ReactDOM.render(&lt;Person name=&quot;tom&quot; sex=&quot;男&quot; age=&quot;18&quot; /&gt;,document.getELementById(&#x27;test&#x27;)) // 直接以key=&quot;valuw&quot;形式放上去，可以接收多个 // 变为 ReactDOM.render(&lt;Person name=&quot;tom&quot; sex=&quot;男&quot; age=&#123;18&#125; speak=&#123;speak&#125;/&gt;,document.getELementById(&#x27;test&#x27;)) function speak() &#123; console.log(&#x27;我在讲话&#x27;) &#125;&lt;/script&gt; 姓名必须指定，且为字符串类型 性别为字符串类型，如果性别没有指定，默认为男 年龄为字符串类型，且为数字类型，默认值为18 props的简写方式1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Person extends React.Component &#123; static propsTypes = &#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &#125; // 指定默认标签属性 static defaultProps = &#123; sex:&#x27;男&#x27;, // sex默认值为男 age:18 // 年龄默认值为18 &#125; render() &#123; const &#123;name,age,sex&#125; = this.props // this.props.name = &#x27;jack&#x27; 此行代码会报错，因为props是只读的 return ( &lt;ul&gt; &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别:&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125; &#125; // 对标签属性进行类型、必要性的限制 // 2. 渲染组件到页面 // 需求希望年龄+1, 又不改真实年龄结果变成年龄：191，需要改变基本数据类型，把字符串变成number // ReactDOM.render(&lt;Person name=&quot;tom&quot; sex=&quot;男&quot; age=&quot;18&quot; /&gt;,document.getELementById(&#x27;test&#x27;)) // 直接以key=&quot;valuw&quot;形式放上去，可以接收多个 // 变为 ReactDOM.render(&lt;Person name=&quot;tom&quot; sex=&quot;男&quot; age=&#123;18&#125; speak=&#123;speak&#125;/&gt;,document.getELementById(&#x27;test&#x27;)) function speak() &#123; console.log(&#x27;我在讲话&#x27;) &#125; &lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; constructor(props) &#123; super(props) // 这个不用super接props也可以获取到，加了super与不加的区别在于this.props console.log(this.props) // 打印实例自身的props，可以拿到；若没有super，undefined // 总结：若不省略构造器，构造器是否接受props，是否传递给super，取决于：是否希望在构造器中通过this访问props &#125; // 1. 创建类式组件 class Person extends React.Component &#123; static propsTypes = &#123; name:PropTypes.string.isRequired, sex:PropTypes.string, age:PropTypes.number, speak:PropTypes.func &#125; // 指定默认标签属性 static defaultProps = &#123; sex:&#x27;男&#x27;, // sex默认值为男 age:18 // 年龄默认值为18 &#125; render() &#123; const &#123;name,age,sex&#125; = this.props // this.props.name = &#x27;jack&#x27; 此行代码会报错，因为props是只读的 return ( &lt;ul&gt; &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别:&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄:&#123;age + 1&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125; &#125; ReactDOM.render(&lt;Person name=&quot;tom&quot;/&gt;,document.getELementById(&#x27;test&#x27;)) &lt;/script&gt; 函数组件使用props123456789101112131415161718192021222324252627&lt;div id=&quot;test&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/babel&quot;&gt; function Person() &#123; const &#123;name,age,sex&#125; = props return ( &lt;ul&gt; &lt;li&gt;姓名:&#123;name&#125;&lt;/li&gt; &lt;li&gt;性别:&#123;sex&#125;&lt;/li&gt; &lt;li&gt;年龄:&#123;age&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125; // 限制写在外面，它不像类式组件有static属性 // 对标签属性进行类型、必要性的限制 Person.propsTypes = &#123; // props属性 name:PropTypes.string.isRequired, // 加了isRequired表示名字必须传 sex:PropTypes.string, // 限制性别为字符串 age:PropTypes.number // 限制年龄为数值 &#125; // 指定默认标签属性 Person.defaultProps = &#123; sex:&#x27;男&#x27;, // sex默认值为男 age:18 // 年龄默认值为18 &#125; // 渲染到组件页面 ReactDOM.render(&lt;Person name=&quot;jerry&quot; sex=&quot;男&quot; age=&#123;18&#125;/&gt;,document.getElementById(&#x27;test&#x27;))&lt;/script&gt; 组件的第三个属性————ref ref字符串形式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Demo extends React.Component &#123; // 展示左侧输入框数据——字符串方法 showData = () =&gt; &#123; // 不需要写的这么麻烦 // const input = document.getElementById(&#x27;input1&#x27;) // alert(input.value) console.log(this.refs.input1) // 这个是真实DOM了，所以可以 const &#123;input1&#125; = this.refs alert(input1.value) &#125; showData2 = () =&gt; &#123; const &#123;input2&#125; = this.refs alert(input2.value) &#125; // ref回调方法 // 展示左侧输入框数据 showData = () =&gt; &#123; // 不需要写的这么麻烦 // const input = document.getElementById(&#x27;input1&#x27;) // alert(input.value) console.log(this.refs.input1) // 这个是真实DOM了，所以可以 const &#123;input1&#125; = this alert(input1.value) &#125; showData2 = () =&gt; &#123; const &#123;input2&#125; = this alert(input2.value) &#125; render() &#123; return ( // 字符串类型的ref不太推荐，存在效率问题，写多了效率不高 // &lt;div&gt; // &#123;/* &lt;input type=&quot;text&quot; id=&quot;input1&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt; 可以不用写id，换成ref */&#125; // &lt;input type=&quot;text&quot; ref=&quot;input1&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt; // &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧数据&lt;/button&gt; // &lt;input type=&quot;text&quot; onBlur=&#123;this.showData2&#125; ref=&quot;input2&quot; placeholder=&quot;诗句焦点提示数据&quot;/&gt; // &#123;/* 只要写ref,就会放到Demo实例对象refs中 */&#125; // &lt;/div&gt; &lt;div&gt; &#123;/* &lt;input type=&quot;text&quot; ref=&#123;(a)=&gt; &#123;console.log(a)&#125; &#125;placeholder=&quot;点击按钮提示数据&quot;/&gt; */&#125; &#123;/* 这个a,打印出来后是 &lt;input type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt; ref属性当前所在的节点 */&#125; &#123;/* &lt;input type=&quot;text&quot; ref=&#123;(a)=&gt; &#123;this.input1 = a&#125; &#125;placeholder=&quot;点击按钮提示数据&quot;/&gt; */&#125; &#123;/* 把a这个节点放在组件实例自身上 */&#125; &lt;input type=&quot;text&quot; ref=&#123;currentNode =&gt; this.input1 = currentNode &#125;placeholder=&quot;点击按钮提示数据&quot;/&gt; &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧数据&lt;/button&gt; &lt;input type=&quot;text&quot; onBlur=&#123;this.showData2&#125; ref=&#123;c =&gt; this.input2 = c&#125; placeholder=&quot;失去焦点提示数据&quot;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Demo/&gt;,document.getELementById(&#x27;test&#x27;)) &lt;/script&gt; 回调ref中执行次数问题，回调函数形式 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Demo extends React.Component &#123; showInfo = () =&gt; &#123; const &#123;input1&#125; = this alert(input1.value) &#125; changeWeather = () =&gt; &#123; // 获取原来的状态 state = &#123;isHot:true&#125; // 更新状态 this.setState(&#123;isHot:!isHot&#125;) &#125; saveInput = (c) =&gt; &#123; this.input1 = c console.log(&#x27;@&#x27;,c) &#125; render() &#123; const &#123;isHot&#125; = this.state return ( &lt;div&gt; &lt;h2&gt;今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;&lt;/h2&gt; &#123;/* &lt;input ref=&#123;c =&gt; this.input1 = c;console.log(&#x27;@&#x27;,c)&#125;/&gt; */&#125; &#123;/* 解决第一次传入参数null，第二次会传入参数DOM元素 通过ref回调函数定义成class的绑定函数方式*/&#125; &lt;input ref=&#123;this.saveInput&#125; type=&quot;text&quot;/&gt; &lt;button onClick=&#123;this.showInfo&#125;&gt;点我提示输入的数据&lt;/button&gt; &lt;button onClick=&#123;this.changeWeather&#125;&gt;点我切换天气&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; /* 如果ref回调函数是以内联函数的方式定义的，在更新的过程中会被执行两次，第一次传入参数null，第二次会传入参数DOM元素 这是因为在每次渲染时会创建一个新的函数实例，所以react清空旧的ref并且设置新的 通过ref回调函数定义成class的绑定函数的方式可以避免上述问题 */ ReactDOM.render(&lt;Demo/&gt;,document.getELementById(&#x27;test&#x27;)) &lt;/script&gt; createRef形式 1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; // 1. 创建类式组件 class Demo extends React.Component &#123; /* React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点，但是该容器是专人专用 */ myRef = React.createRef() myRef2 = React.createRef() // 展示左侧输入框数据 showData = () =&gt; &#123; console.log(this.myRef) // &#123;currrent:input&#125; console.log(this.myRef.current) // 拿的是这个input节点 &lt;input type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt; console.log(this.myRef.current.value) // input框输入什么，这里显示什么 &#125; // 展示右侧输入框数据 showData2 = () =&gt; &#123; console.log(this.myRef2.current.value) // input框输入什么，这里显示什么 &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;this.myRef&#125; type=&quot;text&quot; placeholder=&quot;点击按钮提示数据&quot;/&gt; &#123;/* input被存在this.myRef中 */&#125; &lt;button onClick=&#123;this.showData&#125;&gt;点我提示左侧的数据&lt;/button&gt; &lt;input ref=&#123;this.myRef2&#125; type=&quot;text&quot; onBlur=&#123;this.showData2&#125; placeholder=&quot;点击按钮提示数据&quot;/&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Demo/&gt;,document.getELementById(&#x27;test&#x27;)) &lt;/script&gt; react中的事件处理 通过onXXX属性指定事件处理函数（注意大小写） react使用的是自定义（合成）事件，而不是使用的原生DOM事件————为了更好的兼容 react中事件是通过事件委托方式处理的（委托给组件最外层元素）————为了高效 通过event.target得到发生事件的DOM元素（不要过度使用Refs,可以用这个代替） 1234567showData = () =&gt; &#123; console.log(this.myRef2.current.value) &#125;showData = (event) =&gt; &#123; console.log(event.target.value) &#125;// 但像myref,在上述代码input中无法省略，因为这个 受控组件，非受控组件 非受控组件通过手动操作dom方式获取文本框的值，文本框状态不受react组件的state中状态控制，直接通过原生dom获取输入框的值 实现步骤： 导入createRef函数 调用createRef函数，创建一个ref对象，存储到名为msgRef的实例属性中 为input添加ref属性，只为msgRef 在按钮的事件处理程序中，通过msgRef.current即可拿到input对应的dom元素，而其中msg.current.value拿到的就是文本框的值 1234567891011121314151617import React,&#123;createRef&#125; from &quot;react&quot;class Input extends React.Component &#123; // 这个实例属性可以自定义 msgRef = createyRef() getValue=() =&gt; &#123; // 通过msgRef获取input value值 console.log(this.msgRef.current.value) &#125; render() &#123; return ( &lt;&gt; &lt;input type=&quot;text&quot; ref=&#123;this.msgRef&#125;/&gt; &lt;button onClick=&#123;this.getValue&#125;&gt;点击获取输入框的值&lt;/button&gt; &lt;/&gt; ) &#125;&#125; 这并不是react特有的行为，这其实与javascript函数工作原理有关。通常情况下，如果你没有在方法后面添加(),例如onClick&#x3D;{this.handleClick},你应为这个方法绑定this 受控组件input框自己的状态被react组件控制受控组件就是说可以被react动态控制的组件 实现步骤： 在组件的state中声明一个组件的状态数据 将状态数据设置为input标签元素的value属性的值 为input添加onchange事件 在事件处理程序中，通过事件对象e获取到当前文本框的值（即用户当前输入的值） 调用setState方法，将文本框的值作为state状态的最新值 123456789101112131415161718192021class Counter extends React.Component &#123; // 1. 声明一个用来控制input value属性的react组件自己的状态 state = &#123; message:&#x27;this is a message&#x27; &#125; // 回调函数 inputChange = (e) =&gt; &#123; console.log(&#x27;change事件触发了&#x27;,e) // 4. 需要在这里拿到输入框最新的值 交给state中的message this.setState(&#123; message:e.target.value &#125;) &#125; render() &#123; return ( // 2. 给input框的value属性绑定 react state // 3. 给input框绑定一个change事件 为了拿到当前输入框中的数据 （onchange指定事件回调） &lt;input type=&quot;text&quot; value=&#123;this.state.message&#125; onChange=&#123;this.inputChange&#125;/&gt; ) &#125;&#125; 优化上述代码若有很多个input，比如用户名，密码等等，总不能绑定一个又一个onchange事件 12345678910111213141516171819202122232425262728293031323334353637class Counter extends React.Component &#123; // 1. 声明一个用来控制input value属性的react组件自己的状态 state = &#123; username:&#x27;&#x27;, password:&#x27;&#x27; &#125; // 回调函数 saveFormData = (dataType) =&gt; &#123; console.log(dataType) return (e) =&gt; &#123; // 把saveFormData返回值返回的函数交给onchange作为回调 console.log(e.target.value) this.setState(&#123; // dataType:e.target.value // 这样写是往state中放了一个新的Key,在用户名输入的内容，会出现在dataType这个key后面；压根就没有读取 // 需要读取变量,变量用[] [dataType]:e.target.value &#125;) &#125; &#125; // 表单提交的回调 handleSubmit = (e) =&gt; &#123; e.preventDefault() // 阻止表单默认提交 const &#123;username,password&#125; = this.state alert(`用户名是$&#123;username&#125;`,密码是$&#123;password&#125;) &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; 用户名&lt;input type=&quot;text&quot; onChange=&#123;this.saveFormData(&#x27;username&#x27;)&#125;/&gt; &#123;/* 但若是这么写就是把saveFormData返回值作为回调，立即执行 saveFormData返回值是undefined */&#125; 密码&lt;input type=&quot;text&quot; onChange=&#123;this.saveFormData(&#x27;password&#x27;)&#125;/&gt; &lt;/form&gt; ) &#125;&#125; 高阶函数和函数柯里化 上述saveFormData这就是高阶函数 高阶函数： 如果一个函数符合下面两个规范中的任何一个，那该函数就是高阶函数 1. 若A函数接收的参数是一个函数，那么A就可以称之为高阶函数 2. 若A函数调用的返回值依然是一个函数，那么A就可以称之为高阶函数 常见的高阶函数： promise、setTimeout、arr.map()等等 函数柯里化 通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式 12345function sum(a,b,c) &#123; return a+b+c&#125;const result = sum(1,2,3)console.log(sum ) 不用柯里化实现1234567891011121314151617181920212223// saveFormData = (dataType,value) =&gt; &#123; // this.setState(&#123;[dataType]:value&#125;) // &#125;// 精简代码 saveFormData = (dataType,e) =&gt; &#123; this.setState(&#123;[dataType]:e.target.value&#125;) &#125;render() &#123; return ( // &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; // 用户名&lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; &#123;this.saveFormData(&#x27;username&#x27;,e.target.value)&#125;&#125;/&gt; // &#123;/* 但若是这么写就是把saveFormData返回值作为回调，立即执行 saveFormData返回值是undefined */&#125; // 密码&lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; &#123;this.saveFormData(&#x27;password&#x27;,e.target.value)&#125;&#125;/&gt; // &lt;/form&gt; &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; 用户名&lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; &#123;this.saveFormData(&#x27;username&#x27;,e)&#125;&#125;/&gt; &#123;/* 但若是这么写就是把saveFormData返回值作为回调，立即执行 saveFormData返回值是undefined */&#125; 密码&lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; &#123;this.saveFormData(&#x27;password&#x27;,e)&#125;&#125;/&gt; &lt;/form&gt; )&#125; react生命周期生命周期回调函数 又叫 生命周期钩子函数 生命周期钩子 生命周期函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/babel&quot;&gt; class Life extends React.Component &#123; // 要求2秒完全可见到消失 state = &#123;opacity:1&#125; death = () =&gt; &#123; // 卸载组件前要先清除定时器，拿到定时器的id clearInterval(this.timer) // 卸载组件回调 // ReactDOM.unmountComponent() // 若有很多个容器不能用这个 ReactDOM.unmountComponentAtNode(document.getElementById(&#x27;test&#x27;)) &#125; // 组件挂载完毕 后调用 componentDidMount() &#123; // 这个不需要像death一样，写一个箭头函数，因为它与render是兄弟，后期是通过Life的实例对象 .调用的 this.timer = setInterval(() =&gt; &#123; // 1. 获取原状态,这里不能用const，const声明变量不可修改 let &#123;opacity&#125; = this.state // 减小0.1 opacity -= 0.1 if(opacity &lt;=0) opacity = 1 // 为什么是&lt;=0因为在js中0.1+0.2不一定等于0.3 // 设置新的透明度 this.setState (&#123;opacity&#125;) &#125;,200) &#125; // 组件将要卸载 // componentWillUnmount() &#123; // 这样清楚定时器也可以 // clearInterval(this.timer) // &#125; // render调用的时机：初始化渲染，状态更新之后 render() &#123; // 这样写代码直接卡死了，cpu一路飙升；因为设置更新状态，一更新状态就调render， 引发无限递归，多次调用render // setInterval(() =&gt; &#123; // // 1. 获取原状态,这里不能用const，const声明变量不可修改 // let &#123;opacity&#125; = this.state // // 减小0.1 // opacity -= 0.1 // if(opacity &lt;=0) opacity = 1 // 为什么是&lt;=0因为在js中0.1+0.2不一定等于0.3 // // 设置新的透明度 // this.setState (&#123;opacity&#125;) // &#125;,200) return ( &lt;div&gt; &#123;/* h2中写style=&#123;&#123;opacity:this.state.opacity&#125;&#125; */&#125; &lt;h2&gt;只要学不死，就往死里学&lt;/h2&gt; &lt;button onClick=&#123;this.death&#125;&gt;不活了&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Life/&gt;,document.getELementById(&#x27;test&#x27;)) &lt;/script&gt; 组件是否应该被更新shouldComponentUpdatetrue可以更新false不可以更新不写这个钩子，默认true forceUpdate强制更新可以绕过shouldComponentUpdate，直接进行更新 父组件rendercomponentWillReceiveProps这个第一次传的不算，以后传的才算 123456789101112131415161718192021222324252627class A extends React.Component&#123; state = &#123;carName:&#x27;宝马&#x27;&#125; changeCar = () =&gt; &#123; this.setState(&#123;carName:&#x27;奔驰&#x27;&#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;我是A组件&lt;/div&gt; &lt;button onClick=&#123;this.changeCar&#125;&gt;&lt;/button&gt; &lt;B carName=&#123;this.state.carName&#125;/&gt; &lt;/div&gt; ) &#125;&#125;class B extends React.Component&#123; componentWillReceiveProps(props) &#123; console.log(&#x27;B---componentWillReceiveProps&#x27;,props) &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt;我是B组件，接收的车是:&#123;this.props.carName&#125;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; [AIA] 初始化阶段: 由ReactDoM.render()触发—初次渲染 constructor() componentWillMount() render() componentDidMount()更新阶段: 由组件内部this.setSate()或父组件重新render触发 shouldComponentUpdate()componentwillUpdate() render() componentDidUpdate() 卸载组件:由ReactDOM.unmountComponentAtNode()触发componentwillUnmount()新生命周期去掉三个钩子，加了两个钩子componentWillMount() componentwillUpdate() componentwillUnmount() getDerivedStateFromProps:若state的值任何时候都取决于props，可以使用 getSnapShotBeforeUpdate(preProps,preState,snapValue) 在更新前获取快照在页面调完时拿到数据在处理时使用，此生命周期的任何返回值将作为参数传递给componentDidUpdate","categories":[],"tags":[]},{"title":"Nuxtjs学习","slug":"Nuxt","date":"2021-10-19T02:20:28.000Z","updated":"2023-03-31T07:13:00.937Z","comments":true,"path":"2021/10/19/Nuxt/","link":"","permalink":"http://example.com/2021/10/19/Nuxt/","excerpt":"","text":"官网介绍关于 Nuxt.js 2016 年 10 月 25 日，zeit.co 背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。 Nuxt.js 是什么？Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端&#x2F;服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。 Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置。 除此之外，我们还提供了一种命令叫：nuxt generate ，为基于 Vue.js 的应用提供生成对应的静态站点的功能。 我们相信这个命令所提供的功能，是向开发集成各种微服务（Microservices）的 Web 应用迈开的新一步。 作为框架，Nuxt.js 为 客户端&#x2F;服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等。 Nuxtjs特性 基于 Vue.js 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ES2015+ 语法支持 打包和压缩 JS 和 CSS HTML 头部标签管理 本地开发支持热加载 集成 ESLint 支持各种样式预处理器： SASS、LESS、 Stylus 等等 支持 HTTP&#x2F;2 推送* Nuxtjs 和 Vue的区别 路由 nuxt按照 pages 文件夹的目录结构自动生成路由 vue需在 src&#x2F;router&#x2F;index.js 手动配置路由 nuxt nuxt 类似 router-view , nuxt-link 类似 router-link webpack配置 nuxt内置webpack，允许根据服务端需求，在 nuxt.config.js 中的build属性自定义构建webpack的配置，覆盖默认配置 vue关于webpack的配置存放在build文件夹下 项目入口 nuxt: 没有main.js入口文件，项目初始化的操作需要通过nuxt.config.js进行配置指定。 vue: &#x2F;src&#x2F;main.js，在main.js可以做一些全局注册的初始化工作； 网页渲染流程 vue: 客户端渲染，先下载js后，通过ajax来渲染页面； nuxt： 服务端渲染，可以做到服务端拼接好html后直接返回，首屏可以做到无需发起ajax请求； build后目标产物不同 vue: dist uxt: .nuxt 安装123$ npx create-nuxt-app &lt;项目名&gt;// 或$ yarn create nuxt-app &lt;项目名&gt; 目录结构 资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。 组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。 布局目录 layouts 用于组织应用的布局组件。 middleware 目录 用于存放应用的中间件。 页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。 插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。 静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。服务器启动的时候，该目录下的文件会映射至应用的根路径 &#x2F; 下。 store 目录 用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。 nuxt.config.js 文件用于组织 Nuxt.js 应用的个性化配置，以便覆盖默认配置。 路由 Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。 123 &lt;template&gt; &lt;nuxt-link to=&quot;/&quot;&gt;首页&lt;/nuxt-link&gt;&lt;/template&gt; 举例 pages 文件下 12345pages/ --| user/ -----| index.vue -----| one.vue --| index.vue 生成的路由12345678910111213141516171819router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;user&#x27;, path: &#x27;/user&#x27;, component: &#x27;pages/user/index.vue&#x27; &#125;, &#123; name: &#x27;user-one&#x27;, path: &#x27;/user/one&#x27;, component: &#x27;pages/user/one.vue&#x27; &#125; ]&#125; 动态路由123456789101112131415161718192021222324router: &#123; routes: [ &#123; name: &#x27;index&#x27;, path: &#x27;/&#x27;, component: &#x27;pages/index.vue&#x27; &#125;, &#123; name: &#x27;users-id&#x27;, path: &#x27;/users/:id?&#x27;, component: &#x27;pages/users/_id.vue&#x27; &#125;, &#123; name: &#x27;slug&#x27;, path: &#x27;/:slug&#x27;, component: &#x27;pages/_slug/index.vue&#x27; &#125;, &#123; name: &#x27;slug-comments&#x27;, path: &#x27;/:slug/comments&#x27;, component: &#x27;pages/_slug/comments.vue&#x27; &#125; ]&#125;","categories":[],"tags":[]},{"title":"其他知识","slug":"other","date":"2021-09-28T04:23:48.000Z","updated":"2023-04-25T01:19:01.855Z","comments":true,"path":"2021/09/28/other/","link":"","permalink":"http://example.com/2021/09/28/other/","excerpt":"","text":"其他知识 本篇文章包含了 vue源码知识 和 其他特色功能展示 vue源码部分核心解析 由于是单独提取需要上下相互学习 初始化data new Vue的时候调用会调用_init方法,定义 $set、 $get 、$delete、$watch 等方法,调用$mount进行页面的挂载,挂载的时候主要是通过mountComponent方法,定义updateComponent更新函数,执行render生成虚拟DOM,_update将虚拟DOM生成真实DOM结构，并且渲染到页面中 1234567891011121314151617181920212223242526 //html new Vue(&#123; el:&quot;#app&quot;, //data 两种情况 data:&#123; &#125;, data()&#123; return &#123; msg:&quot;hello&quot; &#125; &#125; watch:&#123;&#125; &#125;) //.$mount(&quot;#app&quot;)function vue(options)&#123; //初始化 this._init(options)&#125;initMixin(vue)lifeyvleMinin(vue)//添加生命周期renderMin(Vue)//添加_rende//全局方法initGlobApi(Vue)export default vue 初始化init 12345678910111213141516171819202122232425262728293031 export function initMixin(Vue)&#123; Vue.prototype._init = function(options)&#123; let vm = this //vm = 实例 vm.$options = merfeOptions(Vue.options,options) callHook(vm,&#x27;beforeCreates&#x27;) //生命周期 vm.$options = mergerOption(Vue.options) //初始化状态 initState(vm) callHook(vm,;&#x27;creates&#x27;) //渲染模板 if(vm.$options.el)&#123; vm.$mount(vm.$options.el) &#125; &#125; //创建$mountVue.prototype.$mount = function(el)&#123; // let vm = this //实例 el = document.querySelector(el) let options = vm.$options if(!options.render)&#123; let template= options.template if(!template &amp;&amp; el)&#123; //获取到html el=el.outerHTML &#125; &#125;&#125;&#125; 初始化状态 1234567891011121314151617181920212223242526272829303132 export function initState(vm)&#123; let ops = vm.$options //判断 if(opts.props)&#123; initProps(vm) &#125; if(opts.data)&#123; initData(vm) &#125; if(opts.watch)&#123; initWatch(vm) &#125; if(opts.compoted)&#123; initCompoted(vm) &#125; if(opts.methods)&#123; initMethods(vm) &#125;&#125;function initProps(vm)&#123;&#125;//vue2对data初始化 //分为函数 和对象 两种类型function initData(vm)&#123; let data = vm.$options.data //this 指向window 要指向new实例 data = typeof data == &#x27;function&#x27;? data.call(vm):data //劫持data observer(data) //data中的数据分为 数组(内部包含对象) 和对象两种情况&#125;function initWatch(vm)&#123;&#125;function initCompoted(vm)&#123;&#125;function initMethods(vm)&#123;&#125; vue中的data data分为两种形式 分为函数和对象 在远吗中通过typeof 判断是函数还是对象 将返回的结果传递给了observer函数进行类型判断取值是把传入值所有的属性(包括嵌套属性)递归 进行响应式defineReactive，又通过 object.definProperty（缺点： 对象中的一个属性进行劫持） 定义get set方法难点是对数组的劫持 首先对数组进行遍历 并获取数组原来的方法 并继承 然后对数组中所有能改变数组自身的方法，如 push、pop 等这些方法进行重写。重写后的方法会先执行它们本身原有的逻辑，并对能增加数组长度的 3 个方法 push、unshift、splice 方法做了判断，获取到插入的值，然后把新添加的值变成一个响应式对象 123let data = vm.$options.datadata = typeof data === &#x27;function&#x27;?data.call(vm):dataobserver(data)//劫持data 对象/数组 data 中处理对象数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657export function observe(data)&#123; //判断数据 if(typeod data != &#x27;object&#x27; || data == null)&#123; return data &#125; //对象通过一个类劫持 return new Observer(data)&#125;class Observer &#123; constructor(value)&#123; //给value定义了一个属性 Object.defineProperty(value,&quot;__ob__&quot;,&#123; enumerable:false, value:this &#125;) //判断数据 if(Array.isArray(value))&#123; value.__proto__ == ArrayMethods this.observeArray(value)//处理数组对象 &#125;else&#123; this.walk(value) //遍历 &#125; &#125; walk(data)&#123; let keys = object.keys(data) for(let i=0;i&lt;keys.length;i++)&#123; //对我们的每个属性进行劫持 let key =keys[i] let value = data[i] defineReactive(data,key,value) &#125; &#125; observeArray(value)&#123; for(let let i=0;i&lt;value.length;i++)&#123; observer(value[i]) &#125; &#125;&#125;//对对象中的属性进行劫持function definReactive(data,key,value)&#123; observer(value)//深度代理 object.definProperty(data,key,&#123; get()&#123; return data[key] &#125;, set(newValue)&#123; if(newValue == value) return ; observer(value)//如果用户设置的是对象 value = newValue &#125; &#125;)&#125; data 中处理数组12345678910111213141516171819202122232425262728293031323334//数组劫持 方法函数劫持 劫持数组方法//重写数组//1.获取原来数组方法let oldArrayProtoMethods = Array.prototype//2.继承export let ArrayMethods = Object.create(oldArrayProtoMethods)//3.劫持let methods = [ &#x27;push&#x27;, &#x27;pop&#x27;, &#x27;unshift&#x27;, &#x27;shift&#x27;, &#x27;splice&#x27;]methods.forEach((item)=&gt;&#123; ArrayMethods[item] = function(...args)&#123; let result = oldArrayProtoMethods[item].apply(this,args) //问题 数组追加对象的情况 要进行劫持 let inserted Switch(item)&#123; case &#x27;push&#x27;: case&#x27;unshift&#x27;: inserted = args break; case &#x27;splice&#x27;: inserted = args.splice() &#125; let ob = this.__ob__ if(inserted)&#123; ob.observeArray(inserted) &#125; return result &#125;&#125;) vue模板编译创建了一个baseCompile 函数 通过document.querySelector获取到html 通过正则解析 将template模板里面属性 指定等等 解析成ast树 并进行遍历 节点进行标记 生成render函数 render函数将模版内容生成对应的vnode 通过diff算法中的patch 等到渲染视图中的vnode 新旧节点的对比 创建真实的dom节点插入视图中完成渲染*&#x2F; 获取html转为ast语法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/vue首次渲染 =&gt;&gt; 先初始化数据 =》 讲模板进行编译 //创建$mountexport function initMixin(Vue)&#123; Vue.prototype._init = function(options)&#123; let vm = this //vm = 实例 vm.$options = options //初始化状态 initState(vm) //渲染模板 if(vm.$options.el)&#123; vm.$mount(vm.$options.el) &#125; &#125; //创建$mountVue.prototype.$mount = function(el)&#123; // let vm = this //实例 el = document.querySelector(el) let options = vm.$options if(!options.render)&#123; let template= options.template if(!template &amp;&amp; el)&#123; //获取到html el=el.outerHTML //变成ast语法树 let ast = compileToFunction(el) //变成rander() options.render = render //变成虚拟dom &#125; &#125; //挂载组件 mounetComponent(vm,el)&#123; &#125;&#125;///ast语法树&#123;&#125; vnode只能操作节点/*&lt;div id=&quot;app&quot;&gt;hello &#123;&#123;msg&#125;&#125;&lt;/div&gt; &#123; tag:&#x27;div&#x27;, attrs:[&#123;id:&quot;#app&quot;&#125;], children:[&#123;tag:&quot;&quot;,text:&quot;hello&quot;,&#125;,&#123;tag:&#x27;div&#x27;.......&#125;*///遍历const ncname = `[a-zA-Z_][\\\\-\\\\..-9_a-zA-Z]*`;const qunameCapture = `((?:$&#123;ncname&#125;\\\\:)?$&#123;ncnme&#125;)`;const startTagOpen = new RegEp(`^&lt;$&#123;quameCapture&#125;`);const endTag = new RegExp(`^&lt;\\\\/$&#123;qnameCapture&#125;[^&gt;]*&gt;`);const attribute = /^\\s*([^\\s&quot;&#x27;&lt;&gt;\\/=]+)(?:\\s*(=)\\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\\s &quot;&#x27;=&lt;&gt;` ]+)))?/;//&lt;div id=&#x27;app&#x27;&gt;&lt;/div&gt;const startTagClose = /^\\s*(/\\?)&gt;/;const defaultTagRE = /\\&#123;\\((?:.|\\r?\\n)+?)\\&#125;/g//创建一个ast对象function createAstElement(tag,attrs)&#123; return &#123; tagName,//元素 attrs,//属性 children:[]//子节点 type:1, parent:null// &#125;&#125;let root;//根元素let creatParent;//当前元素的父级// 数据结构 栈let stack = []//遍历function start(tag,attrs)&#123;//开始标签 let element = createAstElement(tag,attrs) if(!root)&#123; root = element &#125; creatParent = element stack.push(element)&#125;function charts(text)&#123;//获取文本 text= text.replace(/a/g,&#x27;&#x27;) if(text)&#123; createParent.children.push(&#123;type:3,text&#125;) &#125;&#125;function end()&#123; let element = stack.pop() creatParent = stack[stack.length-1] if(creatParent)&#123;//元素的闭合 element.parent.creaateParent.tag creaateParent.children.push(element) &#125; &#125;function parseHTML(html)&#123; while(html)&#123; //html 为空时候结束 //判断标签 let textEnd = html.indexOf(&#x27;&lt;&#x27;) // if(textEnd === 0)&#123; //第一种情况 开始标签 const startTagMatch = parseStartTag()//开始标签内容 if(startTagMatch)&#123; start(startTagMatch.tagName,startTagMatch.attrs) continue; &#125; //结束标签 let endTagMatch = html.match(endTag) if(endTagMatch)&#123; advance(endTagMatch[0].length) end(endTagMatch[1]) continue; &#125; &#125; let text //文本 if(textEnd&gt;0)&#123; //获取文本内容 text = html.substring(0,textEnd) &#125; if(text)&#123; advance(text.length) charts(text) &#125; &#125; function parseStartTag()&#123; //解析开始标签 const start = html.match(startTagOpen) //1.结果 2.false if(start)&#123; //创建ast 语法树 let match = &#123; tagName:start[1], attrs:[], &#125; advance(stsrt[0].length) //删除开始标签 //属性 多个属性 let attr let end while((!end = html.match(startTagClose)) &amp;&amp; (attrs=html.match(attribute)))&#123; march.attrs.push(&#123;name:attr[1],vale:attrs[3]||attrs[4]||attrs[3]&#125;) advance(attr[0]) brack; &#125; if(end) &#123; advance(end[0].length) &#125; &#125; &#125; function advance(n)&#123; html = html.substring(n) &#125; return root&#125;export function compileToFunction(el)&#123; let ast= parseHTML(el) //ast 语法树变成 render函数 1.ast语法树 变成字符串 2.字符串变成函数 let code =generate(ast)&#125; ast语法变为render函数配合上面使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*&lt;div id=&quot;app&quot;&gt;hello &#123;&#123;msg&#125;&#125;&lt;/div&gt;render()&#123; return _c(&#x27;div&#x27;,&#123;id:app&#125;,_v(&#x27;hello&#x27;+_s(msg)),_c)&#125;*/const defaultTagRE = /\\&#123;((?:.|\\r?\\n)+?)\\&#125;\\&#125;/g//处理属性function genPorps(attrs)&#123; let str =&#x27;&#x27;; for(let i =0;i&lt;attrs.length;i++)&#123; let attr = attr[i]; if(attr.name == &#x27;style&#x27;)&#123; let obj = &#123;&#125; // let [key,val] = sttr.value.split(&#x27;;&#x27;) attr.vale.split(&#x27;;&#x27;).forEach(item=&gt;&#123; let [key,val] =item.split(&#x27;:&#x27;) obj[key] = val &#125;) attr.value = obj &#125; str+= `$&#123;attr.name&#125;:$&#123;JSON.stringify(attr.value)&#125;` &#125; return `&#123;$&#123;str.slice(0,-1)&#125;&#125;`&#125;//处理子节点function genChildren(el)&#123; let children = el.children if(children)&#123; return children.map(child=&gt;gen(child)).join(&#x27;,&#x27;) &#125;&#125;function gen(node)&#123; //形式 1.元素 2.div 3.文本 if(node.type === 1)&#123; //元素 return generate(node) &#125;else &#123;//文本 (1)只是文本 不带插值表达式 （2）插值表达式特殊处理 let text = node.text //获取文本 if(!defaultTagRE.test(text))&#123;//检测是否有插值表达式 return `_v($&#123;JSON.stringify(text)&#125;）` &#125; //带有插值表达式 let tokens = [] let lastindex = defaultTagRE.lasteIndex = 0 let match while(match = defaultTagRE.exec(text))&#123; let index = match.index if(index&gt;lastindex)&#123;//添加内容 tokens.push(JSON.stringify(text.slice(lastindex,index))) &#125; tokens.push(`_s($&#123;match[1].trim()&#125;)`) lastindex = index+ match[0].length if(lastindex&lt;text.length)&#123; tokens.push(JSON.sttingify(text.slice(lastindex))) &#125; return `_v($&#123;tokens.join(&#x27;+&#x27;)&#125;)` &#125; &#125;&#125;export function generate(el)&#123; //注意属性 &#123;id:app,style:&#123;color:red&#125;&#125; let children = genChildren(el) let code = `_c($&#123;el.tag&#125;,$&#123;el.attrs.length?`$&#123;genPorps(el.attrs)&#125;`:&#x27;null&#x27;&#125;,$&#123;children?`$&#123;children&#125;`:&#x27;null&#x27;&#125;)` return code&#125; render字符串从函数到dom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//1. 变为ast 语法树let ast = parseHTML(el)// 2.ast语法树变为render函数let code = generate(ast)//3.将render字符串变成函数let render = new Function(`with(this)&#123;return $&#123;code&#125;&#125;`)//将render函数变成vnode(虚拟dom) return render export function mountComponent(vm,el)&#123; callHook(vm,&#x27;beforMounted&#x27;) vm._updata(vm._render()) //（1）vm._render 将render函数转为vnode （2）vm._updata将vnode转为真实dom callHook(vm,&#x27;mounted&#x27;)&#125;//生命周期export function lifeyvleMinin(vue)&#123; Vue.prototype._updata = function(vnode)&#123; let vm = this //两个参数 旧dom 新dom vm.$el=patch(vm.$el,vnode) &#125;&#125;//生命周期调用export function callHook(vm,hook)&#123; const handlers = vm.$options[hook] if(handlers)&#123; for(let i=0;i&lt;headers.length;i++)&#123; handlers[i].call(this) //改变生命周期中this &#125; &#125;&#125;export function renderMin(Vue)&#123; Vue.prototype._c = function()&#123;//处理标签 // 创建标签 return createElement(...arguments) &#125; Vue.prototype._v = function(text)&#123;//处理文本 return createText(text) &#125; Vue.prototype._s = function(value)&#123;//处理变量 return val == null ? &quot;&quot;:(typeof val == &#x27;object&#x27;)?JSON.stringify(val):val &#125; Vue.prototype._render = function()&#123; //render函数变成vnode let vm =this //实例 let render = vm.$options.render let vnode = = render.call(this) &#125;&#125;//创建元素function createElement(tag,data = &#123;&#125;,...children)&#123; return vnode(tag,data,data.key,children)&#125;//创建文本function createText(text)&#123; return vnode(undefined,undefined,undefined,undefined,text)&#125;// 创建虚拟dom function vnode(tag,data,key,children,text)&#123; return &#123; tag, data, key, children, text &#125; &#125;export function patch(oldVnode,vnode)&#123; //vnode =&gt; 真实dom //(1) 创建新dom let el = createEl(vnode) //(2)替换 获取父节点 插入 删除 let parentEl = oldVnode.parentNode //body parentEl.insertBefore(el,oldVnode.nextsibling) parentEl.removeChild(oldVnode) return el&#125;function createEl(vnode)&#123; let &#123;tag,children,key,data,text&#125; = vnode if(typeof tag == &#x27;string&#x27;)&#123;//表示tag是一个元素 vnode.el = document.createElement(tag)//创建元素 if(children.length&gt;0)&#123; children.forEach(child=&gt;&#123; vnode.el.appendChild(createEl(child)) &#125;) &#125; &#125;else&#123; vnode.el = document.createTextNode(text) &#125; return vnode.el&#125;//render()函数=&gt;vnode=&gt;真是的dom/*//vnode 节点&#123; tag, 标签 text, 文本 children 子级&#125;//vue的渲染流程=&gt;数据初始化=&gt;对模块进行编译=&gt;变成rednder函数=&gt;ender函数 变成vnode =&gt;变成真实dom*/ vue源码后续待更新 diff算法diff 算法是一种通过同层的树节点进行比较的高效算法，比较只会在同层级进行, 不会跨层级比较 在diff比较的过程中，循环从两边向中间比较原理：当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图通过isSameVnode进行判断，相同则调用patchVnode方法patchVnode做了以下操作：找到对应的真实dom，称为el如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点如果oldVnode有子节点而VNode没有，则删除el子节点如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el如果两者都有子节点，则执行updateChildren函数比较子节点updateChildren主要做了以下操作：设置新旧VNode的头尾指针新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作 vue中的双向数据绑定new Vue()首先执行初始化，在Observe函数中对data执行响应化处理，同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，同时定义⼀个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数 因为datra中的某个属性会多次出现 定义了一个dep 管理watcher 将来data中数据⼀旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115class Vue &#123; constructor(options) &#123; this.$options = options; this.$data = options.data; // 对data选项做响应式处理 observe(this.$data); // 代理data到vm上 proxy(this); // 执行编译 new Compile(options.el, this); &#125; &#125; function observe(obj) &#123; if (typeof obj !== &quot;object&quot; || obj == null) &#123; return; &#125; new Observer(obj); &#125; class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; walk(obj) &#123; Object.keys(obj).forEach((key) =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;); &#125; &#125; class Compile &#123; constructor(el, vm) &#123; this.$vm = vm; this.$el = document.querySelector(el); // 获取dom if (this.$el) &#123; this.compile(this.$el); &#125; &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; // 遍历子元素 if (this.isElement(node)) &#123; // 判断是否为节点 console.log(&quot;编译元素&quot; + node.nodeName); &#125; else if (this.isInterpolation(node)) &#123; console.log(&quot;编译插值⽂本&quot; + node.textContent); // 判断是否为插值文本 &#123;&#123;&#125;&#125; &#125; if (node.childNodes &amp;&amp; node.childNodes.length &gt; 0) &#123; // 判断是否有子元素 this.compile(node); // 对子元素进行递归遍历 &#125; &#125;); &#125; isElement(node) &#123; return node.nodeType == 1; &#125; isInterpolation(node) &#123; return node.nodeType == 3 &amp;&amp; /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.textContent); &#125; &#125; // 负责更新视图 class Watcher &#123; constructor(vm, key, updater) &#123; this.vm = vm this.key = key this.updaterFn = updater // 创建实例时，把当前实例指定到Dep.target静态属性上 Dep.target = this // 读一下key，触发get vm[key] // 置空 Dep.target = null &#125; // 未来执行dom更新函数，由dep调用的 update() &#123; this.updaterFn.call(this.vm, this.vm[this.key]) &#125; &#125; class Dep &#123; constructor() &#123; this.deps = []; // 依赖管理 &#125; addDep(dep) &#123; this.deps.push(dep); &#125; notify() &#123; this.deps.forEach((dep) =&gt; dep.update()); &#125; &#125; class Watcher &#123; constructor(vm, key, updateFn) &#123; Dep.target = this; this.vm[this.key]; Dep.target = null; &#125; &#125; function defineReactive(obj, key, val) &#123; this.observe(val); const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; Dep.target &amp;&amp; dep.addDep(Dep.target);// Dep.target也就是Watcher实例 return val; &#125;, set(newVal) &#123; if (newVal === val) return; dep.notify(); // 通知dep执行更新方法 &#125;, &#125;); &#125; js运行机制javaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事avaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。事件循环是js实现异步的一种方法，也是js的执行机制。javascript的执行和运行执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。js 轮询机制所有任务都在主线程上执行，形成一个执行栈。2、主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里。3、执行栈所有同步任务执行完毕。4、执行微任务队列，之后再执行宏任务队列。 浏览器跨域原理核心思想：浏览器的script、img、iframe标签是不受同源策略限制的，所以通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的callback函数，并把我们需要的json数据作为参数传入。在服务器端，当req.params参数中带有callback属性时，则把数据作为callback的参数执行，并拼接成一个字符串后返回。优点：兼容性好，简单易用，支持浏览器与服务器双向通信缺点：只支持GET请求，且只支持跨域HTTP请求这种情况（不支持HTTPS）在js中，直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 CORS请求原理CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 核心思想：在服务器端通过检查请求头部的origin，从而决定请求应该成功还是失败修改document.domain来跨子域浏览器都有一个同源策略，限制其一：不能通过ajax的方法去请求不同源中的文档； 其二：浏览器中不同域的框架间不能进行js的交互操作。不同的框架之间（父子或同辈），能够获取到彼此的window对象的，但不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器如ie6也可以使用top、parent等少数几个属性)。 实用方法复制文本到切板12const copy= (text)=&gt;navigator.clipboard.writeText(text) copy(&quot;你好&quot;) 获取某个日期相当于当年的第几天12const time = (date)=&gt;Math.floor((date - new Date(date.getFullYear(),0,0))/100./60/60/24) console.log(time(new Date(2023,12,30)) 解析url参数1234567const parseurl = (url)=&gt;&#123; q=&#123;&#125; url.replace(/([^?&amp;=]+)=([^&amp;+])/g,(_,k,v)=&gt;(q[k]=v)) return q &#125; console.log(parseurl(&quot;http://a.com/?a=1&amp;b=2&quot;)) console.log(parseurl(&quot;a=1&amp;b=2&quot;)); 生成随机颜色 123const color = () =&gt; &#x27;#&#x27;+Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6,&#x27;0&#x27;); console.log(color()); 去掉字符串中的元素标记123456789const removetap = (tag) =&gt; new DOMParser().parseFromString(tag,&#x27;text/html&#x27;).body.textContent || &#x27; &#x27;; console.log(removetap(&quot;&lt;div&gt;55555555&lt;/div&gt;&quot;)) // ``` #### 获取对象的基本数据类型 ```js const getType = (tag) =&gt; &#123; return Object.prototype.toString.call(tag).slice(8,-1) &#125; console.log(getType(()=&gt;&#123;&#125;)); 反转字符串 1234const reverString = (str) =&gt;&#123; return str.split(&#x27;&#x27;).reverse().join(&quot;&quot;) &#125; console.log(reverString(&quot;efesgfrgrd&quot;)) 获取两个数字之间的随机数1234const random =(min,max)=&gt;&#123; return Math.floor(Math.random() * (max-min+1)+min) &#125; console.log(random(5,8)) 检查日期是否合法1234const ifTimeDate = (...time) =&gt;&#123; return !Number.isNaN(new Date(...time).valueOf()) &#125; console.log(ifTimeDate(&quot; 1999 03:16:18&quot;)); 检查日期是否在两个日期之间1234567const ifData = (data,min,max)=&gt;&#123; return +max&gt;= +data &amp;&amp; data &gt;= +min&#125;const data = new Date(&quot;2010-12-8&quot;)const min = new Date(&quot;2003-05-6&quot;)const max = new Date(&quot;2008-05-16&quot;)console.log(ifData(data,min,max)) 判断此页面标签是否激活12const isTabView =()=&gt;!document.hiddenisTabView() 判断一段字符串是否是url1234const isUrl = (url) =&gt;&#123; return /^(http|https):\\/\\/([\\w.]+\\/?)\\S*/.test(url)&#125;console.log(isUrl(&quot;http://baidu.com&quot;)) 打乱数组顺序123let arr = [1,2,3,4,5]arr = arr.sort(()=&gt;0.5 - Math.random())console.log(arr); 去除数字之外的所有字符123const str = &quot;5415sfs5f15sdf48sdf5ds6666666668ss5ds88&quot;const number = str.replace(/\\D/g,&#x27;&#x27;)console.log(number); 删除数组重复项123let arr = [1,2,2,3,5,5,8]const arr2= (arr)=&gt;[...new Set(arr)]console.log(arr2(arr)); 过滤数组为false得值123let arr = [&#x27;undefined&#x27;,0,2,false]const arr2 = arr.filter(Boolean)console.log(arr2); 滚动到页面顶部123const scrllToTop = () =&gt;&#123; window.scrollTo(&#123;top:0,left:0,behavior:&quot;smooth&quot;&#125;)&#125; 滚动到页面底部123const scrllToTop = () =&gt;&#123; window.scrollTo(&#123;top:document.documentElement.offsetHeight,left:0,behavior:&quot;smooth&quot;&#125;)&#125; 调用摄像头12345document.getElementById(&quot;btn_start&quot;).addEventListener(&#x27;click&#x27;,function()&#123; navigator.mediaDevices.getUserMedia(&#123;video:true&#125;).then(stream=&gt;&#123; document.getElementById(&quot;video&quot;).srcObject = stream &#125;) &#125;) y隐藏手机号中间四位1234const tel = &#x27;15237903806&#x27;const reg = /^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/const str = tel.replace(reg,&quot;$1****$2&quot;)console.log(str) 禁止浏览器缩放1234567891011121314151617181920window.addEventListener( &quot;mousewheel&quot;, function (event) &#123; if (event.ctrlKey === true || event.metaKey) &#123; event.preventDefault(); &#125; &#125;, &#123; passive: false &#125; ); //firefox window.addEventListener( &quot;DOMMouseScroll&quot;, function (event) &#123; if (event.ctrlKey === true || event.metaKey) &#123; event.preventDefault(); &#125; &#125;, &#123; passive: false &#125; ); vue自定义拖拽指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Vue.directive(&#x27;drag&#x27;, (el) =&gt; &#123; const oDiv = el // 当前元素 const minTop = oDiv.getAttribute(&#x27;drag-min-top&#x27;) //用以获取HTML元素的属性 const ifMoveSizeArea = 20 oDiv.onmousedown = e =&gt; &#123; let target = oDiv while (window.getComputedStyle(target).position !== &#x27;absolute&#x27; &amp;&amp; target !== document.body) &#123; target = target.parentElement &#125; document.onselectstart = () =&gt; &#123; return false &#125; if (!target.getAttribute(&#x27;init_x&#x27;)) &#123; target.setAttribute(&#x27;init_x&#x27;, target.offsetLeft) target.setAttribute(&#x27;init_y&#x27;, target.offsetTop) &#125; const initX = parseInt(target.getAttribute(&#x27;init_x&#x27;)) const initY = parseInt(target.getAttribute(&#x27;init_y&#x27;)) // 鼠标按下，计算当前元素距离可视区的距离 const disX = e.clientX - target.offsetLeft const disY = e.clientY - target.offsetTop document.onmousemove = e =&gt; &#123; // 通过事件委托，计算移动的距离 // 因为浏览器里并不能直接取到并且使用clientX、clientY,所以使用事件委托在内部做完赋值 const l = e.clientX - disX const t = e.clientY - disY // 计算移动当前元素的位置，并且给该元素样式中的left和top值赋值 target.style.left = l + &#x27;px&#x27; target.style.top = (t &lt; minTop ? minTop : t) + &#x27;px&#x27; if (Math.abs(l - initX) &gt; ifMoveSizeArea || Math.abs(t - initY) &gt; ifMoveSizeArea) &#123; target.setAttribute(&#x27;dragged&#x27;, &#x27;&#x27;) &#125; else &#123; target.removeAttribute(&#x27;dragged&#x27;) &#125; &#125; document.onmouseup = e =&gt; &#123; document.onmousemove = null document.onmouseup = null document.onselectstart = null &#125; // return false不加的话可能导致黏连，拖到一个地方时div粘在鼠标上不下来，相当于onmouseup失效 return false &#125;&#125;) 调用摄像头12345document.getElementById(&quot;btn_start&quot;).addEventListener(&#x27;click&#x27;,function()&#123; navigator.mediaDevices.getUserMedia(&#123;video:true&#125;).then(stream=&gt;&#123; document.getElementById(&quot;video&quot;).srcObject = stream &#125;) &#125;)","categories":[],"tags":[]},{"title":"vue2内容","slug":"vue","date":"2021-09-15T02:46:27.000Z","updated":"2023-03-30T05:36:56.375Z","comments":true,"path":"2021/09/15/vue/","link":"","permalink":"http://example.com/2021/09/15/vue/","excerpt":"","text":"vue 简介 Vue 是一套用于构建用户界面的 渐进式框架 。 与其它大型框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 最初它不过是个人项目，时至今日，已成为全世界三大前端框架之一，github 上拥有 19.8万 Star。 领先于 React 和 Angular，在国内更是首选。 自从Vue 2.0 发布之后，Vue 就成了前端领域的热门话题。 2019.02.05，Vue 发布了 2.6.0 ，这是一个承前启后的版本，在它之后，推出了 3.0.0。 2019.12.05，在万众期待中，尤雨溪公布了 Vue 3 源代码，此时的 Vue 3仍 处于 Alpha 版本。 2020年09月18日，Vue.js 3.0 正式发布。 Vue 周边生态 vue-cli：vue 脚手架vue-resource(axios)：ajax 请求vue-router：路由vuex：状态管理（它是 vue 的插件但是没有用 vue-xxx 的命名规则）vue-lazyload：图片懒加载vue-scroller：页面滑动相关mint-ui：基于 vue 的 UI 组件库（移动端）element-ui：基于 vue 的 UI 组件库（PC 端） 原生计数器 1234567891011121314151617// 1. 获取DOM原生const titleEl = document.querySelector(&quot;.title&quot;);const btnInEl = document.querySelector(&#x27;.increment&#x27;);const btnDeEl = document.querySelector(&#x27;.decrement&#x27;);// 2. 默认设置的是Hello Worldlet counter = 0// 3. 设置titleEl的内容titleEl.innerHTML = counter;// 4. 监听按钮的点击btnInEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter += 1; titleEl.innerHTML =counter;&#125;)btnDeEl.addEventListener(&#x27;click&#x27;,(=&gt;&#123; counter -=1; titleEl.innerHTML = counter;&#125;) vue写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- vue指令: v-on:事件类型 --&gt; &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;!-- 简写 比如: @click @keyup @keydown --&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &#123;&#123; count &#125;&#125; &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 关闭生产提示 Vue.config.productionTip = false var vm = new Vue(&#123; el: &#x27;#app&#x27;, // 数据 data: &#123; count: 0 &#125;, // 方法 methods: &#123; increment()&#123; // this =&gt; vue实例 this.count++ &#125;, decrement()&#123; this.count-- &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 指令语法123456789101112131415161718192021222324252627282930313233343536373839404142434445# 属性绑定 v-bind:# 功能：指定变化的属性值# 完整写法 v-bind:xxx=&#x27;yyy&#x27; // yyy会作为表达式解析执行# 简洁写法 :xxx=&#x27;yyy&#x27;# 属性绑定应用&lt;div id=&quot;app&quot;&gt; &lt;!-- 数组 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套三元表达式 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, isactive?&#x27;active&#x27;: &#x27;&#x27;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 数组嵌套对象 --&gt; &lt;h1 :class=&quot;[&#x27;red&#x27;, &#x27;thin&#x27;, &#123;active: isactive&#125;]&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;!-- 直接使用对象 --&gt; &lt;h1 :class=&quot;&#123;red:true&#125;&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;h1 :class=&quot;styles&quot;&gt;&#123;&#123;msg ? &#x27;尘埃等闲&#x27;:&#x27;大千世界&#x27;&#125;&#125;&lt;/h1&gt; &lt;hr&gt; &lt;button @click=&#x27;click&#x27;&gt;点击&lt;/button&gt;&lt;/div&gt;&lt;script&gt; let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, info: &#x27;明天就中秋了，你们的中秋节目准备的咋样了？&#x27;, isactive: true, index: 1, styles: &#123; red: true, thin: true, active: true &#125; &#125;, methods: &#123; click() &#123; console.log(this); &#125; &#125;, &#125;)&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 单向数据绑定# 语法：v-bind:href =&quot;xxx&quot; 或简写为 :href =&quot;xxx&quot;# 特点：数据只能从 data 流向页面# 双向数据绑定 指令 v-model# 语法：v-mode:value=&quot;xxx&quot; 或简写为 v-model=&quot;xxx&quot;# 特点：数据不仅能从 data 流向页面，还能从页面流向 datav-model应用v-model:用来辅助开发者在不操作 DOM 的前提下，快速获取表单的数据&lt;p&gt;选择的省份是: &#123;&#123;province&#125;&#125;&lt;/p&gt;&lt;select v-model=&#x27;province&#x27;&gt; &lt;option value=&quot;0&quot;&gt;--请选择--&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;深圳&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;广州&lt;/option&gt; &lt;option value=&quot;4&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;杭州&lt;/option&gt;&lt;/select&gt;&lt;p&gt;您选中的是:&#123;&#123;sex&#125;&#125;&lt;/p&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;man&quot;&gt;man&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&#x27;sex&#x27; value=&quot;woman&quot;&gt;woman&lt;p&gt;您的爱好是: &#123;&#123;loves&#125;&#125;&lt;/p&gt;&lt;input type=&quot;checkbox&quot; name=&quot;game&quot; v-model=loves value=&quot;玩游戏&quot;&gt;玩游戏&lt;input type=&quot;checkbox&quot; name=&quot;music&quot; v-model=loves value=&quot;听音乐&quot;&gt;听音乐&lt;input type=&quot;checkbox&quot; name=&quot;basketball&quot; v-model=loves value=&quot;打篮球&quot;&gt;打篮球&lt;input type=&quot;checkbox&quot; name=&quot;eat&quot; v-model=loves value=&quot;吃东西&quot;&gt;吃东西&lt;input type=&quot;checkbox&quot; name=&quot;treenp&quot; v-model=loves value=&quot;吹牛皮&quot;&gt;吹牛皮.number: 将输入值转化为数字类型想要严格限制输入框只允许输入数字，请使用属性type=&quot;number&quot;&lt;input type=&quot;text&quot; v-model.number=&#x27;first&#x27; @keyup=&#x27;sum&#x27;&gt;+&lt;input type=&quot;text&quot; v-model.number=&#x27;last&#x27; @keyup=&#x27;sum&#x27;&gt; =&lt;span&gt;&#123;&#123;result&#125;&#125;&lt;/span&gt;.lazy: 当添加了.lazy修饰符后，双向绑定的数据就不同步了，相当于在input输入框失去焦点后触发的change事件中同步&lt;div&gt; &lt;input v-model.lazy=&quot;msg&quot; @change=&quot;show&quot;&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: 老许 &#125; &#125;, methods: &#123; show () &#123; console.log(this.msg) &#125; &#125;&#125;&lt;/script&gt;.trim 自动去除输入框前后(首尾)空格如下: 如果直接在开头输入空格，或者是在末尾输入空格，是不会显示有输入内容的&lt;input type=&quot;text&quot; v-model.trim=&quot;msg&quot;&gt; v-on指令12345678v-on:click=&#x27;xxx&#x27;v-on:keyup=&#x27;xxx(参数)&#x27;v-on:keyup.enter=&#x27;xxx&#x27;功能：绑定指定事件名的回调函数简洁写法@click=&#x27;xxx&#x27;@keyup=&#x27;xxx&#x27;@keyup.enter=&#x27;xxx&#x27; 事件修饰符prevent：阻止默认事件（常用）； 12&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;a href=&quot;https://www.baidu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我&lt;/a&gt; stop：阻止事件冒泡（常用）； 12345&lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt;&lt;button @click.stop=&quot;showInfo&quot;&gt;点我&lt;/button&gt;&lt;!-- 修饰符可以连续写 先写的先起作用: 这样写就是先阻止默认行为后阻止冒泡--&gt;&lt;!-- &lt;a href=&quot;https://www.baidu.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我&lt;/a&gt; --&gt;&lt;/div&gt; once：事件只触发一次（常用） 123&lt;!-- 事件只触发一次（常用） --&gt;&lt;button @click.once=&quot;showInfo&quot;&gt;点我&lt;/button&gt; 指令语法：条件渲染指令v-if是控制元素是否加载到页面上（有性能开销） 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。当条件不成立时, v-if 的所有子节点不会解析 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被 ‘打断’。 v-show是控制元素的显示与隐藏 （初始创建时加载一次） 切换频率较高的场景。不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 123456789&lt;p v-if=&#x27;flag&#x27;&gt;海底月是天上月&lt;/p&gt;&lt;p v-else&gt;眼前人是心上人&lt;/p&gt;&lt;p v-if=&quot;type === &#x27;A&#x27;&quot;&gt;优秀&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;良好&lt;/p&gt;&lt;p v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;一般&lt;/p&gt;&lt;p v-else=&quot;type === &#x27;D&#x27;&quot;&gt;差&lt;/p&gt;&lt;p v-show=&#x27;flag&#x27;&gt;&lt;/p&gt; 列表渲染指令v-for指令: 1、用于展示列表数据 2、语法：v-for&#x3D;“(item, index) in xxx” :key&#x3D;“yyy” 3、可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 123456789101112131415161718192021222324252627282930&lt;!-- 遍历数组 --&gt;&lt;ul&gt; &lt;span&gt;key是唯一的标识 其数据类型只能是字符串或者数字&lt;/span&gt; &lt;!-- item代表数组中的每一项 --&gt; &lt;!-- 如果需要取下标 (item, index) --&gt; &lt;li v-for=&quot;(item,index) of persons&quot; :key=&quot;index&quot;&gt; &#123;&#123;item.name&#125;&#125;-&#123;&#123;item.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历对象 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(value,key) of car&quot; :key=&quot;key&quot;&gt; &#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历字符串 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(char,index) of str&quot; :key=&quot;index&quot;&gt; &#123;&#123;char&#125;&#125;-&#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;!-- 遍历指定次数 --&gt;&lt;ul&gt; &lt;li v-for=&quot;(number,index) of 5&quot; :key=&quot;index&quot;&gt; &#123;&#123;index&#125;&#125;-&#123;&#123;number&#125;&#125; &lt;/li&gt;&lt;/ul&gt; key使用注意事项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!-- 面试题：react、vue中的key有什么作用？（key的内部原理）1. 虚拟DOM中key的作用：key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：2.对比规则：(1).旧虚拟DOM中找到了与新虚拟DOM相同的key： ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！ ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。(2).旧虚拟DOM中未找到与新虚拟DOM相同的key 创建新的真实DOM，随后渲染到到页面。 3. 用index作为key可能会引发的问题： 1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 2. 如果结构中还包含输入类的DOM： 会产生错误DOM更新 ==&gt; 界面有问题。4. 开发中如何选择key? 1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示， 使用index作为key是没有问题的。--&gt;&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;carname&#x27;&gt; &lt;button @click=&#x27;add&#x27;&gt;添加一辆车&lt;/button&gt; &lt;ul v-for=&#x27;(item, index) in list&#x27; :key=&#x27;item.id&#x27;&gt; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;input&gt;&lt;/input&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div &gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; carname: &#x27;&#x27;, nextId: 4, list: [ &#123;id: 001, name: &#x27;法拉利&#x27; &#125;, &#123;id: 002, name: &#x27;兰博基尼&#x27; &#125;, &#123;id: 003, name: &#x27;布加迪&#x27; &#125;] &#125;, methods: &#123; add() &#123; this.list.unshift(&#123; id: this.nextId, name: this.carname &#125;) this.nextId += 1 &#125; &#125; &#125;);&lt;/script&gt; 过滤器​ 定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。 ​ 语法： ​ 1.注册过滤器：Vue.filter (name,callback) 或 new Vue { filters:{} } ​ 2.使用过滤器： 1&#x27;&#123;&#123; xxx | 过滤器名 &#125;&#125;&#x27; 或 v-bind:属性 = &quot;xxx | 过滤器名&quot; ​ 备注： ​ 1.过滤器也可以接收额外参数、多个过滤器也可以串联 ​ 2.并没有改变原本的数据, 是产生新的对应的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt; !--准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; fmtTime &#125;&#125;&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; getFmtTime() &#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：&#123;&#123; time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;&lt;/h3&gt; &lt;h3 :x=&quot;msg | mySlice&quot;&gt;哈哈哈&lt;/h3&gt; &lt;/div &gt; &lt;div id=&quot;root2&quot;&gt; &lt;h2&gt;&#123;&#123; msg | mySlice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body &gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //全局过滤器 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4) &#125;) new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; time:1621561377603, //时间戳 msg:&#x27;你好，vue&#x27; &#125;, computed: &#123; fmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, methods: &#123; getFmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, //局部过滤器 filters:&#123; timeFormater(value, str = &#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123; // console.log(&#x27;@&#x27;,value) return dayjs(value).format(str) &#125; &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; msg:&#x27;hello,vue!&#x27; &#125; &#125;) computed和method123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;firstName&#x27;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;lastName&#x27;&gt; &lt;!-- 插值表达式的实现 简单的js逻辑表达式 --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName +&#x27;-&#x27;+ lastName&#125;&#125;&lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;firstName&#125;&#125; - &#123;&#123;lastName&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- 更复杂的通过方法的实现 methods中的方法调用一次就会执行一次 如果数据不需要更新 会造成性能的浪费--&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; &lt;span&gt;&#123;&#123;fullName()&#125;&#125; &lt;/span&gt; --&gt; &lt;!-- &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; --&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // 定义到data中的数据默认会被响应式监听 firstName: &#x27;张&#x27;, lastName: &#x27;三&#x27; &#125;, methods: &#123; // fullName() &#123; // console.log(111); // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125;, // 计算属性computed: 计算属性的值本身不存在 是需要通过计算得到的 // 底层也是通过object.defineProperty来实现的 // computed 与 methods的区别 // 1、是否存在缓存: methods调用一次执行一次 // computed第一次调用时会将结果缓存 (有缓存)、后续调用在所依赖的数据不发生变化的前提下 直接返回缓存的结果 =&gt; 复用率高 提升性能 // 2、调用方式不同: methods使用时，一般情况需要加括号，而computed则不需要 // 3、绑定方式不同: methods是单向数据绑定 只有getter, computed是双向数据绑定, 有setter和getter // 使用场景 // 某个属性的值需要来自多个属性的简单计算或者复杂逻辑计算得出的值时, 推荐使用computed属性, 比如购物车的总价计算 computed: &#123; // 完整写法 fullName: &#123; // get作用: 当使用到fullName的时候 默认会调用get方法 // get特点: // 1、初次使用计算属性的时候会执行 // 2、当依赖的响应式数据发生变化的时候会执行 get() &#123; console.log(111); return this.firstName + &#x27;-&#x27; + this.lastName &#125;, // 如果需要修改计算属性 需要提供一个set方法 // 并且这个set方法中要能够引起依赖的数据的变化 set(val) &#123; let arr = val.split(&#x27;-&#x27;) this.firstName = arr[0] this.lastName = arr[1] &#125; &#125;, // 简写 // fullName()&#123; // return this.firstName + &#x27;-&#x27; + this.lastName // &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios@0.21.4/dist/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&#x27;name&#x27;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt; &lt;input type=&quot;text&quot; v-model=&#x27;student.loves.playGame.tencent.name&#x27;&gt; &lt;/div&gt; &lt;script&gt; // watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作 var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; // _data会收集data中的数据 处理成响应式 // 再将其挂载到vm实例对象下方便开发者使用 =&gt; 数据代理 // 响应式: 简单的说就是数据发生变化 页面会重新渲染 // 页面发生变化 数据也会随之变化 name: &#x27;admin&#x27;, message: &#x27;&#x27;, student: &#123; loves: &#123; playGame: &#123; tencent: &#123; name: &#x27;王者荣耀&#x27;, price: 99 &#125;, wangyi: &#123; name: &#x27;和平精英&#x27;, &#125; &#125; &#125; &#125; &#125;, methods: &#123;&#125;, watch: &#123; // 侦听器本质是一个函数 需要侦听谁 就将侦听的属性当作函数名放到watch中即可 // 当被监视的属性发生变化时，回调函数自动调用，执行函数中的代码 // name() &#123; // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125; // 有配置项的情况 将函数改造成对象的形式 // name: &#123; // async handler(newVal, oldVal) &#123; // console.log(111); // console.log(&#x27;新值&#x27;+ newVal, &#x27;老值&#x27;+ oldVal); // if (this.name == &#x27;&#x27;) return // const &#123; data &#125; = await axios.get(&#x27;https://www.escook.cn/api/finduser/&#x27; + this.name) // this.message = data.message // &#125;, // 表示页面初次渲染好之后，就立即触发当前的 watch 侦听器 // 执行handler函数中的内容 // immediate: true, // &#125;, // 如果层次不深 可以直接通过这种方式侦听 // &#x27;student.name&#x27;:&#123;&#125; // &#x27;student.loves.playGame.tencent.name&#x27;:&#123; // handler(newVal)&#123; // console.log(11111); // console.log(newVal); // &#125; // &#125; // vue中的watch默认不监视对象内部的值改变 student: &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 // deep: true &#125; &#125; &#125;); vm.$watch(&#x27;student&#x27;, &#123; handler(newVal) &#123; console.log(11111); console.log(newVal); &#125;, // 开启深度监听 deep: true &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; computed和watch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; firstName: &#x27;Foo&#x27;, lastName: &#x27;Bar&#x27;, fullName: &#x27;Foo Bar&#x27; &#125;, // 侦听器的方式 watch: &#123; firstName: function (val) &#123; this.fullName = val + &#x27; &#x27; + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + &#x27; &#x27; + val &#125; &#125;, // 计算属性的方式 computed: &#123; fullName() &#123; this.fullName = this.firstName + &#x27; &#x27; + this.lastName &#125; &#125; // computed和watch的区别 // 1、computed是有缓存的 watch没有 // 2、computed一般执行同步操作 异步操作在watch中实现 // 3、computed监听的那个数据的数据发生变化时,不会重新计算,只有依赖的数据发生变化时才会重新调用getter来计算 // watch监听的数据发生变化时 立马执行相应的回调函数重新计算 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 数据代理什么是数据代理？ 通过一个对象代理对另一个对象中属性的操作（读&#x2F;写） 123456789101112let obj1 = &#123; x: 100 &#125;let obj2 = &#123; y: 200 &#125;Object.defineProperty(obj2, &#x27;x&#x27;, &#123; get() &#123; return obj1.x &#125;, set(value) &#123; obj1.x = value &#125;&#125;)此时操作obj2实际上在操作obj1 vue中的数据代理 vue里面data的数据代理 通过_data收集data中的数据 利用Object.defineProperty中的get和set将data中的每个数据进行数据代理 再将代理好的数据挂载到vm实例上 好处: 方便开发者操作data中的数据 Vue.set()注意：受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter&#x2F;setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 如果在实例创建之后添加新的属性到实例上，它不会触发视图更新 如果想要数据是响应式的并且能触发视图更新 使用Vue.set() (比如 this.myObject.newProperty &#x3D; ‘hi’) 自定义指令除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100自定义指令总结：一、定义语法：(1).局部指令：new Vue(&#123; new Vue(&#123;directives:&#123;指令名:配置对象&#125; 或 directives&#123;指令名:回调函数&#125;&#125;) &#125;)(2).全局指令：Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数)二、配置对象中常用的3个回调：(1).bind：指令与元素成功绑定时调用。(2).inserted：指令所在元素被插入页面时调用。(3).update：指令所在模板结构被重新解析时调用。三、备注：1.指令定义时不加v-，但使用时要加v-；2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;input type=&quot;text&quot; v-focus&gt; --&gt; &lt;p&gt;&#123;&#123; number &#125;&#125;&lt;/p&gt; 自定义指令: &lt;p v-two-double.flag=&quot;number&quot;&gt;&lt;/p&gt; &lt;button @click=&quot;number += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;age += 1&quot;&gt;++&lt;/button&gt; &lt;hr&gt; 自动聚焦: &lt;input type=&quot;text&quot; v-focus v-if=&quot;flag&quot;&gt;&lt;br&gt; &lt;button @click=&quot;del&quot;&gt;移除元素&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // ctrl+shift+k 删除当前行 Vue.config.productionTip = false // 1、自定义指令什么时候会被执行 ? // - 指令与页面元素绑定成功时(页面一打开) // - 自定义指令所在的vue模板被重新解析时 // 函数式写法 Vue.directive(&#x27;two-double&#x27;, (el, binding) =&gt; &#123; el.innerText = binding.value * 2 &#125;) // Vue.directive(&#x27;focus&#x27;, (el, binding) =&gt; &#123; // // 聚焦失败 原因是此时元素并没有渲染到页面上 // el.focus() // &#125;) // 对象式写法 Vue.directive(&#x27;focus&#x27;, &#123; // 指令与元素成功绑定时调用 bind(el,binding)&#123; el.style.backgroundColor = &#x27;skyblue&#x27; &#125;, // 指令所在元素被插入页面时调用 inserted(el,binding)&#123; el.focus() &#125;, // 指令所在模板结构被重新解析时调用 update(el,binding) &#123; console.log(&#x27;update&#x27;) &#125;, unbind()&#123; console.log(&#x27;unbind&#x27;) &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; number: 1, age: 1, flag: true &#125;, methods: &#123; del()&#123; this.flag = false &#125; &#125;, // 局部自定义指令 // directives: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue组件组件化和模块化的区别模块化 站在代码逻辑的角度来划分 解决js依赖等问题 方便分层开发 保证每个模块职能单一 组件化 站在UI界面的角度来划分 方便将来UI组件的复用 全局组件第一种注册方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 在页面中使用组件 --&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;my-com&gt;&lt;/my-com&gt; &lt;/div&gt; &lt;script&gt; // 关闭生产环境下的vue提示 Vue.config.productionTip = false // 使用组件三步骤 // 1、通过Vue.extend(options)定义组件 // 2、通过Vue.component(&#x27;组件名&#x27;, 定义好的组件)注册全局组件 // 3、在页面结构中通过&lt;组件名&gt;&lt;/组件名&gt;使用组件 // 注意事项 // 1、template有且只能有一个根元素 // 2、不要写el属性 定义的组件都要交给vm管理 由vm中的el来决定服务于哪个容器 // 3、如果自定义组件名使用了驼峰命名法(myCom) 在页面中使用的时候要用-分割组件名并且转为小写(my-com) // 4、组件名不要使用已有的元素名称，比如：div、span都不行。 // 5、组件中的data必须定义为一个函数 函数中必须返回一个对象 避免组件在复用时 数据直接相互引用导致冲突问题 // 6、不用使用脚手架时，单标签会导致复用组件后续无法渲染的问题 // 7、组件中的this指向的是当前组件的实例对象 // 8、使用name配置项指定组件在开发者工具中呈现的名字 // 第一种注册方式 Vue.extend + Vue.component 结合 // 定义组件 let mycom = Vue.extend(&#123; // el: &#x27;#app&#x27;, 违背设计组件的初心 // template: 将来展示在页面上的结构 // name: &#x27;qwer&#x27;, 使用name配置项指定组件在开发者工具中呈现的名字 template: `&lt;div&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: &#x27;hello component&#x27; &#125; &#125;, methods: &#123; show()&#123; // this指向的是当前组件的实例对象 console.log(this); &#125; &#125;, &#125;) // 注册全局组件 Vue.component(&#x27;my-com&#x27;, mycom) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123;&#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 第二种注册方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;mycom1&gt;&lt;/mycom1&gt; &lt;/div&gt; &lt;!-- .vue文件中也是通过这种方式定义页面结构 --&gt; &lt;!-- template模板 只会将template中的内容渲染到页面上 不会将template标签渲染到页面上 --&gt; &lt;template id=&quot;mycom1&quot;&gt; &lt;div&gt; &lt;h1&gt;第三种注册方式&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 第二种注册方式 =&gt; template没有提示 // Vue.component(&#x27;mycom1&#x27;, Vue.extend(&#123; // template: &#x27;&lt;h1&gt;第二种注册方式&lt;/h1&gt;&#x27;, // &#125;)) // 简写 Vue.component(&#x27;组件名&#x27;, 配置对象) 内部会帮我们调用Vue.extend // Vue.component(&#x27;mycom1&#x27;, &#123; // template: &#x27;&lt;h1&gt;第二种注册方式&lt;/h1&gt;&#x27;, // &#125;) // 第三种注册方式 Vue.component(&#x27;mycom1&#x27;, &#123; template: &#x27;#mycom1&#x27; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件data详解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;/div&gt; &lt;script&gt; // 定义一个名为 button-counter 的新组件 Vue.component(&#x27;button-counter&#x27;, &#123; data() &#123; return &#123; count: 0 &#125; &#125;, template: &#x27;&lt;button v-on:click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27; &#125;) // 为什么data必须是一个函数且返回一个对象 // 如果是对象的话多个页面可能会复用这个组件 如果其中一个页面对组件data进行修改的话 其它页面的data也会发生变化 造成数据冲突 (引用问题) // 而定义成一个函数 每次返回一个新的对象 保证了对象的唯一性 避免了组件数据修改影响其他组件数据 var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123;&#125; &#125;, components: &#123; &#125;, methods: &#123;&#125; &#125;); // var obj = &#123;x:100, y:100&#125; // var obj2 = obj // obj2.x = 1000 // console.log(obj); // &#123;x:1000, y:100&#125; // =================================== // function getObj()&#123; // return &#123;x: 100, y:100&#125; // &#125; // var obj = getObj() // var obj2 = getObj() // obj2.x = 1000 // console.log(obj); // &#123;x:100, y:100&#125; &lt;/script&gt;&lt;/body&gt; &lt;/html&gt; 局部组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器 --&gt; &lt;div id=&quot;app&quot;&gt; &lt;mycom&gt;&lt;/mycom&gt; &lt;mycom2&gt;&lt;/mycom2&gt; &lt;/div&gt; &lt;!-- 模板 --&gt; &lt;template id=&quot;tmpl&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; let mycom = Vue.extend(&#123; template: &#x27;#tmpl&#x27;, data()&#123; return &#123; msg: &#x27;局部组件注册&#x27; &#125; &#125; &#125;) let mycom2 = Vue.extend(&#123; template: &#x27;#tmpl&#x27;, data()&#123; return &#123; msg: &#x27;局部组件注册222&#x27; &#125; &#125; &#125;) var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; mycom, mycom2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 嵌套组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;app&gt;&lt;/app&gt; --&gt; &lt;/div&gt; &lt;template id=&quot;bwm&quot;&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;template id=&quot;car&quot;&gt; &lt;div&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;bwm&gt;&lt;/bwm&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id=&quot;app2&quot;&gt; &lt;div&gt; &lt;h1 @click=&#x27;show&#x27;&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;car&gt;&lt;/car&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.config.productionTip = false // 宝马组件 let bwm = Vue.extend(&#123; template: &#x27;#bwm&#x27;, data() &#123; return &#123; msg: &#x27;宝马最新款x7只需要100w&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;仅仅100w 心动不如行动&#x27;); &#125; &#125;, &#125;) // 车组件 let car = Vue.extend(&#123; template: &#x27;#car&#x27;, data() &#123; return &#123; msg: &#x27;男人必须有一辆爱车~&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;比如说劳斯莱斯&#x27;); &#125; &#125;, components: &#123; bwm &#125; &#125;) // App组件 let App = Vue.extend(&#123; template: &#x27;#app2&#x27;, data() &#123; return &#123; msg: &#x27;app2&#x27; &#125; &#125;, methods: &#123; show() &#123; console.log(&#x27;app2&#x27;); &#125; &#125;, components: &#123; car &#125; &#125;) var vm = new Vue(&#123; template: &#x27;&lt;App&gt;&lt;/App&gt;&#x27;, components: &#123; App &#125;, data: &#123;&#125;, methods: &#123;&#125; &#125;).$mount(&#x27;#app&#x27;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue 生命周期12345678910111213141516171819beforeCreate(创建前): 在实例初始化之后，数据代理和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods, data等上的方法和数据，这个钩子一般不会做太多功能，会初始化自己的生命周期，事件方法如：$on $emitcreated(创建完成): 此时已经完成了数据响应式监听和数据代理，可以获取数据和调用方法 但是DOM未渲染 在这个周期里面，可以去发送请求, 因为请求是异步的，不会阻碍实例加载，除非是那些同步操走才会导致页面空白。站在这个角度说来，在这个周期里面进行请求，渲染速度反而会更快。beforeMount(挂载前): 检测有没有template属性 有的话会把template渲染成一个render函数，开始解析模板，生成虚拟dom，没有则将外部的html作为模板进行解析。此时数据虽然初始化完成，DOM未完成挂载，页面还不能显示解析好的内容，数据的双向绑定还是显示&#123;&#123;&#125;&#125;上下两者中间还有一个创建vm.$el保存真实dom的过程，将来虚拟dom对比发现可复用的元素，就从该属性身上取出来渲染 同学们切记 !!!mounted(挂载完成): 数据和真实DOM都完成挂载，这个周期适合执行初始化需要操作DOM的方法。至此初始化操作完成，一般在此进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作beforeUpdate(更新前): 只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，页面和数据没有同步，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。中间还有个虚拟DOM对比的过程，根据新数据，生成新的虚拟DOM，随后与旧的虚拟DOM进行比较，最终完成页面更新，如果真实DOM可以复用 则从vm.$el中取出对应的真实DOM直接渲染 即:完成了Model =&gt; View的更新，同学们切记 !!!updated(更新完成): 只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。此时页面和数据保持同步beforeDestroy(销毁前): 这个周期是在组件销毁之前执行，此时: vm中所有的: data、methods、指令等等，都处于可用状态，马上要执行销毁过程，一般在此阶段:关闭定时器、取消订阅消息、解绑自定义事件等收尾操作destroyed(销毁完成): 在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，自定义事件会被移除 vue 动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时，元素 动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active, .v-leave-active &#123; transition: all .5s ease &#125; .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(150px); &#125; .my-enter-active, .my-leave-active &#123; transition: all .5s cubic-bezier(0, 1.95, .89, .38) &#125; &lt;/style&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&#x27;flag = !flag&#x27;&gt;Toggle&lt;/button&gt; &lt;!-- 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;transition&gt; &lt;h3 v-if=&#x27;flag&#x27;&gt;有些同学的心已经到家了&lt;/h3&gt; &lt;/transition&gt; &lt;hr&gt; &lt;!-- 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。 如果需要自定义类名 可以通过name属性: name=&#x27;my&#x27; .my-enter --&gt; &lt;transition name=&#x27;my&#x27;&gt; &lt;h3 v-if=&#x27;flag&#x27;&gt;有些同学的心已经到家了&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; flag: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue2响应式原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// vue2.x 双向数据绑定原理是通过Objcet.defineProperty来实现的// 这种方式有缺点: 数组的长度 数组的内容发生变化检测不到let obj = &#123; name: &#x27;zs&#x27;, age: 18, phone: &#123; name: &#x27;iphone&#x27; &#125;&#125;// let obj = [1, 2, 3, 4, 5]// 视图更新的方法function render() &#123; console.log(&#x27;视图更新了 ~&#x27;);&#125;let methods = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;, &#x27;splice&#x27;]// 将数组的原型保存一份let arrProto = Array.prototype// 创建原型 将数组原型拷贝一份let proto = Object.create(arrProto)// 重写数组的方法methods.forEach(method =&gt; &#123; proto[method] = function () &#123; // AOP 面向切面编程 // 改变了数组的数据 arrProto[method].call(this, ...arguments) // 重新渲染视图 render() &#125;&#125;)// 观察者模式 function observe(obj) &#123; // 判断一个对象是不是数组 // if(Object.prototype.toString.call(obj) === &#x27;[object Array]&#x27;)&#123; if (Array.isArray(obj)) &#123; // 让观测的对象的原型和我们自己重写的原型建立关系 obj.__proto__ = proto return; &#125; // 如果观察的是一个对象的话 对其属性进行响应式监听(set、get) if (Object.prototype.toString.call(obj) === &#x27;[object Object]&#x27;) &#123; // 取出对象中的每一个键和值 for (let key in obj) &#123; // 调用响应式处理函数 defineReactive(obj, key, obj[key]) &#125; &#125;&#125;// 观察obj对象observe(obj)// 响应式处理// Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。function defineReactive(obj, key, val) &#123; // 检测对象的属性值是否还是对象 observe(val) Object.defineProperty(obj, key, &#123; // 获取 get() &#123; return val &#125;, // 设置 set(newVal) &#123; // 检测设置的值是不是对象 observe(newVal) // 新值和旧值不相等的时候 if (newVal !== val) &#123; // 覆盖掉原来的val值 val = newVal // 通知render函数重新渲染视图 render() &#125; &#125; &#125;)&#125;// obj.name = &#x27;lisi&#x27;// obj.age = 20// console.log(obj.name, obj.age);// 至此 基本可以实现数据发生变化 视图更新的效果// 但是 如果数据有多层呢 也就是属性对应的值也是对象?// obj.phone.name = &#x27;huawei&#x27;// console.log(obj.phone.name);// 修改的值和原来的值一样 不需要重新渲染视图// obj.phone.name = &#x27;iphone&#x27;// 如果重新为对象obj的phone赋值一个新的对象呢? 视图要重新渲染// obj.phone = &#123;name: &#x27;huawei&#x27;&#125;// 并且当修改新的对象的属性值时 视图也要重新渲染// obj.phone.name = &#x27;zs&#x27;// 为对象新增属性值呢? 也是没有办法监测到的// obj.sex = &#x27;man&#x27;// $set来解决这个function $myset(obj, key, val)&#123; if(Array.isArray(obj))&#123; return obj.splice(key, val) &#125; defineReactive(obj, key, val)&#125;// $myset(obj, &#x27;sex&#x27;, &#x27;man&#x27;)// 修改新增的属性值 视图也能更新// obj.sex = &#x27;woman&#x27;// obj.phone = Object.assign(obj.phone, &#123;price: &#x27;666&#x27;&#125;)// obj.phone.price = 888// obj.phone = &#123;...obj.phone, ...&#123;price: &#x27;666&#x27;&#125;&#125;// obj.phone.price = &#x27;888&#x27;// 以后vue涉及到给data中的对象新增属性时 有三种方式// 1、this.$set() || Vue.set()// 2、obj = Object.assign(原对象, 新对象(新增的属性:值))// 2、obj = &#123;...原对象, ...新对象(新增的属性:值)&#125;// =================== 数组 ======================// 数组的响应式数据处理依赖的并不是Object.defineProperty 而是对数组的能够引起数据变化的方法进行重写// obj.push(6)// obj.length ++ // obj[0] = 88// $myset(obj, &#x27;0&#x27;, 66) props (父传子)父组件要正向地向子组件传递数据或参数，子组件收到后，根据传递过来的数据不同，渲染不同的页面内容，或者执行操作。这个正向传递数据的过程是通过props来实现的。子组件使用props来声明需要从父组件接受的数据。 注意:1、所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。2、每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 两种常见的试图变更一个 prop 的情形1、这个 prop 用来传递一个初始值 这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值2、这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性 nextTick作用: 在下次 DOM 更新循环结束之后执行其指定的回调。应用场景:1、在修改数据之后，要基于更新后的新dom进行某些操作时，可以立即使用这个方法，获取更新后的 DOM。2、在created中需要操作dom，此时dom并没有加载完毕 Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 是异步执行 DOM 更新的，简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。 mixinmixinVue.mixin给我们提供了一种混入Vue实例的方法，创建了混入对象之后，我们自定义的方法或者变量可以很轻松的挂载在Vue实例上，给我们带来方便 Vue.mixin为我们提供了两种混入方式：局部混入和全局混入局部混入：顾名思义就是部分混入，也就是只有引入了mixin的混入对象才可以使用，并且只有在引入了mixin混入对象的组件中才生效 全局混入：全局混入我们只需要把mixin.js引入到main.js中，然后将mixin放入到Vue.mixin()方法中即可；全局混入更为便捷，我们将不用在子组件声明，全局混入将会影响每一个组件的实例，使用的时候需要小心谨慎；这样全局混入之后，我们可以直接在组件中通过this.变量&#x2F;方法来调用mixin混入对象的变量&#x2F;方法； mixin可以定义公用的变量或方法，但是mixin中的数据是不共享的，也就是每个组件中的mixin实例都是不一样的，都是单独存在的个体，不存在相互影响的； mixin合并策略1、datamixins中的data会合并到data中，有冲突的话，data中数据覆盖mixins中的数据。 2、methods、components 和 directivesmethods、components 和 directives会执行，但有冲突时，组件中的methods、components 和 directives会覆盖 mixins 中的methods、components 和 directives。 3、特殊的钩子函数（生命周期） 组件和mixin的生命周期都要执行，但是mixin的生命周期优先于组件生命周期执行mixin beforeCreate -&gt; component beforeCreate -&gt; mixin created -&gt; component created 动态组件什么是动态组件？ 动态组件指的是动态切换组件的显示与隐藏 如何实现？vue提供了一个内置的组件，专门用来实现动态组件的渲染 123456789101112131415161718192021&lt;button @click=&quot;comName=&#x27;MyLeft&#x27;&quot;&gt;显示Left组件&lt;/button&gt;&lt;button @click=&quot;comName=&#x27;MyRight&#x27;&quot;&gt;显示Right组件&lt;/button&gt;&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;&lt;script&gt;import MyLeft from &#x27;@/components/Left.vue&#x27;import MyRight from &#x27;@/components/Right.vue&#x27;export default &#123; // 组件的交互 name: &#x27;App&#x27;, data() &#123; return &#123; comName: &#x27;MyLeft&#x27;, &#125; &#125;, components: &#123; MyLeft, MyRight, &#125;,&#125;&lt;/script&gt; keep-alive12345678910111213141516171819202122&lt;script&gt;export default &#123; name: &#x27;left&#x27;, data() &#123; return &#123; count: 0, &#125;; &#125;, created() &#123; console.log(&quot;left组件被创建了&quot;); &#125;, destroyed() &#123; console.log(&quot;left组件被销毁了&quot;); &#125;, deactivated() &#123; console.log(&quot;组件被缓存了&quot;); &#125;, activated() &#123; console.log(&quot;组件被激活了&quot;); &#125;,&#125;;&lt;/script&gt; devServer代理跨域 vue.config.js配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const path = require(&quot;path&quot;);function resolve(dir) &#123; return path.join(__dirname, dir);&#125;module.exports = &#123; chainWebpack: config =&gt; &#123; config.resolve.alias .set(&quot;@&quot;, resolve(&quot;src&quot;)) .set(&quot;assets&quot;, resolve(&quot;src/assets&quot;)) .set(&quot;components&quot;, resolve(&quot;src/components&quot;)) .set(&quot;base&quot;, resolve(&quot;baseConfig&quot;)) .set(&quot;public&quot;, resolve(&quot;public&quot;)); &#125;, pages: &#123; index: &#123; // page 的入口 entry: &#x27;src/index.js&#x27;, &#125; &#125;, // 关闭eslint语法校验 lintOnSave: false, devServer: &#123; // 代理的方式配置跨域 // 缺点: // 1、会先从本地public下查找有没有对应接口的文件 如果有 先返回本地的文件数据 没有再去发起请求访问服务器的数据 (优先匹配前端资源) // 2、没法配置多个代理 // proxy: &#x27;http://localhost:3000/&#x27;, proxy: &#123; // 正则匹配所有以&#x27;/api&#x27;开头的请求路径 &#x27;/api&#x27;: &#123; // http://localhost:8080/api/teachers // http://localhost:3000/teachers // target: 代理目标的基础路径 // http://localhost:8080/teachers target: &#x27;http://localhost:3000/&#x27;, // 路径重写 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; &#125;, // ws：websocket // ws: true, // 改变源, 也就是控制host // changeOrigin: true &#125;, &#x27;/v1&#x27;: &#123; // target: 代理目标的基础路径 target: &#x27;http://localhost:3001&#x27;, // 路径重写 pathRewrite: &#123; &#x27;^/v1&#x27;: &#x27;&#x27; &#125; &#125;, &#125; &#125;&#125; 路由vue-routervue 的一个插件库，是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目 中组件的切换。 1234567891011121314151617181920212223242526272829303132基本使用安装vue-router，命令：npm i vue-router@3引入插件: import VueRouter form &#x27;vue-router&#x27;应用插件：Vue.use(VueRouter)编写router配置项：//引入VueRouterimport VueRouter from &#x27;vue-router&#x27;//引入Vueimport Vue from &#x27;vue&#x27;//使用vueRouterVue.use(VueRouter)//引入路由组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;//创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home &#125; ]&#125;)//暴露routerexport default router//main.js中引入挂载router 实现切换（active-class可配置高亮样式）1&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 指定展示位置1&lt;router-view&gt;&lt;/router-view&gt; 路由注意点路由组件通常存放在pages或者view文件夹，一般组件(可复用)通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载（keep-alive）。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。 123456789101112131415router : 是路由操作对象，只写对象route : 路由信息对象，只读对象// 操作 路由跳转this.$router.push(&#123; name:&#x27;hello&#x27;, params:&#123; name:&#x27;word&#x27;, age:&#x27;11&#x27; &#125;&#125;)// 读取 路由参数接收this.name = this.route.params.name;this.age = this.route.params.age; 嵌套路由（多级路由）12345678910111213141516171819202122232425routes:[ &#123; path:&#x27;/about&#x27;, component:About, &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ //通过children配置子级路由 &#123; path:&#x27;news&#x27;, //此处一定不要写：/news component:News &#125;, &#123; path:&#x27;message&#x27;,//此处一定不要写：/message component:Message &#125;, &#123; path: &#x27;user&#x27;, // 路由懒加载写法 component:()=&gt; import(/*webpackChunkName*:&#x27;user&#x27;/, User) &#125; ] &#125;] 路由懒加载懒加载简单来说就是延迟加载或按需加载，就是用到的时候再进行加载。 作用: 首屏组件加载速度更快一些，解决白屏问题；更好的客户体验；也是性能优化的一种方式； 123456789101112131415161718192021222324252627const routes = [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/home&#x27; &#125;, &#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, // 首屏没有做路由懒加载 component: HomeView &#125;, &#123; path: &#x27;/center&#x27;, name: &#x27;center&#x27;, // 路由懒加载: 懒加载简单来说就是延迟加载或按需加载，就是用到的时候再进行加载。 // 作用: 首屏组件加载速度更快一些，解决白屏问题；更好的客户体验； // 也是性能优化的一种方式； component: () =&gt; import(/* webpackChunkName: &quot;center&quot; */ &#x27;../views/Center.vue&#x27;) &#125;, &#123; path: &#x27;/search&#x27;, component: ()=&gt; import(&#x27;../views/Search.vue&#x27;) &#125;]const router = new VueRouter(&#123; routes&#125;) 路由的query参数1234567891011121314151617&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt;接收参数$route.query.id$route.query.title 路由的params参数动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。 在 vue-router 中使用英文的冒号（:）来定义路由的参数项 配置路由，声明接收params参数 1234567891011121314151617181920&#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; component:Message, children:[ &#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数 component:Detail &#125; ] &#125; ]&#125; 传递参数 12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数 123$route.params.id$route.params.title 路由守卫用：对路由进行权限控制 分类：全局守卫、独享守卫、组件内守卫 全局守卫 123456789101112131415161718192021222324 //全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;beforeEach&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;username&#x27;) === &#x27;admin&#x27;)&#123; //权限控制的具体规则 next() //放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() //放行 &#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123; console.log(&#x27;afterEach&#x27;,to,from) if(to.meta.title)&#123; document.title = to.meta.title //修改网页的title &#125;else&#123; document.title = &#x27;vue_test&#x27; &#125;&#125;) 独享守卫: 12345678910111213 beforeEnter(to,from,next)&#123; console.log(&#x27;beforeEnter&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;username&#x27;) === &#x27;admin&#x27;)&#123; next() &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() &#125;&#125; 组件内守卫： 123456 //进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125; 路由器的两种工作模式 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。hash模式：地址中永远带着#号，不美观 。若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。兼容性较好。history模式：地址干净，美观 。兼容性和hash模式相比略差。底层是h5 api history对象应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。可以安装connect-history-api-fallback插件解决 vuex什么是vuex？vue中实现集中式状态（数据）管理的vue插件（vue.use(vuex)），对vue应用中多个组件的共享状态进行集中式管理（读&#x2F;写），是一种任意组件之间通信的方式，适用于较大型项目 使用场景？1、多个视图依赖于同一状态 2、来自不同视图的行为需要变更同一状态 Vuex的工作流程一、安装vuex npm i vuex@3 二、引入Vue，引入VueX，Vue.use(VueX) 三、在项目创建store文件夹，及index.js定义相关的vuex的state，getters，actions，mutations， 并创建vuex实例：const sotre &#x3D; new Vue.Store({state，getters，actions，mutations}) 四、在入口文件main.js中引入store,并在根实例注册挂载 五、在任意组件中，通过this.$store.state就可以访问到共享数据 六、当通过组件要修改store中的数据时， 1231. 如果该操作是同步的并且不需要共用，可以用this.$store.commit()来触发mutations, 只有mutations才可以直接更改state共享数据2. mutations中只能有同步操作，不能有异步操作3. 如果修改数据的操作是异步的，通过this.$store.dispatch()触发actions, actions中可以发起异步请求，获取数据后，再调用 commit触发mutations,通过mutations修改共享数据 辅助函数mapState当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;div&gt; &lt;p&gt; 商品名称: &#123;&#123;goodName&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品价格: &#123;&#123;goodPrice&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品描述: &#123;&#123;goodDesc&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品最新描述: &#123;&#123;goodNewDesc&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引入辅助函数// mapState: 映射状态import &#123; mapState, mapGetters &#125; from &#x27;vuex&#x27;export default &#123; name: &#x27;counter&#x27;, data() &#123; return &#123; n: &#x27;&#x27; &#125; &#125;, methods: &#123;&#125;, computed: &#123; // 封装思路 // function mapState(obj)&#123; // 需要取出对象的键值对 // for(let key in obj)&#123; // return function [key]()&#123; // return this.$store.state[obj[key]] // &#125; // &#125; // &#125; // mapState(&#123;name: &#x27;goodName&#x27;, price: &#x27;goodPrice&#x27;&#125;) // 手写计算属性 + state // name() &#123; // return this.$store.state.goodName // &#125;, // price() &#123; // return this.$store.state.goodPrice // &#125;, // desc() &#123; // return this.$store.state.goodDesc // &#125; // 生成计算属性 =&gt; 对象的写法 // 传入的对象键为: 生成的计算属性名字 // 传入的对象值为: 需要访问state中的哪个属性 // ...mapState(&#123; name: &#x27;goodName&#x27;, price: &#x27;goodPrice&#x27;, desc: &#x27;goodDesc&#x27; &#125;), // goodName() &#123; // return this.$store.state.goodName // &#125;, // goodPrice() &#123; // return this.$store.state.goodPrice // &#125;, // goodDesc() &#123; // return this.$store.state.goodDesc // &#125;, // 当计算属性的名字和需要访问state的属性名字一样时 可以使用数组的写法 ...mapState([&#x27;goodName&#x27;, &#x27;goodPrice&#x27;, &#x27;goodDesc&#x27;]) &#125;, mounted() &#123; // 返回值是一个对象 &#123;name:function&#125; let res = mapState(&#123; name: &#x27;goodName&#x27; &#125;) console.log(res) &#125;&#125;&lt;/script&gt; mapGetters 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div&gt; &lt;p&gt; 商品名称: &#123;&#123;goodName&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品价格: &#123;&#123;goodPrice&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品描述: &#123;&#123;goodDesc&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品最新描述: &#123;&#123;goodNewDesc&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引入辅助函数// mapState: 映射状态import &#123; mapState, mapGetters &#125; from &#x27;vuex&#x27;export default &#123; name: &#x27;counter&#x27;, data() &#123; return &#123; n: &#x27;&#x27; &#125; &#125;, methods: &#123;&#125;, computed: &#123; // 手写的计算属性 + getter // newDesc()&#123; // return this.$store.getters.goodNewDesc // &#125;, // newDesc()&#123; // return this.$store.getters.goodNewDesc // &#125;, // newDesc()&#123; // return this.$store.getters.goodNewDesc // &#125;, // 利用辅助函数生成 // 对象写法 // ...mapGetters(&#123;newDesc: &#x27;goodNewDesc&#x27;&#125;) // 数组写法 ...mapGetters([&#x27;goodNewDesc&#x27;]) &#125;, mounted() &#123; // 返回值是一个对象 &#123;name:function&#125; let res = mapGetters(&#123; newDesc: &#x27;goodNewDesc&#x27; &#125;) console.log(res) &#125;&#125;&lt;/script&gt; mapMutations 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div&gt; &lt;p&gt; 商品名称: &#123;&#123;goodName&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品价格: &#123;&#123;goodPrice&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品描述: &#123;&#123;goodDesc&#125;&#125; &lt;/p&gt; &lt;p&gt; 商品最新描述: &#123;&#123;goodNewDesc&#125;&#125; &lt;/p&gt; &lt;div&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入要涨价的金额&quot; v-model.number=&quot;money&quot;&gt; &lt;button @click=&#x27;increase(money)&#x27;&gt;涨价&lt;/button&gt; &lt;button @click=&#x27;increaseDouble(money)&#x27;&gt;翻倍的涨价&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引入辅助函数// mapState: 映射状态import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &#x27;vuex&#x27;export default &#123; name: &#x27;counter&#x27;, data() &#123; return &#123; money: &#x27;&#x27; &#125; &#125;, methods: &#123; // increase()&#123; // this.$store.commit(&#x27;INCREASE&#x27;, this.money) // &#125;, // 没有手动传参会将$event事件参数对象当作第二个参数传过去 // increase(e)&#123; // this.$store.commit(&#x27;INCREASE&#x27;, e) // &#125;, // 手动传参就使用我们的参数当作第二个参数传过去 // increase(money)&#123; // this.$store.commit(&#x27;INCREASE&#x27;, money) // &#125;, // 对象的写法 // ...mapMutations(&#123; increase: &#x27;INCREASE&#x27; &#125;) // 数组的写法 ...mapMutations([&#x27;increase&#x27;]), &#125;, computed: &#123; ...mapState([&#x27;goodName&#x27;, &#x27;goodPrice&#x27;, &#x27;goodDesc&#x27;]), ...mapGetters([&#x27;goodNewDesc&#x27;]) &#125;, mounted() &#123; // 返回值是一个对象 &#123;name:function&#125; let res = mapState(&#123; name: &#x27;goodName&#x27; &#125;) console.log(res) &#125;&#125;&lt;/script&gt; mapActions 123456// increaseDouble()&#123;// // 逻辑稍微复杂且需要共用 dispatch// this.$store.dispatch(&#x27;increaseDouble&#x27;, this.money)// &#125;// ...mapActions(&#123;increaseDouble: &#x27;increaseDouble&#x27;&#125;)...mapActions([&#x27;increaseDouble&#x27;]) 持久化在VUE项目中，由于是单页应用，vuex中的数据在页面刷新时就会被清除，所以我们要考虑怎样让vuex中的数据持久保存在浏览器中，至少不能每次刷新时都丢失登录状态，这篇文章介绍VUE项目中常用到的两种vuex持久化的方法，底层实现原理一直，方法不太一样，可以在项目中根据实际来区分方法一、浏览器监听+本地存储我们可以监听浏览器的刷新，在页面刷新时将vuex内的数据保存在本地存储中(根据项目需要可以考虑保存在sessionStorage或者localStorage中)在App.vue中，created生命周期写我们的监听方法 123window.addEventListener(&quot;beforeunload&quot;, () =&gt; &#123; sessionStorage.setItem(&quot;store&quot;, JSON.stringify(this.$store.state))&#125;) 然后在进入到created生命周期时，去到sessionStorage&#x2F;localStorage中的数据，将数据替换 到vuex中 123if(sessionStorage.getItem(&quot;store&quot;)) &#123; this.$store.replaceState(Object.assign(&#123;&#125;, this.$store.state, JSON.parse(sessionStorage.getItem(&#x27;store&#x27;))))&#125; 方法二、状态持久化插件推荐使用 vuex-persistedstate 插件使用方法如下1、在项目中安装该插件 cnpm i –save vuex-persistedstate2、在 src&#x2F;store&#x2F;index.js中引入该插件 import createPersistedState from ‘vuex-persistedstate’在vuex中使用 plugins: [createPersistedState()]整体代码如下 123456789101112131415161718192021import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;import createPersistedState from &#x27;vuex-persistedstate&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; plugins: [createPersistedState(&#123; storage: window.sessionStorage, // 默认位置是 localStorage reducer: (state) =&gt; &#123; return &#123; // 默认是全部缓存，在这里可以设置需要缓存的状态 ...state &#125; &#125; &#125;)], state: &#123; token: &#x27;&#x27; &#125;, mutations: &#123; &#125;,&#125;","categories":[],"tags":[]},{"title":"欢迎来到我的博客","slug":"hello-world","date":"2020-10-12T02:46:27.000Z","updated":"2023-03-31T07:12:30.841Z","comments":true,"path":"2020/10/12/hello-world/","link":"","permalink":"http://example.com/2020/10/12/hello-world/","excerpt":"","text":"介绍 世上有两句疑问：这个程序怎么不运行？这个程序怎么运行了？我的博客 记录与2022.9.1这意味着这是一个新的开始这里面包括了 vue2&#x2F;3 javascript React Html css Es6 还有Nodejs，一串代码往往伴随着优化，接下来让我们一起努力吧","categories":[],"tags":[]}],"categories":[],"tags":[]}